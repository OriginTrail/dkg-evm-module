{
  "address": "0x52a120370b113b270155E0E168B4A5269f03ABd7",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "hubAddress",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "AssetExpired",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "agreementId",
          "type": "bytes32"
        }
      ],
      "name": "CommitPhaseOngoing",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "agreementId",
          "type": "bytes32"
        }
      ],
      "name": "CommitPhaseSucceeded",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "agreementId",
          "type": "bytes32"
        }
      ],
      "name": "FirstEpochHasAlreadyEnded",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "assetStorage",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "NoPendingUpdate",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "assetStorage",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "latestStateIndex",
          "type": "uint256"
        }
      ],
      "name": "PendingUpdateFinalization",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "assetStorage",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "latestState",
          "type": "bytes32"
        }
      ],
      "name": "UpdateIsNotFinalized",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "assetContract",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint96",
          "name": "returnedTokenAmount",
          "type": "uint96"
        }
      ],
      "name": "AssetBurnt",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "assetContract",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "state",
          "type": "bytes32"
        }
      ],
      "name": "AssetMinted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "assetContract",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint96",
          "name": "tokenAmount",
          "type": "uint96"
        }
      ],
      "name": "AssetPaymentIncreased",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "assetContract",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "stateIndex",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint96",
          "name": "returnedTokenAmount",
          "type": "uint96"
        }
      ],
      "name": "AssetStateUpdateCanceled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "assetContract",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "stateIndex",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint96",
          "name": "updateTokenAmount",
          "type": "uint96"
        }
      ],
      "name": "AssetStateUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "assetContract",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint16",
          "name": "epochsNumber",
          "type": "uint16"
        },
        {
          "indexed": false,
          "internalType": "uint96",
          "name": "tokenAmount",
          "type": "uint96"
        }
      ],
      "name": "AssetStoringPeriodExtended",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "assetContract",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint96",
          "name": "tokenAmount",
          "type": "uint96"
        }
      ],
      "name": "AssetUpdatePaymentIncreased",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "assertionContract",
      "outputs": [
        {
          "internalType": "contract Assertion",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "burnAsset",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "cancelAssetStateUpdate",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "contentAssetStorage",
      "outputs": [
        {
          "internalType": "contract ContentAssetStorage",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "assertionId",
              "type": "bytes32"
            },
            {
              "internalType": "uint128",
              "name": "size",
              "type": "uint128"
            },
            {
              "internalType": "uint32",
              "name": "triplesNumber",
              "type": "uint32"
            },
            {
              "internalType": "uint96",
              "name": "chunksNumber",
              "type": "uint96"
            },
            {
              "internalType": "uint16",
              "name": "epochsNumber",
              "type": "uint16"
            },
            {
              "internalType": "uint96",
              "name": "tokenAmount",
              "type": "uint96"
            },
            {
              "internalType": "uint8",
              "name": "scoreFunctionId",
              "type": "uint8"
            },
            {
              "internalType": "bool",
              "name": "immutable_",
              "type": "bool"
            }
          ],
          "internalType": "struct ContentAssetStructs.AssetInputArgs",
          "name": "args",
          "type": "tuple"
        }
      ],
      "name": "createAsset",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "assertionId",
          "type": "bytes32"
        },
        {
          "internalType": "uint128",
          "name": "size",
          "type": "uint128"
        },
        {
          "internalType": "uint32",
          "name": "triplesNumber",
          "type": "uint32"
        },
        {
          "internalType": "uint96",
          "name": "chunksNumber",
          "type": "uint96"
        },
        {
          "internalType": "uint16",
          "name": "epochsNumber",
          "type": "uint16"
        },
        {
          "internalType": "uint96",
          "name": "tokenAmount",
          "type": "uint96"
        },
        {
          "internalType": "uint8",
          "name": "scoreFunctionId",
          "type": "uint8"
        },
        {
          "internalType": "bool",
          "name": "immutable_",
          "type": "bool"
        }
      ],
      "name": "createAssetWithVariables",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint16",
          "name": "epochsNumber",
          "type": "uint16"
        },
        {
          "internalType": "uint96",
          "name": "tokenAmount",
          "type": "uint96"
        }
      ],
      "name": "extendAssetStoringPeriod",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "hashingProxy",
      "outputs": [
        {
          "internalType": "contract HashingProxy",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "hub",
      "outputs": [
        {
          "internalType": "contract Hub",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint96",
          "name": "tokenAmount",
          "type": "uint96"
        }
      ],
      "name": "increaseAssetTokenAmount",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint96",
          "name": "tokenAmount",
          "type": "uint96"
        }
      ],
      "name": "increaseAssetUpdateTokenAmount",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "parametersStorage",
      "outputs": [
        {
          "internalType": "contract ParametersStorage",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "serviceAgreementStorageProxy",
      "outputs": [
        {
          "internalType": "contract ServiceAgreementStorageProxy",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "serviceAgreementV1",
      "outputs": [
        {
          "internalType": "contract ServiceAgreementV1",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "unfinalizedStateStorage",
      "outputs": [
        {
          "internalType": "contract UnfinalizedStateStorage",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "assertionId",
          "type": "bytes32"
        },
        {
          "internalType": "uint128",
          "name": "size",
          "type": "uint128"
        },
        {
          "internalType": "uint32",
          "name": "triplesNumber",
          "type": "uint32"
        },
        {
          "internalType": "uint96",
          "name": "chunksNumber",
          "type": "uint96"
        },
        {
          "internalType": "uint96",
          "name": "updateTokenAmount",
          "type": "uint96"
        }
      ],
      "name": "updateAssetState",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "version",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x1e55d95dcab1a392c73aa4d043191310bffcd092ed43d47d5c68a5e141588b01",
  "receipt": {
    "to": null,
    "from": "0xEfB65B890462206e3453dbd0bC8B2e6D6E0e7bD1",
    "contractAddress": "0x52a120370b113b270155E0E168B4A5269f03ABd7",
    "transactionIndex": 9,
    "gasUsed": "2604200",
    "logsBloom": "0x00000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000008000000000000000000000000000000000800000000000000000000100000000000200000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000080000000000000000000000000000000000000000004000000000000000000001000000000100000000000000000000100000000000000000000000000000000000000000000000000008000000000000000000100000",
    "blockHash": "0x9e89fefe9020f6c770b435e133d391fccc8ab973f0db8b9b579a25ea9c9a4c8e",
    "transactionHash": "0x1e55d95dcab1a392c73aa4d043191310bffcd092ed43d47d5c68a5e141588b01",
    "logs": [
      {
        "transactionIndex": 9,
        "blockNumber": 37384564,
        "transactionHash": "0x1e55d95dcab1a392c73aa4d043191310bffcd092ed43d47d5c68a5e141588b01",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000efb65b890462206e3453dbd0bc8b2e6d6e0e7bd1",
          "0x0000000000000000000000003a22c8bc68e98b0faf40f349dd2b2890fae01484"
        ],
        "data": "0x000000000000000000000000000000000000000000000000001e11a511450980000000000000000000000000000000000000000000000000848ce4d192330763000000000000000000000000000000000000000000000c05ec97701e840ba457000000000000000000000000000000000000000000000000846ed32c80edfde3000000000000000000000000000000000000000000000c05ecb581c39550add7",
        "logIndex": 18,
        "blockHash": "0x9e89fefe9020f6c770b435e133d391fccc8ab973f0db8b9b579a25ea9c9a4c8e"
      }
    ],
    "blockNumber": 37384564,
    "cumulativeGasUsed": "2793200",
    "status": 1,
    "byzantium": true
  },
  "args": ["0x224aEC6891d26e994D4Dbf207aE099ca029b3E67"],
  "numDeployments": 1,
  "solcInputHash": "f39b719713632a929f2674749808e322",
  "metadata": "{\"compiler\":{\"version\":\"0.8.16+commit.07a7930e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"hubAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"AssetExpired\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"agreementId\",\"type\":\"bytes32\"}],\"name\":\"CommitPhaseOngoing\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"agreementId\",\"type\":\"bytes32\"}],\"name\":\"CommitPhaseSucceeded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"agreementId\",\"type\":\"bytes32\"}],\"name\":\"FirstEpochHasAlreadyEnded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetStorage\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"NoPendingUpdate\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetStorage\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"latestStateIndex\",\"type\":\"uint256\"}],\"name\":\"PendingUpdateFinalization\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetStorage\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"latestState\",\"type\":\"bytes32\"}],\"name\":\"UpdateIsNotFinalized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"assetContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"returnedTokenAmount\",\"type\":\"uint96\"}],\"name\":\"AssetBurnt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"assetContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"state\",\"type\":\"bytes32\"}],\"name\":\"AssetMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"assetContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"tokenAmount\",\"type\":\"uint96\"}],\"name\":\"AssetPaymentIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"assetContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"stateIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"returnedTokenAmount\",\"type\":\"uint96\"}],\"name\":\"AssetStateUpdateCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"assetContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"stateIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"updateTokenAmount\",\"type\":\"uint96\"}],\"name\":\"AssetStateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"assetContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"epochsNumber\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"tokenAmount\",\"type\":\"uint96\"}],\"name\":\"AssetStoringPeriodExtended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"assetContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"tokenAmount\",\"type\":\"uint96\"}],\"name\":\"AssetUpdatePaymentIncreased\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"assertionContract\",\"outputs\":[{\"internalType\":\"contract Assertion\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burnAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelAssetStateUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contentAssetStorage\",\"outputs\":[{\"internalType\":\"contract ContentAssetStorage\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"assertionId\",\"type\":\"bytes32\"},{\"internalType\":\"uint128\",\"name\":\"size\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"triplesNumber\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"chunksNumber\",\"type\":\"uint96\"},{\"internalType\":\"uint16\",\"name\":\"epochsNumber\",\"type\":\"uint16\"},{\"internalType\":\"uint96\",\"name\":\"tokenAmount\",\"type\":\"uint96\"},{\"internalType\":\"uint8\",\"name\":\"scoreFunctionId\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"immutable_\",\"type\":\"bool\"}],\"internalType\":\"struct ContentAssetStructs.AssetInputArgs\",\"name\":\"args\",\"type\":\"tuple\"}],\"name\":\"createAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"assertionId\",\"type\":\"bytes32\"},{\"internalType\":\"uint128\",\"name\":\"size\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"triplesNumber\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"chunksNumber\",\"type\":\"uint96\"},{\"internalType\":\"uint16\",\"name\":\"epochsNumber\",\"type\":\"uint16\"},{\"internalType\":\"uint96\",\"name\":\"tokenAmount\",\"type\":\"uint96\"},{\"internalType\":\"uint8\",\"name\":\"scoreFunctionId\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"immutable_\",\"type\":\"bool\"}],\"name\":\"createAssetWithVariables\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"epochsNumber\",\"type\":\"uint16\"},{\"internalType\":\"uint96\",\"name\":\"tokenAmount\",\"type\":\"uint96\"}],\"name\":\"extendAssetStoringPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hashingProxy\",\"outputs\":[{\"internalType\":\"contract HashingProxy\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hub\",\"outputs\":[{\"internalType\":\"contract Hub\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint96\",\"name\":\"tokenAmount\",\"type\":\"uint96\"}],\"name\":\"increaseAssetTokenAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint96\",\"name\":\"tokenAmount\",\"type\":\"uint96\"}],\"name\":\"increaseAssetUpdateTokenAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"parametersStorage\",\"outputs\":[{\"internalType\":\"contract ParametersStorage\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"serviceAgreementStorageProxy\",\"outputs\":[{\"internalType\":\"contract ServiceAgreementStorageProxy\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"serviceAgreementV1\",\"outputs\":[{\"internalType\":\"contract ServiceAgreementV1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unfinalizedStateStorage\",\"outputs\":[{\"internalType\":\"contract UnfinalizedStateStorage\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"assertionId\",\"type\":\"bytes32\"},{\"internalType\":\"uint128\",\"name\":\"size\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"triplesNumber\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"chunksNumber\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"updateTokenAmount\",\"type\":\"uint96\"}],\"name\":\"updateAssetState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/assets/ContentAsset.sol\":\"ContentAsset\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xa94b34880e3c1b0b931662cb1c09e5dfa6662f31cba80e07c5ee71cd135c9673\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\",\"keccak256\":\"0x24b04b8aacaaf1a4a0719117b29c9c3647b1f479c5ac2a60f5ff1bb6d839c238\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20.sol\\\";\\nimport \\\"../../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\nabstract contract ERC20Burnable is Context, ERC20 {\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public virtual {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n     * allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for ``accounts``'s tokens of at least\\n     * `amount`.\\n     */\\n    function burnFrom(address account, uint256 amount) public virtual {\\n        _spendAllowance(account, _msgSender(), amount);\\n        _burn(account, amount);\\n    }\\n}\\n\",\"keccak256\":\"0x0d19410453cda55960a818e02bd7c18952a5c8fe7a3036e81f0d599f34487a7b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/ERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./extensions/IERC721Metadata.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: address zero is not a valid owner\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _owners[tokenId];\\n        require(owner != address(0), \\\"ERC721: invalid token ID\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        _requireMinted(tokenId);\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not token owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        _requireMinted(tokenId);\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: caller is not token owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: caller is not token owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n\\n        _afterTokenTransfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n\\n        _afterTokenTransfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n\\n        _afterTokenTransfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual {\\n        require(owner != operator, \\\"ERC721: approve to caller\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Reverts if the `tokenId` has not been minted yet.\\n     */\\n    function _requireMinted(uint256 tokenId) internal view virtual {\\n        require(_exists(tokenId), \\\"ERC721: invalid token ID\\\");\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n}\\n\",\"keccak256\":\"0x0b606994df12f0ce35f6d2f6dcdde7e55e6899cdef7e00f180980caa81e3844e\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xed6a749c5373af398105ce6ee3ac4763aa450ea7285d268c85d9eeca809cdb1f\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xa82b58eca1ee256be466e536706850163d2ec7821945abd6b4778cfb3bee37da\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x75b829ff2f26c14355d1cba20e16fe7b29ca58eb5fef665ede48bc0f9c6c74b9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd6153ce99bcdcce22b124f755e72553295be6abcd63804cfdffceb188b8bef10\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\",\"keccak256\":\"0xaf159a8b1923ad2a26d516089bceca9bdeaeacd04be50983ea00ba63070f08a3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function verifyCalldata(\\n        bytes32[] calldata proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be proved to be a part of a Merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and the sibling nodes in `proof`,\\n     * consuming from one or the other at each step according to the instructions given by\\n     * `proofFlags`.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x596ed72a251d391b814a4aa19d7acb02ebdcc92ba27d3fff74a6f0c158b12ab7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xd10975de010d89fd1c78dc5e8a9a7e7f496198085c151648f20cba166b32582b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"contracts/Assertion.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport {AssertionStorage} from \\\"./storage/AssertionStorage.sol\\\";\\nimport {ContractStatus} from \\\"./abstract/ContractStatus.sol\\\";\\nimport {Initializable} from \\\"./interface/Initializable.sol\\\";\\nimport {Named} from \\\"./interface/Named.sol\\\";\\nimport {Versioned} from \\\"./interface/Versioned.sol\\\";\\nimport {AssertionStructs} from \\\"./structs/AssertionStructs.sol\\\";\\n\\ncontract Assertion is Named, Versioned, ContractStatus, Initializable {\\n    event AssertionCreated(bytes32 indexed assertionId, uint128 size, uint32 triplesNumber, uint96 chunksNumber);\\n\\n    string private constant _NAME = \\\"Assertion\\\";\\n    string private constant _VERSION = \\\"1.0.1\\\";\\n\\n    AssertionStorage public assertionStorage;\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(address hubAddress) ContractStatus(hubAddress) {}\\n\\n    function initialize() public onlyHubOwner {\\n        assertionStorage = AssertionStorage(hub.getContractAddress(\\\"AssertionStorage\\\"));\\n    }\\n\\n    function name() external pure virtual override returns (string memory) {\\n        return _NAME;\\n    }\\n\\n    function version() external pure virtual override returns (string memory) {\\n        return _VERSION;\\n    }\\n\\n    function createAssertion(\\n        bytes32 assertionId,\\n        uint128 size,\\n        uint32 triplesNumber,\\n        uint96 chunksNumber\\n    ) external onlyContracts {\\n        AssertionStorage ans = assertionStorage;\\n\\n        require(assertionId != bytes32(0), \\\"Assertion ID cannot be empty\\\");\\n        require(size != 0, \\\"Size cannot be 0\\\");\\n        require(triplesNumber != 0, \\\"Triples number cannot be 0\\\");\\n        require(chunksNumber != 0, \\\"Chunks number cannot be 0\\\");\\n\\n        ans.createAssertion(assertionId, size, triplesNumber, chunksNumber);\\n\\n        emit AssertionCreated(assertionId, size, triplesNumber, chunksNumber);\\n    }\\n}\\n\",\"keccak256\":\"0xbf236472ca3126b0ae799d60a0c546bff9e7115fe3fb14eb3fda88604b166bb8\",\"license\":\"MIT\"},\"contracts/CommitManagerV1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport {HashingProxy} from \\\"./HashingProxy.sol\\\";\\nimport {ScoringProxy} from \\\"./ScoringProxy.sol\\\";\\nimport {Staking} from \\\"./Staking.sol\\\";\\nimport {IdentityStorage} from \\\"./storage/IdentityStorage.sol\\\";\\nimport {ParametersStorage} from \\\"./storage/ParametersStorage.sol\\\";\\nimport {ProfileStorage} from \\\"./storage/ProfileStorage.sol\\\";\\nimport {ServiceAgreementStorageProxy} from \\\"./storage/ServiceAgreementStorageProxy.sol\\\";\\nimport {ShardingTableStorage} from \\\"./storage/ShardingTableStorage.sol\\\";\\nimport {StakingStorage} from \\\"./storage/StakingStorage.sol\\\";\\nimport {ContractStatus} from \\\"./abstract/ContractStatus.sol\\\";\\nimport {Initializable} from \\\"./interface/Initializable.sol\\\";\\nimport {Named} from \\\"./interface/Named.sol\\\";\\nimport {Versioned} from \\\"./interface/Versioned.sol\\\";\\nimport {ContentAssetErrors} from \\\"./errors/assets/ContentAssetErrors.sol\\\";\\nimport {GeneralErrors} from \\\"./errors/GeneralErrors.sol\\\";\\nimport {ServiceAgreementErrorsV1} from \\\"./errors/ServiceAgreementErrorsV1.sol\\\";\\nimport {ServiceAgreementStructsV1} from \\\"./structs/ServiceAgreementStructsV1.sol\\\";\\n\\ncontract CommitManagerV1 is Named, Versioned, ContractStatus, Initializable {\\n    event CommitSubmitted(\\n        address indexed assetContract,\\n        uint256 indexed tokenId,\\n        bytes keyword,\\n        uint8 hashFunctionId,\\n        uint16 epoch,\\n        uint72 indexed identityId,\\n        uint40 score\\n    );\\n\\n    string private constant _NAME = \\\"CommitManagerV1\\\";\\n    string private constant _VERSION = \\\"1.0.0\\\";\\n\\n    bool[4] public reqs = [false, false, false, false];\\n\\n    HashingProxy public hashingProxy;\\n    ScoringProxy public scoringProxy;\\n    Staking public stakingContract;\\n    IdentityStorage public identityStorage;\\n    ParametersStorage public parametersStorage;\\n    ProfileStorage public profileStorage;\\n    ServiceAgreementStorageProxy public serviceAgreementStorageProxy;\\n    ShardingTableStorage public shardingTableStorage;\\n    StakingStorage public stakingStorage;\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(address hubAddress) ContractStatus(hubAddress) {}\\n\\n    function initialize() public onlyHubOwner {\\n        hashingProxy = HashingProxy(hub.getContractAddress(\\\"HashingProxy\\\"));\\n        scoringProxy = ScoringProxy(hub.getContractAddress(\\\"ScoringProxy\\\"));\\n        stakingContract = Staking(hub.getContractAddress(\\\"Staking\\\"));\\n        identityStorage = IdentityStorage(hub.getContractAddress(\\\"IdentityStorage\\\"));\\n        parametersStorage = ParametersStorage(hub.getContractAddress(\\\"ParametersStorage\\\"));\\n        profileStorage = ProfileStorage(hub.getContractAddress(\\\"ProfileStorage\\\"));\\n        serviceAgreementStorageProxy = ServiceAgreementStorageProxy(\\n            hub.getContractAddress(\\\"ServiceAgreementStorageProxy\\\")\\n        );\\n        shardingTableStorage = ShardingTableStorage(hub.getContractAddress(\\\"ShardingTableStorage\\\"));\\n        stakingStorage = StakingStorage(hub.getContractAddress(\\\"StakingStorage\\\"));\\n    }\\n\\n    function name() external pure virtual override returns (string memory) {\\n        return _NAME;\\n    }\\n\\n    function version() external pure virtual override returns (string memory) {\\n        return _VERSION;\\n    }\\n\\n    function isCommitWindowOpen(bytes32 agreementId, uint16 epoch) public view returns (bool) {\\n        ServiceAgreementStorageProxy sasProxy = serviceAgreementStorageProxy;\\n        uint256 startTime = sasProxy.getAgreementStartTime(agreementId);\\n\\n        ParametersStorage params = parametersStorage;\\n        uint128 epochLength = sasProxy.getAgreementEpochLength(agreementId);\\n\\n        if (startTime == 0) revert ServiceAgreementErrorsV1.ServiceAgreementDoesntExist(agreementId);\\n        if (epoch >= sasProxy.getAgreementEpochsNumber(agreementId))\\n            revert ServiceAgreementErrorsV1.ServiceAgreementHasBeenExpired(\\n                agreementId,\\n                startTime,\\n                sasProxy.getAgreementEpochsNumber(agreementId),\\n                epochLength\\n            );\\n\\n        uint256 timeNow = block.timestamp;\\n        uint256 commitWindowDuration = (params.commitWindowDurationPerc() * epochLength) / 100;\\n\\n        if (epoch == 0) {\\n            return timeNow < (startTime + commitWindowDuration);\\n        }\\n\\n        return (timeNow >= (startTime + epochLength * epoch) &&\\n            timeNow < (startTime + epochLength * epoch + commitWindowDuration));\\n    }\\n\\n    function getTopCommitSubmissions(\\n        bytes32 agreementId,\\n        uint16 epoch\\n    ) external view returns (ServiceAgreementStructsV1.CommitSubmission[] memory) {\\n        ServiceAgreementStorageProxy sasProxy = serviceAgreementStorageProxy;\\n\\n        if (!sasProxy.serviceAgreementExists(agreementId))\\n            revert ServiceAgreementErrorsV1.ServiceAgreementDoesntExist(agreementId);\\n        if (epoch >= sasProxy.getAgreementEpochsNumber(agreementId))\\n            revert ServiceAgreementErrorsV1.ServiceAgreementHasBeenExpired(\\n                agreementId,\\n                sasProxy.getAgreementStartTime(agreementId),\\n                sasProxy.getAgreementEpochsNumber(agreementId),\\n                sasProxy.getAgreementEpochLength(agreementId)\\n            );\\n\\n        uint32 r0 = parametersStorage.r0();\\n\\n        ServiceAgreementStructsV1.CommitSubmission[]\\n            memory epochCommits = new ServiceAgreementStructsV1.CommitSubmission[](r0);\\n\\n        bytes32 epochSubmissionsHead = sasProxy.getV1AgreementEpochSubmissionHead(agreementId, epoch);\\n\\n        epochCommits[0] = sasProxy.getCommitSubmission(epochSubmissionsHead);\\n\\n        bytes32 commitId;\\n        uint72 nextIdentityId = epochCommits[0].nextIdentityId;\\n        uint8 submissionsIdx = 1;\\n        while ((submissionsIdx < r0) && (nextIdentityId != 0)) {\\n            commitId = keccak256(abi.encodePacked(agreementId, epoch, nextIdentityId));\\n            epochCommits[submissionsIdx] = sasProxy.getCommitSubmission(commitId);\\n\\n            nextIdentityId = epochCommits[submissionsIdx].nextIdentityId;\\n\\n            unchecked {\\n                submissionsIdx++;\\n            }\\n        }\\n\\n        return epochCommits;\\n    }\\n\\n    function submitCommit(ServiceAgreementStructsV1.CommitInputArgs calldata args) external {\\n        ServiceAgreementStorageProxy sasProxy = serviceAgreementStorageProxy;\\n\\n        bytes32 agreementId = hashingProxy.callHashFunction(\\n            args.hashFunctionId,\\n            abi.encodePacked(args.assetContract, args.tokenId, args.keyword)\\n        );\\n\\n        if (!sasProxy.serviceAgreementExists(agreementId))\\n            revert ServiceAgreementErrorsV1.ServiceAgreementDoesntExist(agreementId);\\n\\n        if (!reqs[0] && !isCommitWindowOpen(agreementId, args.epoch)) {\\n            uint128 epochLength = sasProxy.getAgreementEpochLength(agreementId);\\n\\n            uint256 actualCommitWindowStart = (sasProxy.getAgreementStartTime(agreementId) + args.epoch * epochLength);\\n\\n            revert ServiceAgreementErrorsV1.CommitWindowClosed(\\n                agreementId,\\n                args.epoch,\\n                actualCommitWindowStart,\\n                actualCommitWindowStart + (parametersStorage.commitWindowDurationPerc() * epochLength) / 100,\\n                block.timestamp\\n            );\\n        }\\n\\n        uint72 identityId = identityStorage.getIdentityId(msg.sender);\\n\\n        if (!reqs[1] && !shardingTableStorage.nodeExists(identityId)) {\\n            ProfileStorage ps = profileStorage;\\n\\n            revert ServiceAgreementErrorsV1.NodeNotInShardingTable(\\n                identityId,\\n                ps.getNodeId(identityId),\\n                ps.getAsk(identityId),\\n                stakingStorage.totalStakes(identityId)\\n            );\\n        }\\n\\n        uint40 score = scoringProxy.callScoreFunction(\\n            sasProxy.getAgreementScoreFunctionId(agreementId),\\n            args.hashFunctionId,\\n            profileStorage.getNodeId(identityId),\\n            args.keyword,\\n            stakingStorage.totalStakes(identityId)\\n        );\\n\\n        _insertCommit(agreementId, args.epoch, identityId, 0, 0, score);\\n\\n        emit CommitSubmitted(\\n            args.assetContract,\\n            args.tokenId,\\n            args.keyword,\\n            args.hashFunctionId,\\n            args.epoch,\\n            identityId,\\n            score\\n        );\\n    }\\n\\n    function setReq(uint256 index, bool req) external onlyHubOwner {\\n        reqs[index] = req;\\n    }\\n\\n    function _insertCommit(\\n        bytes32 agreementId,\\n        uint16 epoch,\\n        uint72 identityId,\\n        uint72 prevIdentityId,\\n        uint72 nextIdentityId,\\n        uint40 score\\n    ) internal virtual {\\n        ServiceAgreementStorageProxy sasProxy = serviceAgreementStorageProxy;\\n\\n        bytes32 commitId = keccak256(abi.encodePacked(agreementId, epoch, identityId));\\n\\n        if (!reqs[2] && sasProxy.commitSubmissionExists(commitId))\\n            revert ServiceAgreementErrorsV1.NodeAlreadySubmittedCommit(\\n                agreementId,\\n                epoch,\\n                identityId,\\n                profileStorage.getNodeId(identityId)\\n            );\\n\\n        bytes32 refCommitId = sasProxy.getV1AgreementEpochSubmissionHead(agreementId, epoch);\\n\\n        ParametersStorage params = parametersStorage;\\n\\n        uint72 refCommitNextIdentityId = sasProxy.getCommitSubmissionNextIdentityId(refCommitId);\\n        uint32 r0 = params.r0();\\n        uint8 i;\\n        while ((score < sasProxy.getCommitSubmissionScore(refCommitId)) && (refCommitNextIdentityId != 0) && (i < r0)) {\\n            refCommitId = keccak256(abi.encodePacked(agreementId, epoch, refCommitNextIdentityId));\\n\\n            refCommitNextIdentityId = sasProxy.getCommitSubmissionNextIdentityId(refCommitId);\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        if (!reqs[3] && (i >= r0))\\n            revert ServiceAgreementErrorsV1.NodeNotAwarded(\\n                agreementId,\\n                epoch,\\n                identityId,\\n                profileStorage.getNodeId(identityId),\\n                i\\n            );\\n\\n        sasProxy.createV1CommitSubmissionObject(commitId, identityId, prevIdentityId, nextIdentityId, score);\\n\\n        ServiceAgreementStructsV1.CommitSubmission memory refCommit = sasProxy.getCommitSubmission(refCommitId);\\n\\n        if ((i == 0) && (refCommit.identityId == 0)) {\\n            //  No head -> Setting new head\\n            sasProxy.setV1AgreementEpochSubmissionHead(agreementId, epoch, commitId);\\n        } else if ((i == 0) && (score <= refCommit.score)) {\\n            // There is a head with higher or equal score, add new commit on the right\\n            _linkCommits(agreementId, epoch, refCommit.identityId, identityId);\\n        } else if ((i == 0) && (score > refCommit.score)) {\\n            // There is a head with lower score, replace the head\\n            sasProxy.setV1AgreementEpochSubmissionHead(agreementId, epoch, commitId);\\n            _linkCommits(agreementId, epoch, identityId, refCommit.identityId);\\n        } else if (score > refCommit.score) {\\n            // [H] - head\\n            // [RC] - reference commit\\n            // [RC-] - commit before reference commit\\n            // [RC+] - commit after reference commit\\n            // [NC] - new commit\\n            // [] <-> [H] <-> [X] ... [RC-] <-> [RC] <-> [RC+] ... [C] <-> []\\n            // [] <-> [H] <-> [X] ... [RC-] <-(NL)-> [NC] <-(NL)-> [RC] <-> [RC+] ... [C] <-> []\\n            _linkCommits(agreementId, epoch, refCommit.prevIdentityId, identityId);\\n            _linkCommits(agreementId, epoch, identityId, refCommit.identityId);\\n        } else {\\n            // [] <-> [H] <-> [RC] <-> []\\n            // [] <-> [H] <-> [RC] <-(NL)-> [NC] <-> []\\n            _linkCommits(agreementId, epoch, refCommit.identityId, identityId);\\n        }\\n    }\\n\\n    function _linkCommits(\\n        bytes32 agreementId,\\n        uint16 epoch,\\n        uint72 leftIdentityId,\\n        uint72 rightIdentityId\\n    ) internal virtual {\\n        ServiceAgreementStorageProxy sasProxy = serviceAgreementStorageProxy;\\n\\n        sasProxy.setCommitSubmissionNextIdentityId(\\n            keccak256(abi.encodePacked(agreementId, epoch, leftIdentityId)), // leftCommitId\\n            rightIdentityId\\n        );\\n\\n        sasProxy.setCommitSubmissionPrevIdentityId(\\n            keccak256(abi.encodePacked(agreementId, epoch, rightIdentityId)), // rightCommitId\\n            leftIdentityId\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x74e28016b8b81051333eb81ad50a4ad8c207c9654c7860ddb392613912d6788b\",\"license\":\"MIT\"},\"contracts/CommitManagerV1U1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport {HashingProxy} from \\\"./HashingProxy.sol\\\";\\nimport {ScoringProxy} from \\\"./ScoringProxy.sol\\\";\\nimport {Staking} from \\\"./Staking.sol\\\";\\nimport {ContentAssetStorage} from \\\"./storage/assets/ContentAssetStorage.sol\\\";\\nimport {IdentityStorage} from \\\"./storage/IdentityStorage.sol\\\";\\nimport {ParametersStorage} from \\\"./storage/ParametersStorage.sol\\\";\\nimport {ProfileStorage} from \\\"./storage/ProfileStorage.sol\\\";\\nimport {ServiceAgreementStorageProxy} from \\\"./storage/ServiceAgreementStorageProxy.sol\\\";\\nimport {ShardingTableStorage} from \\\"./storage/ShardingTableStorage.sol\\\";\\nimport {StakingStorage} from \\\"./storage/StakingStorage.sol\\\";\\nimport {UnfinalizedStateStorage} from \\\"./storage/UnfinalizedStateStorage.sol\\\";\\nimport {AbstractAsset} from \\\"./abstract/AbstractAsset.sol\\\";\\nimport {ContractStatus} from \\\"./abstract/ContractStatus.sol\\\";\\nimport {Initializable} from \\\"./interface/Initializable.sol\\\";\\nimport {Named} from \\\"./interface/Named.sol\\\";\\nimport {Versioned} from \\\"./interface/Versioned.sol\\\";\\nimport {ServiceAgreementStructsV1} from \\\"./structs/ServiceAgreementStructsV1.sol\\\";\\nimport {ContentAssetErrors} from \\\"./errors/assets/ContentAssetErrors.sol\\\";\\nimport {GeneralErrors} from \\\"./errors/GeneralErrors.sol\\\";\\nimport {ServiceAgreementErrorsV1U1} from \\\"./errors/ServiceAgreementErrorsV1U1.sol\\\";\\n\\ncontract CommitManagerV1U1 is Named, Versioned, ContractStatus, Initializable {\\n    event CommitSubmitted(\\n        address indexed assetContract,\\n        uint256 indexed tokenId,\\n        bytes keyword,\\n        uint8 hashFunctionId,\\n        uint16 epoch,\\n        uint256 stateIndex,\\n        uint72 indexed identityId,\\n        uint40 score\\n    );\\n    event StateFinalized(\\n        address indexed assetContract,\\n        uint256 indexed tokenId,\\n        bytes keyword,\\n        uint8 hashFunctionId,\\n        uint16 epoch,\\n        uint256 stateIndex,\\n        bytes32 state\\n    );\\n\\n    string private constant _NAME = \\\"CommitManagerV1U1\\\";\\n    string private constant _VERSION = \\\"1.0.0\\\";\\n\\n    bool[6] public reqs = [false, false, false, false, false, false];\\n\\n    HashingProxy public hashingProxy;\\n    ScoringProxy public scoringProxy;\\n    Staking public stakingContract;\\n    ContentAssetStorage public contentAssetStorage;\\n    IdentityStorage public identityStorage;\\n    ParametersStorage public parametersStorage;\\n    ProfileStorage public profileStorage;\\n    ServiceAgreementStorageProxy public serviceAgreementStorageProxy;\\n    ShardingTableStorage public shardingTableStorage;\\n    StakingStorage public stakingStorage;\\n    UnfinalizedStateStorage public unfinalizedStateStorage;\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(address hubAddress) ContractStatus(hubAddress) {}\\n\\n    function initialize() public onlyHubOwner {\\n        hashingProxy = HashingProxy(hub.getContractAddress(\\\"HashingProxy\\\"));\\n        scoringProxy = ScoringProxy(hub.getContractAddress(\\\"ScoringProxy\\\"));\\n        stakingContract = Staking(hub.getContractAddress(\\\"Staking\\\"));\\n        contentAssetStorage = ContentAssetStorage(hub.getAssetStorageAddress(\\\"ContentAssetStorage\\\"));\\n        identityStorage = IdentityStorage(hub.getContractAddress(\\\"IdentityStorage\\\"));\\n        parametersStorage = ParametersStorage(hub.getContractAddress(\\\"ParametersStorage\\\"));\\n        profileStorage = ProfileStorage(hub.getContractAddress(\\\"ProfileStorage\\\"));\\n        serviceAgreementStorageProxy = ServiceAgreementStorageProxy(\\n            hub.getContractAddress(\\\"ServiceAgreementStorageProxy\\\")\\n        );\\n        shardingTableStorage = ShardingTableStorage(hub.getContractAddress(\\\"ShardingTableStorage\\\"));\\n        stakingStorage = StakingStorage(hub.getContractAddress(\\\"StakingStorage\\\"));\\n        unfinalizedStateStorage = UnfinalizedStateStorage(hub.getContractAddress(\\\"UnfinalizedStateStorage\\\"));\\n    }\\n\\n    function name() external pure virtual override returns (string memory) {\\n        return _NAME;\\n    }\\n\\n    function version() external pure virtual override returns (string memory) {\\n        return _VERSION;\\n    }\\n\\n    function isCommitWindowOpen(bytes32 agreementId, uint16 epoch) public view returns (bool) {\\n        ServiceAgreementStorageProxy sasProxy = serviceAgreementStorageProxy;\\n        uint256 startTime = sasProxy.getAgreementStartTime(agreementId);\\n\\n        ParametersStorage params = parametersStorage;\\n        uint128 epochLength = sasProxy.getAgreementEpochLength(agreementId);\\n\\n        if (startTime == 0) revert ServiceAgreementErrorsV1U1.ServiceAgreementDoesntExist(agreementId);\\n        if (epoch >= sasProxy.getAgreementEpochsNumber(agreementId))\\n            revert ServiceAgreementErrorsV1U1.ServiceAgreementHasBeenExpired(\\n                agreementId,\\n                startTime,\\n                sasProxy.getAgreementEpochsNumber(agreementId),\\n                epochLength\\n            );\\n\\n        uint256 timeNow = block.timestamp;\\n        uint256 commitWindowDuration = (params.commitWindowDurationPerc() * epochLength) / 100;\\n\\n        if (epoch == 0) {\\n            return timeNow < (startTime + commitWindowDuration);\\n        }\\n\\n        return (timeNow >= (startTime + epochLength * epoch) &&\\n            timeNow < (startTime + epochLength * epoch + commitWindowDuration));\\n    }\\n\\n    function isUpdateCommitWindowOpen(\\n        bytes32 agreementId,\\n        uint16 epoch,\\n        uint256 stateIndex\\n    ) public view returns (bool) {\\n        ServiceAgreementStorageProxy sasProxy = serviceAgreementStorageProxy;\\n\\n        uint128 epochLength = sasProxy.getAgreementEpochLength(agreementId);\\n\\n        if (!sasProxy.serviceAgreementExists(agreementId))\\n            revert ServiceAgreementErrorsV1U1.ServiceAgreementDoesntExist(agreementId);\\n        if (epoch >= sasProxy.getAgreementEpochsNumber(agreementId))\\n            revert ServiceAgreementErrorsV1U1.ServiceAgreementHasBeenExpired(\\n                agreementId,\\n                sasProxy.getAgreementStartTime(agreementId),\\n                sasProxy.getAgreementEpochsNumber(agreementId),\\n                epochLength\\n            );\\n\\n        uint256 commitWindowEnd = sasProxy.getUpdateCommitsDeadline(\\n            keccak256(abi.encodePacked(agreementId, stateIndex))\\n        );\\n\\n        return block.timestamp < commitWindowEnd;\\n    }\\n\\n    function getTopCommitSubmissions(\\n        bytes32 agreementId,\\n        uint16 epoch,\\n        uint256 stateIndex\\n    ) external view returns (ServiceAgreementStructsV1.CommitSubmission[] memory) {\\n        ServiceAgreementStorageProxy sasProxy = serviceAgreementStorageProxy;\\n\\n        if (!sasProxy.serviceAgreementExists(agreementId))\\n            revert ServiceAgreementErrorsV1U1.ServiceAgreementDoesntExist(agreementId);\\n        if (epoch >= sasProxy.getAgreementEpochsNumber(agreementId))\\n            revert ServiceAgreementErrorsV1U1.ServiceAgreementHasBeenExpired(\\n                agreementId,\\n                sasProxy.getAgreementStartTime(agreementId),\\n                sasProxy.getAgreementEpochsNumber(agreementId),\\n                sasProxy.getAgreementEpochLength(agreementId)\\n            );\\n\\n        uint32 r0 = parametersStorage.r0();\\n\\n        ServiceAgreementStructsV1.CommitSubmission[]\\n            memory epochStateCommits = new ServiceAgreementStructsV1.CommitSubmission[](r0);\\n\\n        bytes32 epochSubmissionsHead = sasProxy.getV1U1AgreementEpochSubmissionHead(agreementId, epoch, stateIndex);\\n\\n        epochStateCommits[0] = sasProxy.getCommitSubmission(epochSubmissionsHead);\\n\\n        bytes32 commitId;\\n        uint72 nextIdentityId = epochStateCommits[0].nextIdentityId;\\n        uint8 submissionsIdx = 1;\\n        while ((submissionsIdx < r0) && (nextIdentityId != 0)) {\\n            commitId = keccak256(abi.encodePacked(agreementId, epoch, stateIndex, nextIdentityId));\\n            epochStateCommits[submissionsIdx] = sasProxy.getCommitSubmission(commitId);\\n\\n            nextIdentityId = epochStateCommits[submissionsIdx].nextIdentityId;\\n\\n            unchecked {\\n                submissionsIdx++;\\n            }\\n        }\\n\\n        return epochStateCommits;\\n    }\\n\\n    function submitCommit(ServiceAgreementStructsV1.CommitInputArgs calldata args) external {\\n        ServiceAgreementStorageProxy sasProxy = serviceAgreementStorageProxy;\\n\\n        bytes32 agreementId = hashingProxy.callHashFunction(\\n            args.hashFunctionId,\\n            abi.encodePacked(args.assetContract, args.tokenId, args.keyword)\\n        );\\n\\n        if (!sasProxy.serviceAgreementExists(agreementId))\\n            revert ServiceAgreementErrorsV1U1.ServiceAgreementDoesntExist(agreementId);\\n\\n        uint256 latestFinalizedStateIndex = AbstractAsset(args.assetContract).getAssertionIdsLength(args.tokenId) - 1;\\n\\n        if (!reqs[0] && !isCommitWindowOpen(agreementId, args.epoch)) {\\n            uint128 epochLength = sasProxy.getAgreementEpochLength(agreementId);\\n\\n            uint256 actualCommitWindowStart = (sasProxy.getAgreementStartTime(agreementId) + args.epoch * epochLength);\\n\\n            revert ServiceAgreementErrorsV1U1.CommitWindowClosed(\\n                agreementId,\\n                args.epoch,\\n                latestFinalizedStateIndex,\\n                actualCommitWindowStart,\\n                actualCommitWindowStart + (parametersStorage.commitWindowDurationPerc() * epochLength) / 100,\\n                block.timestamp\\n            );\\n        }\\n\\n        uint72 identityId = identityStorage.getIdentityId(msg.sender);\\n\\n        if (!reqs[1] && !shardingTableStorage.nodeExists(identityId)) {\\n            ProfileStorage ps = profileStorage;\\n\\n            revert ServiceAgreementErrorsV1U1.NodeNotInShardingTable(\\n                identityId,\\n                ps.getNodeId(identityId),\\n                ps.getAsk(identityId),\\n                stakingStorage.totalStakes(identityId)\\n            );\\n        }\\n\\n        uint40 score = scoringProxy.callScoreFunction(\\n            sasProxy.getAgreementScoreFunctionId(agreementId),\\n            args.hashFunctionId,\\n            profileStorage.getNodeId(identityId),\\n            args.keyword,\\n            stakingStorage.totalStakes(identityId)\\n        );\\n\\n        _insertCommit(agreementId, args.epoch, latestFinalizedStateIndex, identityId, 0, 0, score);\\n\\n        emit CommitSubmitted(\\n            args.assetContract,\\n            args.tokenId,\\n            args.keyword,\\n            args.hashFunctionId,\\n            args.epoch,\\n            latestFinalizedStateIndex,\\n            identityId,\\n            score\\n        );\\n    }\\n\\n    function submitUpdateCommit(ServiceAgreementStructsV1.CommitInputArgs calldata args) external {\\n        UnfinalizedStateStorage uss = unfinalizedStateStorage;\\n        AbstractAsset generalAssetInterface = AbstractAsset(args.assetContract);\\n\\n        bytes32 unfinalizedState = uss.getUnfinalizedState(args.tokenId);\\n        uint256 unfinalizedStateIndex = generalAssetInterface.getAssertionIdsLength(args.tokenId);\\n\\n        if (uss.getUnfinalizedState(args.tokenId) == bytes32(0)) {\\n            revert ServiceAgreementErrorsV1U1.NoPendingUpdate(args.assetContract, args.tokenId);\\n        }\\n\\n        ServiceAgreementStorageProxy sasProxy = serviceAgreementStorageProxy;\\n\\n        bytes32 agreementId = hashingProxy.callHashFunction(\\n            args.hashFunctionId,\\n            abi.encodePacked(args.assetContract, args.tokenId, args.keyword)\\n        );\\n\\n        if (!sasProxy.serviceAgreementExists(agreementId))\\n            revert ServiceAgreementErrorsV1U1.ServiceAgreementDoesntExist(agreementId);\\n\\n        if (!reqs[2] && !isUpdateCommitWindowOpen(agreementId, args.epoch, unfinalizedStateIndex)) {\\n            uint256 commitWindowEnd = sasProxy.getUpdateCommitsDeadline(\\n                keccak256(abi.encodePacked(agreementId, unfinalizedStateIndex))\\n            );\\n\\n            revert ServiceAgreementErrorsV1U1.CommitWindowClosed(\\n                agreementId,\\n                args.epoch,\\n                unfinalizedStateIndex,\\n                commitWindowEnd - parametersStorage.updateCommitWindowDuration(),\\n                commitWindowEnd,\\n                block.timestamp\\n            );\\n        }\\n\\n        uint72 identityId = identityStorage.getIdentityId(msg.sender);\\n\\n        if (!reqs[3] && !shardingTableStorage.nodeExists(identityId)) {\\n            ProfileStorage ps = profileStorage;\\n\\n            revert ServiceAgreementErrorsV1U1.NodeNotInShardingTable(\\n                identityId,\\n                ps.getNodeId(identityId),\\n                ps.getAsk(identityId),\\n                stakingStorage.totalStakes(identityId)\\n            );\\n        }\\n\\n        uint40 score = scoringProxy.callScoreFunction(\\n            sasProxy.getAgreementScoreFunctionId(agreementId),\\n            args.hashFunctionId,\\n            profileStorage.getNodeId(identityId),\\n            args.keyword,\\n            stakingStorage.totalStakes(identityId)\\n        );\\n\\n        _insertCommit(agreementId, args.epoch, unfinalizedStateIndex, identityId, 0, 0, score);\\n\\n        emit CommitSubmitted(\\n            args.assetContract,\\n            args.tokenId,\\n            args.keyword,\\n            args.hashFunctionId,\\n            args.epoch,\\n            unfinalizedStateIndex,\\n            identityId,\\n            score\\n        );\\n\\n        if (\\n            sasProxy.getCommitsCount(keccak256(abi.encodePacked(agreementId, args.epoch, unfinalizedStateIndex))) ==\\n            parametersStorage.finalizationCommitsNumber()\\n        ) {\\n            if (sasProxy.agreementV1Exists(agreementId)) {\\n                sasProxy.migrateV1ServiceAgreement(agreementId);\\n            }\\n\\n            sasProxy.setAgreementTokenAmount(\\n                agreementId,\\n                sasProxy.getAgreementTokenAmount(agreementId) + sasProxy.getAgreementUpdateTokenAmount(agreementId)\\n            );\\n            sasProxy.setAgreementUpdateTokenAmount(agreementId, 0);\\n\\n            ContentAssetStorage cas = contentAssetStorage;\\n            cas.setAssertionIssuer(args.tokenId, unfinalizedState, uss.getIssuer(args.tokenId));\\n            cas.pushAssertionId(args.tokenId, unfinalizedState);\\n\\n            uss.deleteIssuer(args.tokenId);\\n            uss.deleteUnfinalizedState(args.tokenId);\\n\\n            emit StateFinalized(\\n                args.assetContract,\\n                args.tokenId,\\n                args.keyword,\\n                args.hashFunctionId,\\n                args.epoch,\\n                unfinalizedStateIndex,\\n                unfinalizedState\\n            );\\n        }\\n    }\\n\\n    function setReq(uint256 index, bool req) external onlyHubOwner {\\n        reqs[index] = req;\\n    }\\n\\n    function _insertCommit(\\n        bytes32 agreementId,\\n        uint16 epoch,\\n        uint256 stateIndex,\\n        uint72 identityId,\\n        uint72 prevIdentityId,\\n        uint72 nextIdentityId,\\n        uint40 score\\n    ) internal virtual {\\n        ServiceAgreementStorageProxy sasProxy = serviceAgreementStorageProxy;\\n\\n        bytes32 commitId = keccak256(abi.encodePacked(agreementId, epoch, stateIndex, identityId));\\n\\n        if (!reqs[4] && sasProxy.commitSubmissionExists(commitId))\\n            revert ServiceAgreementErrorsV1U1.NodeAlreadySubmittedCommit(\\n                agreementId,\\n                epoch,\\n                stateIndex,\\n                identityId,\\n                profileStorage.getNodeId(identityId)\\n            );\\n\\n        bytes32 refCommitId = sasProxy.getV1U1AgreementEpochSubmissionHead(agreementId, epoch, stateIndex);\\n\\n        ParametersStorage params = parametersStorage;\\n\\n        uint72 refCommitNextIdentityId = sasProxy.getCommitSubmissionNextIdentityId(refCommitId);\\n        uint32 r0 = params.r0();\\n        uint8 i;\\n        while ((score < sasProxy.getCommitSubmissionScore(refCommitId)) && (refCommitNextIdentityId != 0) && (i < r0)) {\\n            refCommitId = keccak256(abi.encodePacked(agreementId, epoch, stateIndex, refCommitNextIdentityId));\\n\\n            refCommitNextIdentityId = sasProxy.getCommitSubmissionNextIdentityId(refCommitId);\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        if (!reqs[5] && (i >= r0))\\n            revert ServiceAgreementErrorsV1U1.NodeNotAwarded(\\n                agreementId,\\n                epoch,\\n                stateIndex,\\n                identityId,\\n                profileStorage.getNodeId(identityId),\\n                i\\n            );\\n\\n        sasProxy.createV1U1CommitSubmissionObject(commitId, identityId, prevIdentityId, nextIdentityId, score);\\n\\n        ServiceAgreementStructsV1.CommitSubmission memory refCommit = sasProxy.getCommitSubmission(refCommitId);\\n\\n        if ((i == 0) && (refCommit.identityId == 0)) {\\n            //  No head -> Setting new head\\n            sasProxy.setV1U1AgreementEpochSubmissionHead(agreementId, epoch, stateIndex, commitId);\\n        } else if ((i == 0) && (score <= refCommit.score)) {\\n            // There is a head with higher or equal score, add new commit on the right\\n            _linkCommits(agreementId, epoch, stateIndex, refCommit.identityId, identityId);\\n        } else if ((i == 0) && (score > refCommit.score)) {\\n            // There is a head with lower score, replace the head\\n            sasProxy.setV1U1AgreementEpochSubmissionHead(agreementId, epoch, stateIndex, commitId);\\n            _linkCommits(agreementId, epoch, stateIndex, identityId, refCommit.identityId);\\n        } else if (score > refCommit.score) {\\n            // [H] - head\\n            // [RC] - reference commit\\n            // [RC-] - commit before reference commit\\n            // [RC+] - commit after reference commit\\n            // [NC] - new commit\\n            // [] <-> [H] <-> [X] ... [RC-] <-> [RC] <-> [RC+] ... [C] <-> []\\n            // [] <-> [H] <-> [X] ... [RC-] <-(NL)-> [NC] <-(NL)-> [RC] <-> [RC+] ... [C] <-> []\\n            _linkCommits(agreementId, epoch, stateIndex, refCommit.prevIdentityId, identityId);\\n            _linkCommits(agreementId, epoch, stateIndex, identityId, refCommit.identityId);\\n        } else {\\n            // [] <-> [H] <-> [RC] <-> []\\n            // [] <-> [H] <-> [RC] <-(NL)-> [NC] <-> []\\n            _linkCommits(agreementId, epoch, stateIndex, refCommit.identityId, identityId);\\n        }\\n\\n        sasProxy.incrementCommitsCount(keccak256(abi.encodePacked(agreementId, epoch, stateIndex)));\\n    }\\n\\n    function _linkCommits(\\n        bytes32 agreementId,\\n        uint16 epoch,\\n        uint256 stateIndex,\\n        uint72 leftIdentityId,\\n        uint72 rightIdentityId\\n    ) internal virtual {\\n        ServiceAgreementStorageProxy sasProxy = serviceAgreementStorageProxy;\\n\\n        sasProxy.setCommitSubmissionNextIdentityId(\\n            keccak256(abi.encodePacked(agreementId, epoch, stateIndex, leftIdentityId)), // leftCommitId\\n            rightIdentityId\\n        );\\n\\n        sasProxy.setCommitSubmissionPrevIdentityId(\\n            keccak256(abi.encodePacked(agreementId, epoch, stateIndex, rightIdentityId)), // rightCommitId\\n            leftIdentityId\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x8ee543faf8f6002abef2b9016b9d8d52e39a563e342739b79a5ee424491bc8b6\",\"license\":\"MIT\"},\"contracts/Guardian.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport {HubDependent} from \\\"./abstract/HubDependent.sol\\\";\\nimport {ICustodian} from \\\"./interface/ICustodian.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ncontract Guardian is HubDependent {\\n    event TokenTransferred(address indexed custodian, uint256 amount);\\n    event MisplacedOTPWithdrawn(address indexed custodian, uint256 amount);\\n    event MisplacedTokensWithdrawn(address indexed custodian, address tokenContract, uint256 amount);\\n\\n    IERC20 public tokenContract;\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(address hubAddress) HubDependent(hubAddress) {}\\n\\n    function initialize() public onlyHubOwner {\\n        tokenContract = IERC20(hub.getContractAddress(\\\"Token\\\"));\\n    }\\n\\n    function transferTokens(address payable custodian) external onlyHubOwner {\\n        require(custodian != address(0x0), \\\"Custodian cannot be a zero address\\\");\\n        uint contractSize;\\n        assembly {\\n            contractSize := extcodesize(custodian)\\n        }\\n        require(contractSize > 0, \\\"Cannot transfer tokens to custodian that is not a contract!\\\");\\n\\n        ICustodian custodianContract = ICustodian(custodian);\\n        bool hasOwnersFunction = false;\\n        try custodianContract.getOwners() returns (address[] memory owners) {\\n            hasOwnersFunction = true;\\n            require(owners.length > 0, \\\"Cannot transfer tokens to custodian without owners defined!\\\");\\n        } catch {}\\n        require(hasOwnersFunction, \\\"Cannot transfer tokens to custodian without getOwners function!\\\");\\n\\n        uint256 balanceTransferred = tokenContract.balanceOf(address(this));\\n        bool transactionResult = tokenContract.transfer(custodian, balanceTransferred);\\n        require(transactionResult, \\\"Token transaction execution failed!\\\");\\n\\n        emit TokenTransferred(custodian, balanceTransferred);\\n    }\\n\\n    function withdrawMisplacedOTP() external onlyHubOwner {\\n        uint256 balance = address(this).balance;\\n        if (balance > 0) {\\n            (bool success, ) = msg.sender.call{value: balance}(\\\"\\\");\\n            require(success, \\\"Transfer failed.\\\");\\n        }\\n        emit MisplacedOTPWithdrawn(msg.sender, balance);\\n    }\\n\\n    function withdrawMisplacedTokens(address tokenContractAddress) external onlyHubOwner {\\n        require(tokenContractAddress != address(tokenContract), \\\"Cannot use this function with the TRAC contract\\\");\\n        IERC20 misplacedTokensContract = IERC20(tokenContractAddress);\\n\\n        uint256 balance = misplacedTokensContract.balanceOf(address(this));\\n        if (balance > 0) {\\n            bool transactionResult = misplacedTokensContract.transfer(msg.sender, balance);\\n            require(transactionResult, \\\"Token transaction execution failed\\\");\\n        }\\n        emit MisplacedTokensWithdrawn(msg.sender, tokenContractAddress, balance);\\n    }\\n}\\n\",\"keccak256\":\"0x2dcef9797032f7c9aae94d003e52a83ae8e978b1ca5b3fbca261e552252d3de8\",\"license\":\"MIT\"},\"contracts/HashingProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport {ContractStatus} from \\\"./abstract/ContractStatus.sol\\\";\\nimport {IHashFunction} from \\\"./interface/IHashFunction.sol\\\";\\nimport {Named} from \\\"./interface/Named.sol\\\";\\nimport {Versioned} from \\\"./interface/Versioned.sol\\\";\\nimport {UnorderedIndexableContractDynamicSetLib} from \\\"./utils/UnorderedIndexableContractDynamicSet.sol\\\";\\n\\ncontract HashingProxy is Named, Versioned, ContractStatus {\\n    using UnorderedIndexableContractDynamicSetLib for UnorderedIndexableContractDynamicSetLib.Set;\\n\\n    event NewHashFunctionContract(uint8 indexed hashFunctionId, address newContractAddress);\\n    event HashFunctionContractChanged(uint8 indexed hashFunctionId, address newContractAddress);\\n\\n    string private constant _NAME = \\\"HashingProxy\\\";\\n    string private constant _VERSION = \\\"1.0.1\\\";\\n\\n    UnorderedIndexableContractDynamicSetLib.Set internal hashFunctionSet;\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(address hubAddress) ContractStatus(hubAddress) {}\\n\\n    function name() external pure virtual override returns (string memory) {\\n        return _NAME;\\n    }\\n\\n    function version() external pure virtual override returns (string memory) {\\n        return _VERSION;\\n    }\\n\\n    function setContractAddress(uint8 hashFunctionId, address hashingContractAddress) external onlyHubOwner {\\n        if (hashFunctionSet.exists(hashFunctionId)) {\\n            hashFunctionSet.update(hashFunctionId, hashingContractAddress);\\n            emit HashFunctionContractChanged(hashFunctionId, hashingContractAddress);\\n        } else {\\n            hashFunctionSet.append(hashFunctionId, hashingContractAddress);\\n            emit NewHashFunctionContract(hashFunctionId, hashingContractAddress);\\n        }\\n    }\\n\\n    function removeContract(uint8 hashFunctionId) external onlyHubOwner {\\n        hashFunctionSet.remove(hashFunctionId);\\n    }\\n\\n    function callHashFunction(uint8 hashFunctionId, bytes calldata data) external view returns (bytes32) {\\n        return IHashFunction(hashFunctionSet.get(hashFunctionId).addr).hash(data);\\n    }\\n\\n    function getHashFunctionName(uint8 hashFunctionId) external view returns (string memory) {\\n        return Named(hashFunctionSet.get(hashFunctionId).addr).name();\\n    }\\n\\n    function getHashFunctionContractAddress(uint8 hashFunctionId) external view returns (address) {\\n        return hashFunctionSet.get(hashFunctionId).addr;\\n    }\\n\\n    function getAllHashFunctions() external view returns (UnorderedIndexableContractDynamicSetLib.Contract[] memory) {\\n        return hashFunctionSet.getAll();\\n    }\\n\\n    function isHashFunction(uint8 hashFunctionId) external view returns (bool) {\\n        return hashFunctionSet.exists(hashFunctionId);\\n    }\\n}\\n\",\"keccak256\":\"0x025adfeec4c165b83247442a9d36fee0bf311c01c3527bbd23401ce9879f5eee\",\"license\":\"MIT\"},\"contracts/Hub.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport {Named} from \\\"./interface/Named.sol\\\";\\nimport {Versioned} from \\\"./interface/Versioned.sol\\\";\\nimport {UnorderedNamedContractDynamicSetLib} from \\\"./utils/UnorderedNamedContractDynamicSet.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract Hub is Named, Versioned, Ownable {\\n    using UnorderedNamedContractDynamicSetLib for UnorderedNamedContractDynamicSetLib.Set;\\n\\n    event NewContract(string contractName, address newContractAddress);\\n    event ContractChanged(string contractName, address newContractAddress);\\n    event NewAssetStorage(string contractName, address newContractAddress);\\n    event AssetStorageChanged(string contractName, address newContractAddress);\\n\\n    string private constant _NAME = \\\"Hub\\\";\\n    string private constant _VERSION = \\\"1.0.0\\\";\\n\\n    UnorderedNamedContractDynamicSetLib.Set internal contractSet;\\n    UnorderedNamedContractDynamicSetLib.Set internal assetStorageSet;\\n\\n    function name() external pure virtual override returns (string memory) {\\n        return _NAME;\\n    }\\n\\n    function version() external pure virtual override returns (string memory) {\\n        return _VERSION;\\n    }\\n\\n    function setContractAddress(string calldata contractName, address newContractAddress) external onlyOwner {\\n        if (contractSet.exists(contractName)) {\\n            emit ContractChanged(contractName, newContractAddress);\\n            contractSet.update(contractName, newContractAddress);\\n        } else {\\n            emit NewContract(contractName, newContractAddress);\\n            contractSet.append(contractName, newContractAddress);\\n        }\\n    }\\n\\n    function setAssetStorageAddress(string calldata assetStorageName, address assetStorageAddress) external onlyOwner {\\n        if (assetStorageSet.exists(assetStorageName)) {\\n            emit AssetStorageChanged(assetStorageName, assetStorageAddress);\\n            assetStorageSet.update(assetStorageName, assetStorageAddress);\\n        } else {\\n            emit NewAssetStorage(assetStorageName, assetStorageAddress);\\n            assetStorageSet.append(assetStorageName, assetStorageAddress);\\n        }\\n    }\\n\\n    function getContractAddress(string calldata contractName) external view returns (address) {\\n        return contractSet.get(contractName).addr;\\n    }\\n\\n    function getAssetStorageAddress(string calldata assetStorageName) external view returns (address) {\\n        return assetStorageSet.get(assetStorageName).addr;\\n    }\\n\\n    function getAllContracts() external view returns (UnorderedNamedContractDynamicSetLib.Contract[] memory) {\\n        return contractSet.getAll();\\n    }\\n\\n    function getAllAssetStorages() external view returns (UnorderedNamedContractDynamicSetLib.Contract[] memory) {\\n        return assetStorageSet.getAll();\\n    }\\n\\n    function isContract(string calldata contractName) external view returns (bool) {\\n        return contractSet.exists(contractName);\\n    }\\n\\n    function isContract(address selectedContractAddress) external view returns (bool) {\\n        return contractSet.exists(selectedContractAddress);\\n    }\\n\\n    function isAssetStorage(string calldata assetStorageName) external view returns (bool) {\\n        return assetStorageSet.exists(assetStorageName);\\n    }\\n\\n    function isAssetStorage(address assetStorageAddress) external view returns (bool) {\\n        return assetStorageSet.exists(assetStorageAddress);\\n    }\\n}\\n\",\"keccak256\":\"0xf93b8b90622b1a49cd00a3558f64766e6bbca7b2f192f8e036a773d01e5c3382\",\"license\":\"MIT\"},\"contracts/ProofManagerV1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport {HashingProxy} from \\\"./HashingProxy.sol\\\";\\nimport {Staking} from \\\"./Staking.sol\\\";\\nimport {AssertionStorage} from \\\"./storage/AssertionStorage.sol\\\";\\nimport {IdentityStorage} from \\\"./storage/IdentityStorage.sol\\\";\\nimport {ParametersStorage} from \\\"./storage/ParametersStorage.sol\\\";\\nimport {ProfileStorage} from \\\"./storage/ProfileStorage.sol\\\";\\nimport {ServiceAgreementStorageProxy} from \\\"./storage/ServiceAgreementStorageProxy.sol\\\";\\nimport {AbstractAsset} from \\\"./abstract/AbstractAsset.sol\\\";\\nimport {ContractStatus} from \\\"./abstract/ContractStatus.sol\\\";\\nimport {Initializable} from \\\"./interface/Initializable.sol\\\";\\nimport {Named} from \\\"./interface/Named.sol\\\";\\nimport {Versioned} from \\\"./interface/Versioned.sol\\\";\\nimport {ServiceAgreementStructsV1} from \\\"./structs/ServiceAgreementStructsV1.sol\\\";\\nimport {ContentAssetErrors} from \\\"./errors/assets/ContentAssetErrors.sol\\\";\\nimport {GeneralErrors} from \\\"./errors/GeneralErrors.sol\\\";\\nimport {ServiceAgreementErrorsV1} from \\\"./errors/ServiceAgreementErrorsV1.sol\\\";\\nimport {MerkleProof} from \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\n\\ncontract ProofManagerV1 is Named, Versioned, ContractStatus, Initializable {\\n    event ProofSubmitted(\\n        address indexed assetContract,\\n        uint256 indexed tokenId,\\n        bytes keyword,\\n        uint8 hashFunctionId,\\n        uint16 epoch,\\n        uint72 indexed identityId\\n    );\\n\\n    string private constant _NAME = \\\"ProofManagerV1\\\";\\n    string private constant _VERSION = \\\"1.0.0\\\";\\n\\n    bool[4] public reqs = [false, false, false, false];\\n\\n    HashingProxy public hashingProxy;\\n    Staking public stakingContract;\\n    AssertionStorage public assertionStorage;\\n    IdentityStorage public identityStorage;\\n    ParametersStorage public parametersStorage;\\n    ProfileStorage public profileStorage;\\n    ServiceAgreementStorageProxy public serviceAgreementStorageProxy;\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(address hubAddress) ContractStatus(hubAddress) {}\\n\\n    function initialize() public onlyHubOwner {\\n        hashingProxy = HashingProxy(hub.getContractAddress(\\\"HashingProxy\\\"));\\n        stakingContract = Staking(hub.getContractAddress(\\\"Staking\\\"));\\n        assertionStorage = AssertionStorage(hub.getContractAddress(\\\"AssertionStorage\\\"));\\n        identityStorage = IdentityStorage(hub.getContractAddress(\\\"IdentityStorage\\\"));\\n        parametersStorage = ParametersStorage(hub.getContractAddress(\\\"ParametersStorage\\\"));\\n        profileStorage = ProfileStorage(hub.getContractAddress(\\\"ProfileStorage\\\"));\\n        serviceAgreementStorageProxy = ServiceAgreementStorageProxy(\\n            hub.getContractAddress(\\\"ServiceAgreementStorageProxy\\\")\\n        );\\n    }\\n\\n    function name() external pure virtual override returns (string memory) {\\n        return _NAME;\\n    }\\n\\n    function version() external pure virtual override returns (string memory) {\\n        return _VERSION;\\n    }\\n\\n    function isProofWindowOpen(bytes32 agreementId, uint16 epoch) public view returns (bool) {\\n        ServiceAgreementStorageProxy sasProxy = serviceAgreementStorageProxy;\\n        uint256 startTime = sasProxy.getAgreementStartTime(agreementId);\\n\\n        if (startTime == 0) revert ServiceAgreementErrorsV1.ServiceAgreementDoesntExist(agreementId);\\n        if (epoch >= sasProxy.getAgreementEpochsNumber(agreementId))\\n            revert ServiceAgreementErrorsV1.ServiceAgreementHasBeenExpired(\\n                agreementId,\\n                startTime,\\n                sasProxy.getAgreementEpochsNumber(agreementId),\\n                sasProxy.getAgreementEpochLength(agreementId)\\n            );\\n\\n        uint256 timeNow = block.timestamp;\\n        uint128 epochLength = sasProxy.getAgreementEpochLength(agreementId);\\n        uint8 proofWindowOffsetPerc = sasProxy.getAgreementProofWindowOffsetPerc(agreementId);\\n\\n        uint256 proofWindowOffset = (epochLength * proofWindowOffsetPerc) / 100;\\n        uint256 proofWindowDuration = (epochLength * parametersStorage.proofWindowDurationPerc()) / 100;\\n\\n        return (timeNow >= (startTime + epochLength * epoch + proofWindowOffset) &&\\n            timeNow < (startTime + epochLength * epoch + proofWindowOffset + proofWindowDuration));\\n    }\\n\\n    function getChallenge(\\n        address sender,\\n        address assetContract,\\n        uint256 tokenId,\\n        uint16 epoch\\n    ) public view returns (bytes32 assertionId, uint256 challenge) {\\n        uint72 identityId = identityStorage.getIdentityId(sender);\\n\\n        AbstractAsset generalAssetInterface = AbstractAsset(assetContract);\\n        assertionId = generalAssetInterface.getLatestAssertionId(tokenId);\\n\\n        uint256 assertionChunksNumber = assertionStorage.getAssertionChunksNumber(assertionId);\\n\\n        // blockchash() function only works for last 256 blocks (25.6 min window in case of 6s block time)\\n        // TODO: figure out how to achieve randomness\\n        return (assertionId, uint256(sha256(abi.encodePacked(epoch, identityId))) % assertionChunksNumber);\\n    }\\n\\n    function sendProof(ServiceAgreementStructsV1.ProofInputArgs calldata args) external {\\n        ServiceAgreementStorageProxy sasProxy = serviceAgreementStorageProxy;\\n\\n        bytes32 agreementId = hashingProxy.callHashFunction(\\n            args.hashFunctionId,\\n            abi.encodePacked(args.assetContract, args.tokenId, args.keyword)\\n        );\\n\\n        if (!sasProxy.serviceAgreementExists(agreementId))\\n            revert ServiceAgreementErrorsV1.ServiceAgreementDoesntExist(agreementId);\\n\\n        if (!reqs[0] && !isProofWindowOpen(agreementId, args.epoch)) {\\n            uint128 epochLength = sasProxy.getAgreementEpochLength(agreementId);\\n\\n            uint256 actualCommitWindowStart = (sasProxy.getAgreementStartTime(agreementId) + args.epoch * epochLength);\\n\\n            revert ServiceAgreementErrorsV1.ProofWindowClosed(\\n                agreementId,\\n                args.epoch,\\n                actualCommitWindowStart,\\n                actualCommitWindowStart + (parametersStorage.commitWindowDurationPerc() * epochLength) / 100,\\n                block.timestamp\\n            );\\n        }\\n\\n        IdentityStorage ids = identityStorage;\\n\\n        uint72 identityId = ids.getIdentityId(msg.sender);\\n\\n        if (\\n            !reqs[1] &&\\n            (sasProxy.getCommitSubmissionScore(keccak256(abi.encodePacked(agreementId, args.epoch, identityId))) == 0)\\n        )\\n            revert ServiceAgreementErrorsV1.NodeAlreadyRewarded(\\n                agreementId,\\n                args.epoch,\\n                identityId,\\n                profileStorage.getNodeId(identityId)\\n            );\\n\\n        bytes32 nextCommitId = sasProxy.getV1AgreementEpochSubmissionHead(agreementId, args.epoch);\\n        uint32 r0 = parametersStorage.r0();\\n        uint8 i;\\n        while ((identityId != sasProxy.getCommitSubmissionIdentityId(nextCommitId)) && (i < r0)) {\\n            nextCommitId = keccak256(\\n                abi.encodePacked(agreementId, args.epoch, sasProxy.getCommitSubmissionNextIdentityId(nextCommitId))\\n            );\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        if (!reqs[2] && (i >= r0))\\n            revert ServiceAgreementErrorsV1.NodeNotAwarded(\\n                agreementId,\\n                args.epoch,\\n                identityId,\\n                profileStorage.getNodeId(identityId),\\n                i\\n            );\\n\\n        bytes32 merkleRoot;\\n        uint256 challenge;\\n        (merkleRoot, challenge) = getChallenge(msg.sender, args.assetContract, args.tokenId, args.epoch);\\n\\n        if (\\n            !reqs[3] &&\\n            !MerkleProof.verify(args.proof, merkleRoot, keccak256(abi.encodePacked(args.chunkHash, challenge)))\\n        )\\n            revert ServiceAgreementErrorsV1.WrongMerkleProof(\\n                agreementId,\\n                args.epoch,\\n                identityId,\\n                profileStorage.getNodeId(identityId),\\n                args.proof,\\n                merkleRoot,\\n                args.chunkHash,\\n                challenge\\n            );\\n\\n        emit ProofSubmitted(\\n            args.assetContract,\\n            args.tokenId,\\n            args.keyword,\\n            args.hashFunctionId,\\n            args.epoch,\\n            identityId\\n        );\\n\\n        uint96 reward = (sasProxy.getAgreementTokenAmount(agreementId) /\\n            (sasProxy.getAgreementEpochsNumber(agreementId) - args.epoch + 1) /\\n            (r0 - sasProxy.getAgreementRewardedNodesNumber(agreementId, args.epoch)));\\n\\n        stakingContract.addReward(agreementId, identityId, reward);\\n        sasProxy.setAgreementTokenAmount(agreementId, sasProxy.getAgreementTokenAmount(agreementId) - reward);\\n        sasProxy.incrementAgreementRewardedNodesNumber(agreementId, args.epoch);\\n\\n        // To make sure that node already received reward\\n        sasProxy.setCommitSubmissionScore(keccak256(abi.encodePacked(agreementId, args.epoch, identityId)), 0);\\n    }\\n\\n    function setReq(uint256 index, bool req) external onlyHubOwner {\\n        reqs[index] = req;\\n    }\\n}\\n\",\"keccak256\":\"0xf8050016343ca93957aa29d76a6ff88bd7c2940193f2ce2f068fb8e5f1109555\",\"license\":\"MIT\"},\"contracts/ProofManagerV1U1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport {HashingProxy} from \\\"./HashingProxy.sol\\\";\\nimport {Staking} from \\\"./Staking.sol\\\";\\nimport {AssertionStorage} from \\\"./storage/AssertionStorage.sol\\\";\\nimport {IdentityStorage} from \\\"./storage/IdentityStorage.sol\\\";\\nimport {ParametersStorage} from \\\"./storage/ParametersStorage.sol\\\";\\nimport {ProfileStorage} from \\\"./storage/ProfileStorage.sol\\\";\\nimport {ServiceAgreementStorageProxy} from \\\"./storage/ServiceAgreementStorageProxy.sol\\\";\\nimport {AbstractAsset} from \\\"./abstract/AbstractAsset.sol\\\";\\nimport {ContractStatus} from \\\"./abstract/ContractStatus.sol\\\";\\nimport {Initializable} from \\\"./interface/Initializable.sol\\\";\\nimport {Named} from \\\"./interface/Named.sol\\\";\\nimport {Versioned} from \\\"./interface/Versioned.sol\\\";\\nimport {ServiceAgreementStructsV1} from \\\"./structs/ServiceAgreementStructsV1.sol\\\";\\nimport {ContentAssetErrors} from \\\"./errors/assets/ContentAssetErrors.sol\\\";\\nimport {GeneralErrors} from \\\"./errors/GeneralErrors.sol\\\";\\nimport {ServiceAgreementErrorsV1U1} from \\\"./errors/ServiceAgreementErrorsV1U1.sol\\\";\\nimport {MerkleProof} from \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\n\\ncontract ProofManagerV1U1 is Named, Versioned, ContractStatus, Initializable {\\n    event ProofSubmitted(\\n        address indexed assetContract,\\n        uint256 indexed tokenId,\\n        bytes keyword,\\n        uint8 hashFunctionId,\\n        uint16 epoch,\\n        uint256 stateIndex,\\n        uint72 indexed identityId\\n    );\\n\\n    string private constant _NAME = \\\"ProofManagerV1U1\\\";\\n    string private constant _VERSION = \\\"1.0.0\\\";\\n\\n    bool[4] public reqs = [false, false, false, false];\\n\\n    HashingProxy public hashingProxy;\\n    Staking public stakingContract;\\n    AssertionStorage public assertionStorage;\\n    IdentityStorage public identityStorage;\\n    ParametersStorage public parametersStorage;\\n    ProfileStorage public profileStorage;\\n    ServiceAgreementStorageProxy public serviceAgreementStorageProxy;\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(address hubAddress) ContractStatus(hubAddress) {}\\n\\n    function initialize() public onlyHubOwner {\\n        hashingProxy = HashingProxy(hub.getContractAddress(\\\"HashingProxy\\\"));\\n        stakingContract = Staking(hub.getContractAddress(\\\"Staking\\\"));\\n        assertionStorage = AssertionStorage(hub.getContractAddress(\\\"AssertionStorage\\\"));\\n        identityStorage = IdentityStorage(hub.getContractAddress(\\\"IdentityStorage\\\"));\\n        parametersStorage = ParametersStorage(hub.getContractAddress(\\\"ParametersStorage\\\"));\\n        profileStorage = ProfileStorage(hub.getContractAddress(\\\"ProfileStorage\\\"));\\n        serviceAgreementStorageProxy = ServiceAgreementStorageProxy(\\n            hub.getContractAddress(\\\"ServiceAgreementStorageProxy\\\")\\n        );\\n    }\\n\\n    function name() external pure virtual override returns (string memory) {\\n        return _NAME;\\n    }\\n\\n    function version() external pure virtual override returns (string memory) {\\n        return _VERSION;\\n    }\\n\\n    function isProofWindowOpen(bytes32 agreementId, uint16 epoch) public view returns (bool) {\\n        ServiceAgreementStorageProxy sasProxy = serviceAgreementStorageProxy;\\n        uint256 startTime = sasProxy.getAgreementStartTime(agreementId);\\n\\n        if (startTime == 0) revert ServiceAgreementErrorsV1U1.ServiceAgreementDoesntExist(agreementId);\\n        if (epoch >= sasProxy.getAgreementEpochsNumber(agreementId))\\n            revert ServiceAgreementErrorsV1U1.ServiceAgreementHasBeenExpired(\\n                agreementId,\\n                startTime,\\n                sasProxy.getAgreementEpochsNumber(agreementId),\\n                sasProxy.getAgreementEpochLength(agreementId)\\n            );\\n\\n        uint256 timeNow = block.timestamp;\\n        uint128 epochLength = sasProxy.getAgreementEpochLength(agreementId);\\n        uint8 proofWindowOffsetPerc = sasProxy.getAgreementProofWindowOffsetPerc(agreementId);\\n\\n        uint256 proofWindowOffset = (epochLength * proofWindowOffsetPerc) / 100;\\n        uint256 proofWindowDuration = (epochLength * parametersStorage.proofWindowDurationPerc()) / 100;\\n\\n        return (timeNow >= (startTime + epochLength * epoch + proofWindowOffset) &&\\n            timeNow < (startTime + epochLength * epoch + proofWindowOffset + proofWindowDuration));\\n    }\\n\\n    function getChallenge(\\n        address assetContract,\\n        uint256 tokenId,\\n        uint16 epoch\\n    ) public view returns (bytes32 assertionId, uint256 challenge) {\\n        return _getChallenge(msg.sender, assetContract, tokenId, epoch);\\n    }\\n\\n    function sendProof(ServiceAgreementStructsV1.ProofInputArgs calldata args) external {\\n        ServiceAgreementStorageProxy sasProxy = serviceAgreementStorageProxy;\\n\\n        bytes32 agreementId = hashingProxy.callHashFunction(\\n            args.hashFunctionId,\\n            abi.encodePacked(args.assetContract, args.tokenId, args.keyword)\\n        );\\n\\n        if (!sasProxy.serviceAgreementExists(agreementId))\\n            revert ServiceAgreementErrorsV1U1.ServiceAgreementDoesntExist(agreementId);\\n\\n        uint256 latestFinalizedStateIndex = AbstractAsset(args.assetContract).getAssertionIdsLength(args.tokenId) - 1;\\n\\n        if (!reqs[0] && !isProofWindowOpen(agreementId, args.epoch)) {\\n            uint128 epochLength = sasProxy.getAgreementEpochLength(agreementId);\\n\\n            uint256 actualProofWindowStart = (sasProxy.getAgreementStartTime(agreementId) +\\n                args.epoch *\\n                epochLength +\\n                (sasProxy.getAgreementProofWindowOffsetPerc(agreementId) * epochLength) /\\n                100);\\n\\n            revert ServiceAgreementErrorsV1U1.ProofWindowClosed(\\n                agreementId,\\n                args.epoch,\\n                latestFinalizedStateIndex,\\n                actualProofWindowStart,\\n                actualProofWindowStart + (parametersStorage.proofWindowDurationPerc() * epochLength) / 100,\\n                block.timestamp\\n            );\\n        }\\n\\n        IdentityStorage ids = identityStorage;\\n\\n        uint72 identityId = ids.getIdentityId(msg.sender);\\n        bytes32 commitId = keccak256(abi.encodePacked(agreementId, args.epoch, latestFinalizedStateIndex, identityId));\\n\\n        if (!reqs[1] && (sasProxy.getCommitSubmissionScore(commitId) == 0))\\n            revert ServiceAgreementErrorsV1U1.NodeAlreadyRewarded(\\n                agreementId,\\n                args.epoch,\\n                latestFinalizedStateIndex,\\n                identityId,\\n                profileStorage.getNodeId(identityId)\\n            );\\n\\n        bytes32 nextCommitId = sasProxy.getV1U1AgreementEpochSubmissionHead(\\n            agreementId,\\n            args.epoch,\\n            latestFinalizedStateIndex\\n        );\\n        uint32 r0 = parametersStorage.r0();\\n        uint8 i;\\n        while ((identityId != sasProxy.getCommitSubmissionIdentityId(nextCommitId)) && (i < r0)) {\\n            nextCommitId = keccak256(\\n                abi.encodePacked(\\n                    agreementId,\\n                    args.epoch,\\n                    latestFinalizedStateIndex,\\n                    sasProxy.getCommitSubmissionNextIdentityId(nextCommitId)\\n                )\\n            );\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        if (!reqs[2] && (i >= r0))\\n            revert ServiceAgreementErrorsV1U1.NodeNotAwarded(\\n                agreementId,\\n                args.epoch,\\n                latestFinalizedStateIndex,\\n                identityId,\\n                profileStorage.getNodeId(identityId),\\n                i\\n            );\\n\\n        bytes32 merkleRoot;\\n        uint256 challenge;\\n        (merkleRoot, challenge) = _getChallenge(msg.sender, args.assetContract, args.tokenId, args.epoch);\\n\\n        if (\\n            !reqs[3] &&\\n            !MerkleProof.verify(args.proof, merkleRoot, keccak256(abi.encodePacked(args.chunkHash, challenge)))\\n        )\\n            revert ServiceAgreementErrorsV1U1.WrongMerkleProof(\\n                agreementId,\\n                args.epoch,\\n                latestFinalizedStateIndex,\\n                identityId,\\n                profileStorage.getNodeId(identityId),\\n                args.proof,\\n                merkleRoot,\\n                args.chunkHash,\\n                challenge\\n            );\\n\\n        emit ProofSubmitted(\\n            args.assetContract,\\n            args.tokenId,\\n            args.keyword,\\n            args.hashFunctionId,\\n            args.epoch,\\n            latestFinalizedStateIndex,\\n            identityId\\n        );\\n\\n        uint96 reward = (sasProxy.getAgreementTokenAmount(agreementId) /\\n            (sasProxy.getAgreementEpochsNumber(agreementId) - args.epoch + 1) /\\n            (r0 - sasProxy.getAgreementRewardedNodesNumber(agreementId, args.epoch)));\\n\\n        stakingContract.addReward(agreementId, identityId, reward);\\n        sasProxy.setAgreementTokenAmount(agreementId, sasProxy.getAgreementTokenAmount(agreementId) - reward);\\n        sasProxy.incrementAgreementRewardedNodesNumber(agreementId, args.epoch);\\n\\n        // To make sure that node already received reward\\n        sasProxy.setCommitSubmissionScore(commitId, 0);\\n    }\\n\\n    function setReq(uint256 index, bool req) external onlyHubOwner {\\n        reqs[index] = req;\\n    }\\n\\n    function _getChallenge(\\n        address sender,\\n        address assetContract,\\n        uint256 tokenId,\\n        uint16 epoch\\n    ) internal view returns (bytes32 assertionId, uint256 challenge) {\\n        uint72 identityId = identityStorage.getIdentityId(sender);\\n\\n        AbstractAsset generalAssetInterface = AbstractAsset(assetContract);\\n        bytes32 latestFinalizedState = generalAssetInterface.getLatestAssertionId(tokenId);\\n\\n        uint256 assertionChunksNumber = assertionStorage.getAssertionChunksNumber(latestFinalizedState);\\n\\n        // blockchash() function only works for last 256 blocks (25.6 min window in case of 6s block time)\\n        // TODO: figure out how to achieve randomness\\n        return (latestFinalizedState, uint256(sha256(abi.encodePacked(epoch, identityId))) % assertionChunksNumber);\\n    }\\n}\\n\",\"keccak256\":\"0xceb62332b709d93d2c6b6d5605fde81b6c7d6418454acfdf76abe3fdfaf612d5\",\"license\":\"MIT\"},\"contracts/ScoringProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport {ContractStatus} from \\\"./abstract/ContractStatus.sol\\\";\\nimport {IScoreFunction} from \\\"./interface/IScoreFunction.sol\\\";\\nimport {Named} from \\\"./interface/Named.sol\\\";\\nimport {Versioned} from \\\"./interface/Versioned.sol\\\";\\nimport {UnorderedIndexableContractDynamicSetLib} from \\\"./utils/UnorderedIndexableContractDynamicSet.sol\\\";\\n\\ncontract ScoringProxy is Named, Versioned, ContractStatus {\\n    using UnorderedIndexableContractDynamicSetLib for UnorderedIndexableContractDynamicSetLib.Set;\\n\\n    event NewScoringFunctionContract(uint8 indexed scoreFunctionId, address newContractAddress);\\n    event ScoringFunctionContractUpdated(uint8 indexed scoreFunctionId, address newContractAddress);\\n\\n    string private constant _NAME = \\\"ScoringProxy\\\";\\n    string private constant _VERSION = \\\"1.0.1\\\";\\n\\n    UnorderedIndexableContractDynamicSetLib.Set internal scoreFunctionSet;\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(address hubAddress) ContractStatus(hubAddress) {}\\n\\n    function name() external pure virtual override returns (string memory) {\\n        return _NAME;\\n    }\\n\\n    function version() external pure virtual override returns (string memory) {\\n        return _VERSION;\\n    }\\n\\n    function setContractAddress(uint8 scoreFunctionId, address scoringContractAddress) external onlyHubOwner {\\n        if (scoreFunctionSet.exists(scoreFunctionId)) {\\n            emit ScoringFunctionContractUpdated(scoreFunctionId, scoringContractAddress);\\n            scoreFunctionSet.update(scoreFunctionId, scoringContractAddress);\\n        } else {\\n            emit NewScoringFunctionContract(scoreFunctionId, scoringContractAddress);\\n            scoreFunctionSet.append(scoreFunctionId, scoringContractAddress);\\n        }\\n    }\\n\\n    function removeContract(uint8 scoreFunctionId) external onlyHubOwner {\\n        scoreFunctionSet.remove(scoreFunctionId);\\n    }\\n\\n    function callScoreFunction(\\n        uint8 scoreFunctionId,\\n        uint8 hashFunctionId,\\n        bytes calldata nodeId,\\n        bytes calldata keyword,\\n        uint96 stake\\n    ) external view returns (uint40) {\\n        IScoreFunction scoringFunction = IScoreFunction(scoreFunctionSet.get(scoreFunctionId).addr);\\n        uint256 distance = scoringFunction.calculateDistance(hashFunctionId, nodeId, keyword);\\n        return scoringFunction.calculateScore(distance, stake);\\n    }\\n\\n    function getScoreFunctionName(uint8 scoreFunctionId) external view returns (string memory) {\\n        return Named(scoreFunctionSet.get(scoreFunctionId).addr).name();\\n    }\\n\\n    function getScoreFunctionContractAddress(uint8 scoreFunctionId) external view returns (address) {\\n        return scoreFunctionSet.get(scoreFunctionId).addr;\\n    }\\n\\n    function getAllScoreFunctions() external view returns (UnorderedIndexableContractDynamicSetLib.Contract[] memory) {\\n        return scoreFunctionSet.getAll();\\n    }\\n\\n    function isScoreFunction(uint8 scoreFunctionId) external view returns (bool) {\\n        return scoreFunctionSet.exists(scoreFunctionId);\\n    }\\n}\\n\",\"keccak256\":\"0x859ffe3d07864b258f16bd86e33e75f005971dd24b4a6760855679bda1207dee\",\"license\":\"MIT\"},\"contracts/ServiceAgreementV1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport {CommitManagerV1} from \\\"./CommitManagerV1.sol\\\";\\nimport {CommitManagerV1U1} from \\\"./CommitManagerV1U1.sol\\\";\\nimport {HashingProxy} from \\\"./HashingProxy.sol\\\";\\nimport {ProofManagerV1} from \\\"./ProofManagerV1.sol\\\";\\nimport {ProofManagerV1U1} from \\\"./ProofManagerV1U1.sol\\\";\\nimport {ScoringProxy} from \\\"./ScoringProxy.sol\\\";\\nimport {ParametersStorage} from \\\"./storage/ParametersStorage.sol\\\";\\nimport {ServiceAgreementStorageProxy} from \\\"./storage/ServiceAgreementStorageProxy.sol\\\";\\nimport {ContractStatus} from \\\"./abstract/ContractStatus.sol\\\";\\nimport {Initializable} from \\\"./interface/Initializable.sol\\\";\\nimport {Named} from \\\"./interface/Named.sol\\\";\\nimport {Versioned} from \\\"./interface/Versioned.sol\\\";\\nimport {ServiceAgreementStructsV1} from \\\"./structs/ServiceAgreementStructsV1.sol\\\";\\nimport {GeneralErrors} from \\\"./errors/GeneralErrors.sol\\\";\\nimport {ServiceAgreementErrorsV1U1} from \\\"./errors/ServiceAgreementErrorsV1U1.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ncontract ServiceAgreementV1 is Named, Versioned, ContractStatus, Initializable {\\n    event ServiceAgreementV1Created(\\n        address indexed assetContract,\\n        uint256 indexed tokenId,\\n        bytes keyword,\\n        uint8 hashFunctionId,\\n        uint256 startTime,\\n        uint16 epochsNumber,\\n        uint128 epochLength,\\n        uint96 tokenAmount\\n    );\\n    event ServiceAgreementV1Terminated(bytes32 indexed agreementId);\\n    event ServiceAgreementV1Extended(bytes32 indexed agreementId, uint16 epochsNumber);\\n    event ServiceAgreementV1RewardRaised(bytes32 indexed agreementId, uint96 tokenAmount);\\n    event ServiceAgreementV1UpdateRewardRaised(bytes32 indexed agreementId, uint96 updateTokenAmount);\\n\\n    string private constant _NAME = \\\"ServiceAgreementV1\\\";\\n    string private constant _VERSION = \\\"1.1.1\\\";\\n\\n    CommitManagerV1 public commitManagerV1;\\n    CommitManagerV1U1 public commitManagerV1U1;\\n    ProofManagerV1 public proofManagerV1;\\n    ProofManagerV1U1 public proofManagerV1U1;\\n    HashingProxy public hashingProxy;\\n    ScoringProxy public scoringProxy;\\n    ParametersStorage public parametersStorage;\\n    ServiceAgreementStorageProxy public serviceAgreementStorageProxy;\\n    IERC20 public tokenContract;\\n\\n    error ScoreError();\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(address hubAddress) ContractStatus(hubAddress) {}\\n\\n    function initialize() public onlyHubOwner {\\n        commitManagerV1 = CommitManagerV1(hub.getContractAddress(\\\"CommitManagerV1\\\"));\\n        commitManagerV1U1 = CommitManagerV1U1(hub.getContractAddress(\\\"CommitManagerV1U1\\\"));\\n        proofManagerV1 = ProofManagerV1(hub.getContractAddress(\\\"ProofManagerV1\\\"));\\n        proofManagerV1U1 = ProofManagerV1U1(hub.getContractAddress(\\\"ProofManagerV1U1\\\"));\\n        hashingProxy = HashingProxy(hub.getContractAddress(\\\"HashingProxy\\\"));\\n        scoringProxy = ScoringProxy(hub.getContractAddress(\\\"ScoringProxy\\\"));\\n        parametersStorage = ParametersStorage(hub.getContractAddress(\\\"ParametersStorage\\\"));\\n        serviceAgreementStorageProxy = ServiceAgreementStorageProxy(\\n            hub.getContractAddress(\\\"ServiceAgreementStorageProxy\\\")\\n        );\\n        tokenContract = IERC20(hub.getContractAddress(\\\"Token\\\"));\\n    }\\n\\n    function name() external pure virtual override returns (string memory) {\\n        return _NAME;\\n    }\\n\\n    function version() external pure virtual override returns (string memory) {\\n        return _VERSION;\\n    }\\n\\n    function createServiceAgreement(\\n        ServiceAgreementStructsV1.ServiceAgreementInputArgs calldata args\\n    ) external onlyContracts {\\n        if (args.epochsNumber == 0) revert ServiceAgreementErrorsV1U1.ZeroEpochsNumber();\\n        if (args.tokenAmount == 0) revert ServiceAgreementErrorsV1U1.ZeroTokenAmount();\\n        if (!scoringProxy.isScoreFunction(args.scoreFunctionId))\\n            revert ServiceAgreementErrorsV1U1.ScoreFunctionDoesntExist(args.scoreFunctionId);\\n\\n        bytes32 agreementId = hashingProxy.callHashFunction(\\n            args.hashFunctionId,\\n            abi.encodePacked(args.assetContract, args.tokenId, args.keyword)\\n        );\\n\\n        ServiceAgreementStorageProxy sasProxy = serviceAgreementStorageProxy;\\n        ParametersStorage params = parametersStorage;\\n\\n        sasProxy.createV1ServiceAgreementObject(\\n            agreementId,\\n            args.epochsNumber,\\n            params.epochLength(),\\n            args.tokenAmount,\\n            args.scoreFunctionId,\\n            params.minProofWindowOffsetPerc() +\\n                _generatePseudorandomUint8(\\n                    args.assetCreator,\\n                    params.maxProofWindowOffsetPerc() - params.minProofWindowOffsetPerc() + 1\\n                )\\n        );\\n\\n        IERC20 tknc = tokenContract;\\n        if (tknc.allowance(args.assetCreator, address(this)) < args.tokenAmount)\\n            revert ServiceAgreementErrorsV1U1.TooLowAllowance(tknc.allowance(args.assetCreator, address(this)));\\n        if (tknc.balanceOf(args.assetCreator) < args.tokenAmount)\\n            revert ServiceAgreementErrorsV1U1.TooLowBalance(tknc.balanceOf(args.assetCreator));\\n\\n        tknc.transferFrom(args.assetCreator, sasProxy.agreementV1StorageAddress(), args.tokenAmount);\\n\\n        emit ServiceAgreementV1Created(\\n            args.assetContract,\\n            args.tokenId,\\n            args.keyword,\\n            args.hashFunctionId,\\n            block.timestamp,\\n            args.epochsNumber,\\n            params.epochLength(),\\n            args.tokenAmount\\n        );\\n    }\\n\\n    function terminateAgreement(address assetOwner, bytes32 agreementId) external onlyContracts {\\n        ServiceAgreementStorageProxy sasProxy = serviceAgreementStorageProxy;\\n\\n        uint96 agreementBalance = sasProxy.getAgreementTokenAmount(agreementId);\\n\\n        sasProxy.setAgreementTokenAmount(agreementId, 0);\\n        sasProxy.transferAgreementTokens(agreementId, assetOwner, agreementBalance);\\n        sasProxy.deleteServiceAgreementObject(agreementId);\\n\\n        emit ServiceAgreementV1Terminated(agreementId);\\n    }\\n\\n    function extendStoringPeriod(\\n        address assetOwner,\\n        bytes32 agreementId,\\n        uint16 epochsNumber,\\n        uint96 tokenAmount\\n    ) external onlyContracts {\\n        if (epochsNumber == 0) revert ServiceAgreementErrorsV1U1.ZeroEpochsNumber();\\n\\n        ServiceAgreementStorageProxy sasProxy = serviceAgreementStorageProxy;\\n\\n        sasProxy.setAgreementEpochsNumber(agreementId, sasProxy.getAgreementEpochsNumber(agreementId) + epochsNumber);\\n        sasProxy.setAgreementTokenAmount(agreementId, sasProxy.getAgreementTokenAmount(agreementId) + tokenAmount);\\n\\n        if (sasProxy.agreementV1Exists(agreementId)) {\\n            _addTokens(assetOwner, sasProxy.agreementV1StorageAddress(), tokenAmount);\\n        } else {\\n            _addTokens(assetOwner, sasProxy.agreementV1U1StorageAddress(), tokenAmount);\\n        }\\n\\n        emit ServiceAgreementV1Extended(agreementId, epochsNumber);\\n    }\\n\\n    function addTokens(address assetOwner, bytes32 agreementId, uint96 tokenAmount) external onlyContracts {\\n        ServiceAgreementStorageProxy sasProxy = serviceAgreementStorageProxy;\\n\\n        sasProxy.setAgreementTokenAmount(agreementId, sasProxy.getAgreementTokenAmount(agreementId) + tokenAmount);\\n\\n        if (sasProxy.agreementV1Exists(agreementId)) {\\n            _addTokens(assetOwner, sasProxy.agreementV1StorageAddress(), tokenAmount);\\n        } else {\\n            _addTokens(assetOwner, sasProxy.agreementV1U1StorageAddress(), tokenAmount);\\n        }\\n\\n        emit ServiceAgreementV1RewardRaised(agreementId, tokenAmount);\\n    }\\n\\n    function addUpdateTokens(address assetOwner, bytes32 agreementId, uint96 tokenAmount) external onlyContracts {\\n        ServiceAgreementStorageProxy sasProxy = serviceAgreementStorageProxy;\\n\\n        sasProxy.setAgreementUpdateTokenAmount(\\n            agreementId,\\n            sasProxy.getAgreementUpdateTokenAmount(agreementId) + tokenAmount\\n        );\\n\\n        _addTokens(assetOwner, sasProxy.agreementV1U1StorageAddress(), tokenAmount);\\n\\n        emit ServiceAgreementV1UpdateRewardRaised(agreementId, tokenAmount);\\n    }\\n\\n    function isCommitWindowOpen(bytes32 agreementId, uint16 epoch) public view returns (bool) {\\n        if (serviceAgreementStorageProxy.agreementV1Exists(agreementId)) {\\n            return commitManagerV1.isCommitWindowOpen(agreementId, epoch);\\n        } else {\\n            return commitManagerV1U1.isCommitWindowOpen(agreementId, epoch);\\n        }\\n    }\\n\\n    function getTopCommitSubmissions(\\n        bytes32 agreementId,\\n        uint16 epoch\\n    ) external view returns (ServiceAgreementStructsV1.CommitSubmission[] memory) {\\n        if (serviceAgreementStorageProxy.agreementV1Exists(agreementId)) {\\n            return commitManagerV1.getTopCommitSubmissions(agreementId, epoch);\\n        } else {\\n            return commitManagerV1U1.getTopCommitSubmissions(agreementId, epoch, 0);\\n        }\\n    }\\n\\n    function submitCommit(ServiceAgreementStructsV1.CommitInputArgs calldata args) external {\\n        bytes32 agreementId = hashingProxy.callHashFunction(\\n            args.hashFunctionId,\\n            abi.encodePacked(args.assetContract, args.tokenId, args.keyword)\\n        );\\n\\n        if (serviceAgreementStorageProxy.agreementV1Exists(agreementId)) {\\n            commitManagerV1.submitCommit(args);\\n        } else {\\n            commitManagerV1U1.submitCommit(args);\\n        }\\n    }\\n\\n    function isProofWindowOpen(bytes32 agreementId, uint16 epoch) public view returns (bool) {\\n        if (serviceAgreementStorageProxy.agreementV1Exists(agreementId)) {\\n            return proofManagerV1.isProofWindowOpen(agreementId, epoch);\\n        } else {\\n            return proofManagerV1U1.isProofWindowOpen(agreementId, epoch);\\n        }\\n    }\\n\\n    function getChallenge(\\n        address sender,\\n        address assetContract,\\n        uint256 tokenId,\\n        uint16 epoch\\n    ) public view returns (bytes32 assertionId, uint256 challenge) {\\n        return proofManagerV1.getChallenge(sender, assetContract, tokenId, epoch);\\n    }\\n\\n    function sendProof(ServiceAgreementStructsV1.ProofInputArgs calldata args) external {\\n        bytes32 agreementId = hashingProxy.callHashFunction(\\n            args.hashFunctionId,\\n            abi.encodePacked(args.assetContract, args.tokenId, args.keyword)\\n        );\\n\\n        if (serviceAgreementStorageProxy.agreementV1Exists(agreementId)) {\\n            proofManagerV1.sendProof(args);\\n        } else {\\n            proofManagerV1U1.sendProof(args);\\n        }\\n    }\\n\\n    function _addTokens(address assetOwner, address sasAddress, uint96 tokenAmount) internal virtual {\\n        if (tokenAmount == 0) revert ServiceAgreementErrorsV1U1.ZeroTokenAmount();\\n\\n        IERC20 tknc = tokenContract;\\n\\n        if (tknc.allowance(assetOwner, address(this)) < tokenAmount)\\n            revert ServiceAgreementErrorsV1U1.TooLowAllowance(tknc.allowance(assetOwner, address(this)));\\n        if (tknc.balanceOf(assetOwner) < tokenAmount)\\n            revert ServiceAgreementErrorsV1U1.TooLowBalance(tknc.balanceOf(assetOwner));\\n\\n        tknc.transferFrom(assetOwner, sasAddress, tokenAmount);\\n    }\\n\\n    function _generatePseudorandomUint8(address sender, uint8 limit) internal view virtual returns (uint8) {\\n        return uint8(uint256(keccak256(abi.encodePacked(block.timestamp, sender, block.number))) % limit);\\n    }\\n}\\n\",\"keccak256\":\"0xa86f9eef2f0ced5668383549ad1bbe0fcacaa0d217be969ce9168d4cf23d936f\",\"license\":\"MIT\"},\"contracts/ShardingTable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport {ProfileStorage} from \\\"./storage/ProfileStorage.sol\\\";\\nimport {ShardingTableStorage} from \\\"./storage/ShardingTableStorage.sol\\\";\\nimport {StakingStorage} from \\\"./storage/StakingStorage.sol\\\";\\nimport {ContractStatus} from \\\"./abstract/ContractStatus.sol\\\";\\nimport {Initializable} from \\\"./interface/Initializable.sol\\\";\\nimport {Named} from \\\"./interface/Named.sol\\\";\\nimport {Versioned} from \\\"./interface/Versioned.sol\\\";\\nimport {ShardingTableStructs} from \\\"./structs/ShardingTableStructs.sol\\\";\\nimport {NULL} from \\\"./constants/ShardingTableConstants.sol\\\";\\n\\ncontract ShardingTable is Named, Versioned, ContractStatus, Initializable {\\n    event NodeAdded(uint72 indexed identityId, bytes nodeId, uint96 ask, uint96 stake);\\n    event NodeRemoved(uint72 indexed identityId, bytes nodeId);\\n\\n    string private constant _NAME = \\\"ShardingTable\\\";\\n    string private constant _VERSION = \\\"1.0.1\\\";\\n\\n    ProfileStorage public profileStorage;\\n    ShardingTableStorage public shardingTableStorage;\\n    StakingStorage public stakingStorage;\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(address hubAddress) ContractStatus(hubAddress) {}\\n\\n    function initialize() public onlyHubOwner {\\n        profileStorage = ProfileStorage(hub.getContractAddress(\\\"ProfileStorage\\\"));\\n        shardingTableStorage = ShardingTableStorage(hub.getContractAddress(\\\"ShardingTableStorage\\\"));\\n        stakingStorage = StakingStorage(hub.getContractAddress(\\\"StakingStorage\\\"));\\n    }\\n\\n    function name() external pure virtual override returns (string memory) {\\n        return _NAME;\\n    }\\n\\n    function version() external pure virtual override returns (string memory) {\\n        return _VERSION;\\n    }\\n\\n    function getShardingTable(\\n        uint72 startingIdentityId,\\n        uint72 nodesNumber\\n    ) external view returns (ShardingTableStructs.NodeInfo[] memory) {\\n        return _getShardingTable(startingIdentityId, nodesNumber);\\n    }\\n\\n    function getShardingTable() external view returns (ShardingTableStructs.NodeInfo[] memory) {\\n        ShardingTableStorage sts = shardingTableStorage;\\n        return _getShardingTable(sts.head(), sts.nodesCount());\\n    }\\n\\n    function pushBack(uint72 identityId) external onlyContracts {\\n        ProfileStorage ps = profileStorage;\\n        require(ps.profileExists(identityId), \\\"Profile doesn't exist\\\");\\n\\n        ShardingTableStorage sts = shardingTableStorage;\\n\\n        sts.createNodeObject(identityId, NULL, NULL);\\n\\n        if (sts.tail() != NULL) sts.link(sts.tail(), identityId);\\n\\n        sts.setTail(identityId);\\n\\n        if (sts.head() == NULL) sts.setHead(identityId);\\n\\n        sts.incrementNodesCount();\\n\\n        emit NodeAdded(\\n            identityId,\\n            ps.getNodeId(identityId),\\n            ps.getAsk(identityId),\\n            stakingStorage.totalStakes(identityId)\\n        );\\n    }\\n\\n    function pushFront(uint72 identityId) external onlyContracts {\\n        ProfileStorage ps = profileStorage;\\n        require(ps.profileExists(identityId), \\\"Profile doesn't exist\\\");\\n\\n        ShardingTableStorage sts = shardingTableStorage;\\n\\n        sts.createNodeObject(identityId, NULL, NULL);\\n\\n        if (sts.head() != NULL) sts.link(identityId, sts.head());\\n\\n        shardingTableStorage.setHead(identityId);\\n\\n        if (sts.tail() == NULL) sts.setTail(identityId);\\n\\n        sts.incrementNodesCount();\\n\\n        emit NodeAdded(\\n            identityId,\\n            ps.getNodeId(identityId),\\n            ps.getAsk(identityId),\\n            stakingStorage.totalStakes(identityId)\\n        );\\n    }\\n\\n    function removeNode(uint72 identityId) external onlyContracts {\\n        ProfileStorage ps = profileStorage;\\n        require(ps.profileExists(identityId), \\\"Profile doesn't exist\\\");\\n\\n        ShardingTableStorage sts = shardingTableStorage;\\n\\n        ShardingTableStructs.Node memory nodeToRemove = sts.getNode(identityId);\\n\\n        uint72 head = sts.head();\\n        uint72 tail = sts.tail();\\n\\n        if ((head == identityId) && (tail == identityId)) {\\n            sts.setHead(NULL);\\n            sts.setTail(NULL);\\n        } else if (tail == identityId) {\\n            sts.setTail(nodeToRemove.prevIdentityId);\\n            sts.setNextIdentityId(tail, NULL);\\n        } else if (head == identityId) {\\n            sts.setHead(nodeToRemove.nextIdentityId);\\n            sts.setPrevIdentityId(head, NULL);\\n        } else {\\n            sts.link(nodeToRemove.prevIdentityId, nodeToRemove.nextIdentityId);\\n        }\\n\\n        sts.deleteNodeObject(identityId);\\n        sts.decrementNodesCount();\\n\\n        emit NodeRemoved(identityId, ps.getNodeId(identityId));\\n    }\\n\\n    function _getShardingTable(\\n        uint72 startingIdentityId,\\n        uint72 nodesNumber\\n    ) internal view virtual returns (ShardingTableStructs.NodeInfo[] memory) {\\n        ShardingTableStructs.NodeInfo[] memory nodesPage;\\n        ShardingTableStorage sts = shardingTableStorage;\\n\\n        if ((sts.nodesCount() == 0) || (nodesNumber == 0)) {\\n            return nodesPage;\\n        }\\n\\n        ShardingTableStructs.Node memory startingNode = sts.getNode(startingIdentityId);\\n\\n        require((startingIdentityId == NULL) || (startingNode.identityId != NULL), \\\"Wrong starting Identity ID\\\");\\n\\n        nodesPage = new ShardingTableStructs.NodeInfo[](nodesNumber);\\n\\n        ProfileStorage ps = profileStorage;\\n        StakingStorage ss = stakingStorage;\\n\\n        nodesPage[0] = ShardingTableStructs.NodeInfo({\\n            nodeId: ps.getNodeId(startingIdentityId),\\n            identityId: startingIdentityId,\\n            ask: ps.getAsk(startingNode.identityId),\\n            stake: ss.totalStakes(startingNode.identityId)\\n        });\\n\\n        uint72 nextIdentityId = startingIdentityId;\\n        uint72 i = 1;\\n        while ((i < nodesNumber) && (nextIdentityId != NULL)) {\\n            nextIdentityId = sts.getNode(nextIdentityId).nextIdentityId;\\n\\n            nodesPage[i] = ShardingTableStructs.NodeInfo({\\n                nodeId: ps.getNodeId(nextIdentityId),\\n                identityId: nextIdentityId,\\n                ask: ps.getAsk(nextIdentityId),\\n                stake: ss.totalStakes(nextIdentityId)\\n            });\\n\\n            unchecked {\\n                i += 1;\\n            }\\n        }\\n\\n        return nodesPage;\\n    }\\n}\\n\",\"keccak256\":\"0xdc5fcd9c08b1794fc7c251733a15ae9af7f8744ec80b1a70924f6219ca3e62cd\",\"license\":\"MIT\"},\"contracts/Shares.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport {HubDependent} from \\\"./abstract/HubDependent.sol\\\";\\nimport {ERC20} from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport {ERC20Burnable} from \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\\\";\\n\\ncontract Shares is HubDependent, ERC20, ERC20Burnable {\\n    constructor(\\n        address hubAddress,\\n        string memory name,\\n        string memory symbol\\n    )\\n        HubDependent(hubAddress)\\n        ERC20(name, symbol) // solhint-disable-next-line no-empty-blocks\\n    {}\\n\\n    function mint(address to, uint256 amount) external onlyContracts {\\n        _mint(to, amount);\\n    }\\n}\\n\",\"keccak256\":\"0x5ba555c0e9109f8e9a17a98a7a30643c9849059ea9b80693c9e2d460d679666d\",\"license\":\"MIT\"},\"contracts/Staking.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport {ShardingTable} from \\\"./ShardingTable.sol\\\";\\nimport {Shares} from \\\"./Shares.sol\\\";\\nimport {IdentityStorage} from \\\"./storage/IdentityStorage.sol\\\";\\nimport {ParametersStorage} from \\\"./storage/ParametersStorage.sol\\\";\\nimport {ProfileStorage} from \\\"./storage/ProfileStorage.sol\\\";\\nimport {ServiceAgreementStorageProxy} from \\\"./storage/ServiceAgreementStorageProxy.sol\\\";\\nimport {ShardingTableStorage} from \\\"./storage/ShardingTableStorage.sol\\\";\\nimport {StakingStorage} from \\\"./storage/StakingStorage.sol\\\";\\nimport {ContractStatus} from \\\"./abstract/ContractStatus.sol\\\";\\nimport {Initializable} from \\\"./interface/Initializable.sol\\\";\\nimport {Named} from \\\"./interface/Named.sol\\\";\\nimport {Versioned} from \\\"./interface/Versioned.sol\\\";\\nimport {ADMIN_KEY} from \\\"./constants/IdentityConstants.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ncontract Staking is Named, Versioned, ContractStatus, Initializable {\\n    event StakeIncreased(\\n        uint72 indexed identityId,\\n        bytes nodeId,\\n        address indexed staker,\\n        uint96 oldStake,\\n        uint96 newStake\\n    );\\n    event StakeWithdrawalStarted(\\n        uint72 indexed identityId,\\n        bytes nodeId,\\n        address indexed staker,\\n        uint96 oldStake,\\n        uint96 newStake,\\n        uint256 withdrawalPeriodEnd\\n    );\\n    event StakeWithdrawn(uint72 indexed identityId, bytes nodeId, address indexed staker, uint96 withdrawnStakeAmount);\\n    event AccumulatedOperatorFeeIncreased(\\n        uint72 indexed identityId,\\n        bytes nodeId,\\n        uint96 oldAccumulatedOperatorFee,\\n        uint96 newAccumulatedOperatorFee\\n    );\\n    event OperatorFeeUpdated(uint72 indexed identityId, bytes nodeId, uint8 operatorFee);\\n\\n    string private constant _NAME = \\\"Staking\\\";\\n    string private constant _VERSION = \\\"1.0.2\\\";\\n\\n    ShardingTable public shardingTableContract;\\n    IdentityStorage public identityStorage;\\n    ParametersStorage public parametersStorage;\\n    ProfileStorage public profileStorage;\\n    StakingStorage public stakingStorage;\\n    ServiceAgreementStorageProxy public serviceAgreementStorageProxy;\\n    ShardingTableStorage public shardingTableStorage;\\n    IERC20 public tokenContract;\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(address hubAddress) ContractStatus(hubAddress) {}\\n\\n    modifier onlyAdmin(uint72 identityId) {\\n        _checkAdmin(identityId);\\n        _;\\n    }\\n\\n    function initialize() public onlyHubOwner {\\n        shardingTableContract = ShardingTable(hub.getContractAddress(\\\"ShardingTable\\\"));\\n        identityStorage = IdentityStorage(hub.getContractAddress(\\\"IdentityStorage\\\"));\\n        parametersStorage = ParametersStorage(hub.getContractAddress(\\\"ParametersStorage\\\"));\\n        profileStorage = ProfileStorage(hub.getContractAddress(\\\"ProfileStorage\\\"));\\n        stakingStorage = StakingStorage(hub.getContractAddress(\\\"StakingStorage\\\"));\\n        serviceAgreementStorageProxy = ServiceAgreementStorageProxy(\\n            hub.getContractAddress(\\\"ServiceAgreementStorageProxy\\\")\\n        );\\n        shardingTableStorage = ShardingTableStorage(hub.getContractAddress(\\\"ShardingTableStorage\\\"));\\n        tokenContract = IERC20(hub.getContractAddress(\\\"Token\\\"));\\n    }\\n\\n    function name() external pure virtual override returns (string memory) {\\n        return _NAME;\\n    }\\n\\n    function version() external pure virtual override returns (string memory) {\\n        return _VERSION;\\n    }\\n\\n    function addStake(address sender, uint72 identityId, uint96 stakeAmount) external onlyContracts {\\n        _addStake(sender, identityId, stakeAmount);\\n    }\\n\\n    function addStake(uint72 identityId, uint96 stakeAmount) external onlyAdmin(identityId) {\\n        _addStake(msg.sender, identityId, stakeAmount);\\n    }\\n\\n    function startStakeWithdrawal(uint72 identityId, uint96 sharesToBurn) external {\\n        require(sharesToBurn != 0, \\\"Withdrawal amount cannot be 0\\\");\\n\\n        ProfileStorage ps = profileStorage;\\n        StakingStorage ss = stakingStorage;\\n\\n        require(ps.profileExists(identityId), \\\"Profile doesn't exist\\\");\\n\\n        Shares sharesContract = Shares(ps.getSharesContractAddress(identityId));\\n\\n        require(sharesToBurn <= sharesContract.balanceOf(msg.sender), \\\"sharesToBurn must be <= balance\\\");\\n\\n        uint96 oldStake = ss.totalStakes(identityId);\\n        uint96 stakeWithdrawalAmount = uint96((uint256(oldStake) * sharesToBurn) / sharesContract.totalSupply());\\n        uint96 newStake = oldStake - stakeWithdrawalAmount;\\n        uint96 newStakeWithdrawalAmount = ss.getWithdrawalRequestAmount(identityId, msg.sender) + stakeWithdrawalAmount;\\n\\n        ParametersStorage params = parametersStorage;\\n\\n        uint256 withdrawalPeriodEnd = block.timestamp + params.stakeWithdrawalDelay();\\n        ss.createWithdrawalRequest(identityId, msg.sender, newStakeWithdrawalAmount, withdrawalPeriodEnd);\\n        ss.setTotalStake(identityId, newStake);\\n        sharesContract.burnFrom(msg.sender, sharesToBurn);\\n\\n        if (shardingTableStorage.nodeExists(identityId) && (newStake < params.minimumStake())) {\\n            shardingTableContract.removeNode(identityId);\\n        }\\n\\n        emit StakeWithdrawalStarted(\\n            identityId,\\n            ps.getNodeId(identityId),\\n            msg.sender,\\n            oldStake,\\n            newStake,\\n            withdrawalPeriodEnd\\n        );\\n    }\\n\\n    function withdrawStake(uint72 identityId) external {\\n        ProfileStorage ps = profileStorage;\\n\\n        require(ps.profileExists(identityId), \\\"Profile doesn't exist\\\");\\n\\n        StakingStorage ss = stakingStorage;\\n\\n        uint96 stakeWithdrawalAmount;\\n        uint256 withdrawalTimestamp;\\n        (stakeWithdrawalAmount, withdrawalTimestamp) = ss.withdrawalRequests(identityId, msg.sender);\\n\\n        require(stakeWithdrawalAmount != 0, \\\"Withdrawal hasn't been initiated\\\");\\n        require(withdrawalTimestamp < block.timestamp, \\\"Withdrawal period hasn't ended\\\");\\n\\n        ss.deleteWithdrawalRequest(identityId, msg.sender);\\n        ss.transferStake(msg.sender, stakeWithdrawalAmount);\\n\\n        emit StakeWithdrawn(identityId, ps.getNodeId(identityId), msg.sender, stakeWithdrawalAmount);\\n    }\\n\\n    function addReward(bytes32 agreementId, uint72 identityId, uint96 rewardAmount) external onlyContracts {\\n        ServiceAgreementStorageProxy sasProxy = serviceAgreementStorageProxy;\\n        StakingStorage ss = stakingStorage;\\n\\n        uint96 operatorFee = (rewardAmount * ss.operatorFees(identityId)) / 100;\\n        uint96 delegatorsReward = rewardAmount - operatorFee;\\n\\n        ProfileStorage ps = profileStorage;\\n\\n        uint96 oldAccumulatedOperatorFee = ps.getAccumulatedOperatorFee(identityId);\\n        uint96 oldStake = ss.totalStakes(identityId);\\n\\n        if (operatorFee != 0) {\\n            ps.setAccumulatedOperatorFee(identityId, oldAccumulatedOperatorFee + operatorFee);\\n            sasProxy.transferAgreementTokens(agreementId, address(ps), operatorFee);\\n        }\\n\\n        if (delegatorsReward != 0) {\\n            ss.setTotalStake(identityId, oldStake + delegatorsReward);\\n            sasProxy.transferAgreementTokens(agreementId, address(ss), delegatorsReward);\\n\\n            if (!shardingTableStorage.nodeExists(identityId) && oldStake >= parametersStorage.minimumStake()) {\\n                shardingTableContract.pushBack(identityId);\\n            }\\n        }\\n\\n        emit AccumulatedOperatorFeeIncreased(\\n            identityId,\\n            ps.getNodeId(identityId),\\n            oldAccumulatedOperatorFee,\\n            oldAccumulatedOperatorFee + operatorFee\\n        );\\n\\n        address sasAddress;\\n        if (sasProxy.agreementV1Exists(agreementId)) {\\n            sasAddress = sasProxy.agreementV1StorageAddress();\\n        } else {\\n            sasAddress = sasProxy.agreementV1U1StorageAddress();\\n        }\\n\\n        emit StakeIncreased(identityId, ps.getNodeId(identityId), sasAddress, oldStake, oldStake + delegatorsReward);\\n    }\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    function slash(uint72 identityId) external onlyContracts {\\n        // TBD\\n    }\\n\\n    function setOperatorFee(uint72 identityId, uint8 operatorFee) external onlyAdmin(identityId) {\\n        require(operatorFee <= 100, \\\"Operator fee out of [0, 100]\\\");\\n        stakingStorage.setOperatorFee(identityId, operatorFee);\\n\\n        emit OperatorFeeUpdated(identityId, profileStorage.getNodeId(identityId), operatorFee);\\n    }\\n\\n    function _addStake(address sender, uint72 identityId, uint96 stakeAmount) internal virtual {\\n        StakingStorage ss = stakingStorage;\\n        ProfileStorage ps = profileStorage;\\n        ParametersStorage params = parametersStorage;\\n        IERC20 tknc = tokenContract;\\n\\n        uint96 oldStake = ss.totalStakes(identityId);\\n        uint96 newStake = oldStake + stakeAmount;\\n\\n        require(ps.profileExists(identityId), \\\"Profile doesn't exist\\\");\\n        require(tknc.allowance(sender, address(this)) >= stakeAmount, \\\"Allowance < stakeAmount\\\");\\n        require(newStake <= params.maximumStake(), \\\"Exceeded the maximum stake\\\");\\n\\n        Shares sharesContract = Shares(ps.getSharesContractAddress(identityId));\\n\\n        uint256 sharesMinted;\\n        if (sharesContract.totalSupply() == 0) {\\n            sharesMinted = stakeAmount;\\n        } else {\\n            sharesMinted = ((stakeAmount * sharesContract.totalSupply()) / oldStake);\\n        }\\n        sharesContract.mint(sender, sharesMinted);\\n\\n        ss.setTotalStake(identityId, newStake);\\n        tknc.transferFrom(sender, address(ss), stakeAmount);\\n\\n        if (!shardingTableStorage.nodeExists(identityId) && newStake >= params.minimumStake()) {\\n            shardingTableContract.pushBack(identityId);\\n        }\\n\\n        emit StakeIncreased(identityId, ps.getNodeId(identityId), sender, oldStake, newStake);\\n    }\\n\\n    function _checkAdmin(uint72 identityId) internal view virtual {\\n        require(\\n            identityStorage.keyHasPurpose(identityId, keccak256(abi.encodePacked(msg.sender)), ADMIN_KEY),\\n            \\\"Admin function\\\"\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x8100c10505e4d64c2f1f7f388616bc7d82c3a00fa66299cfb79ad4e3a6538d9a\",\"license\":\"MIT\"},\"contracts/abstract/AbstractAsset.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport {HubDependent} from \\\"../abstract/HubDependent.sol\\\";\\nimport {Named} from \\\"../interface/Named.sol\\\";\\nimport {Versioned} from \\\"../interface/Versioned.sol\\\";\\n\\nabstract contract AbstractAsset is Named, Versioned, HubDependent {\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(address hubAddress) HubDependent(hubAddress) {}\\n\\n    function getAssertionIds(uint256 tokenId) public view virtual returns (bytes32[] memory);\\n\\n    function getLatestAssertionId(uint256 tokenId) external view returns (bytes32) {\\n        bytes32[] memory assertions = getAssertionIds(tokenId);\\n        return assertions[assertions.length - 1];\\n    }\\n\\n    function getAssertionIdByIndex(uint256 tokenId, uint256 index) external view returns (bytes32) {\\n        bytes32[] memory assertions = getAssertionIds(tokenId);\\n        return assertions[index];\\n    }\\n\\n    function getAssertionIdsLength(uint256 tokenId) external view returns (uint256) {\\n        return getAssertionIds(tokenId).length;\\n    }\\n}\\n\",\"keccak256\":\"0x3facdea0bc5feabf23b7ff13898e036a6b3a521dfc849a461b564032737f8bf3\",\"license\":\"MIT\"},\"contracts/abstract/ContractStatus.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport {HubDependent} from \\\"./HubDependent.sol\\\";\\n\\nabstract contract ContractStatus is HubDependent {\\n    bool public status;\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(address hubAddress) HubDependent(hubAddress) {}\\n\\n    function setStatus(bool _status) external onlyHubOwner {\\n        status = _status;\\n    }\\n}\\n\",\"keccak256\":\"0x1a770a3dea223c33b0d6d7e522186af2b41e6d1012209f329cd4b3cf4180ef61\",\"license\":\"MIT\"},\"contracts/abstract/HubDependent.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport {Hub} from \\\"../Hub.sol\\\";\\n\\nabstract contract HubDependent {\\n    Hub public hub;\\n\\n    constructor(address hubAddress) {\\n        require(hubAddress != address(0), \\\"Hub Address cannot be 0x0\\\");\\n\\n        hub = Hub(hubAddress);\\n    }\\n\\n    modifier onlyHubOwner() {\\n        _checkHubOwner();\\n        _;\\n    }\\n\\n    modifier onlyContracts() {\\n        _checkHub();\\n        _;\\n    }\\n\\n    function _checkHubOwner() internal view virtual {\\n        require(msg.sender == hub.owner(), \\\"Fn can only be used by hub owner\\\");\\n    }\\n\\n    function _checkHub() internal view virtual {\\n        require(hub.isContract(msg.sender), \\\"Fn can only be called by the hub\\\");\\n    }\\n}\\n\",\"keccak256\":\"0xf9cadb8d1ee628ef5ece2631ca5d622b30bfd54d4666812b401746a4e5643fbe\",\"license\":\"MIT\"},\"contracts/assets/ContentAsset.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport {Assertion} from \\\"../Assertion.sol\\\";\\nimport {HashingProxy} from \\\"../HashingProxy.sol\\\";\\nimport {ServiceAgreementV1} from \\\"../ServiceAgreementV1.sol\\\";\\nimport {ContentAssetStorage} from \\\"../storage/assets/ContentAssetStorage.sol\\\";\\nimport {ParametersStorage} from \\\"../storage/ParametersStorage.sol\\\";\\nimport {ServiceAgreementStorageProxy} from \\\"../storage/ServiceAgreementStorageProxy.sol\\\";\\nimport {UnfinalizedStateStorage} from \\\"../storage/UnfinalizedStateStorage.sol\\\";\\nimport {HubDependent} from \\\"../abstract/HubDependent.sol\\\";\\nimport {Initializable} from \\\"../interface/Initializable.sol\\\";\\nimport {Named} from \\\"../interface/Named.sol\\\";\\nimport {Versioned} from \\\"../interface/Versioned.sol\\\";\\nimport {ContentAssetStructs} from \\\"../structs/assets/ContentAssetStructs.sol\\\";\\nimport {ServiceAgreementStructsV1} from \\\"../structs/ServiceAgreementStructsV1.sol\\\";\\nimport {ContentAssetErrors} from \\\"../errors/assets/ContentAssetErrors.sol\\\";\\nimport {HASH_FUNCTION_ID} from \\\"../constants/assets/ContentAssetConstants.sol\\\";\\n\\ncontract ContentAsset is Named, Versioned, HubDependent, Initializable {\\n    event AssetMinted(address indexed assetContract, uint256 indexed tokenId, bytes32 indexed state);\\n    event AssetBurnt(address indexed assetContract, uint256 indexed tokenId, uint96 returnedTokenAmount);\\n    event AssetStateUpdated(\\n        address indexed assetContract,\\n        uint256 indexed tokenId,\\n        uint256 indexed stateIndex,\\n        uint96 updateTokenAmount\\n    );\\n    event AssetStateUpdateCanceled(\\n        address indexed assetContract,\\n        uint256 indexed tokenId,\\n        uint256 indexed stateIndex,\\n        uint96 returnedTokenAmount\\n    );\\n    event AssetStoringPeriodExtended(\\n        address indexed assetContract,\\n        uint256 indexed tokenId,\\n        uint16 epochsNumber,\\n        uint96 tokenAmount\\n    );\\n    event AssetPaymentIncreased(address indexed assetContract, uint256 indexed tokenId, uint96 tokenAmount);\\n    event AssetUpdatePaymentIncreased(address indexed assetContract, uint256 indexed tokenId, uint96 tokenAmount);\\n\\n    string private constant _NAME = \\\"ContentAsset\\\";\\n    string private constant _VERSION = \\\"1.0.0\\\";\\n\\n    Assertion public assertionContract;\\n    HashingProxy public hashingProxy;\\n    ContentAssetStorage public contentAssetStorage;\\n    ParametersStorage public parametersStorage;\\n    ServiceAgreementStorageProxy public serviceAgreementStorageProxy;\\n    ServiceAgreementV1 public serviceAgreementV1;\\n    UnfinalizedStateStorage public unfinalizedStateStorage;\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(address hubAddress) HubDependent(hubAddress) {}\\n\\n    function initialize() public onlyHubOwner {\\n        assertionContract = Assertion(hub.getContractAddress(\\\"Assertion\\\"));\\n        hashingProxy = HashingProxy(hub.getContractAddress(\\\"HashingProxy\\\"));\\n        contentAssetStorage = ContentAssetStorage(hub.getAssetStorageAddress(\\\"ContentAssetStorage\\\"));\\n        parametersStorage = ParametersStorage(hub.getContractAddress(\\\"ParametersStorage\\\"));\\n        serviceAgreementStorageProxy = ServiceAgreementStorageProxy(\\n            hub.getContractAddress(\\\"ServiceAgreementStorageProxy\\\")\\n        );\\n        serviceAgreementV1 = ServiceAgreementV1(hub.getContractAddress(\\\"ServiceAgreementV1\\\"));\\n        unfinalizedStateStorage = UnfinalizedStateStorage(hub.getContractAddress(\\\"UnfinalizedStateStorage\\\"));\\n    }\\n\\n    modifier onlyAssetOwner(uint256 tokenId) {\\n        _checkAssetOwner(tokenId);\\n        _;\\n    }\\n\\n    modifier onlyMutable(uint256 tokenId) {\\n        _checkMutability(tokenId);\\n        _;\\n    }\\n\\n    function name() external pure override returns (string memory) {\\n        return _NAME;\\n    }\\n\\n    function version() external pure override returns (string memory) {\\n        return _VERSION;\\n    }\\n\\n    function createAsset(ContentAssetStructs.AssetInputArgs calldata args) external {\\n        _createAsset(\\n            args.assertionId,\\n            args.size,\\n            args.triplesNumber,\\n            args.chunksNumber,\\n            args.epochsNumber,\\n            args.tokenAmount,\\n            args.scoreFunctionId,\\n            args.immutable_\\n        );\\n    }\\n\\n    function createAssetWithVariables(\\n        bytes32 assertionId,\\n        uint128 size,\\n        uint32 triplesNumber,\\n        uint96 chunksNumber,\\n        uint16 epochsNumber,\\n        uint96 tokenAmount,\\n        uint8 scoreFunctionId,\\n        bool immutable_\\n    ) external {\\n        _createAsset(\\n            assertionId,\\n            size,\\n            triplesNumber,\\n            chunksNumber,\\n            epochsNumber,\\n            tokenAmount,\\n            scoreFunctionId,\\n            immutable_\\n        );\\n    }\\n\\n    function burnAsset(uint256 tokenId) external onlyAssetOwner(tokenId) {\\n        ContentAssetStorage cas = contentAssetStorage;\\n\\n        address contentAssetStorageAddress = address(cas);\\n\\n        bytes memory keyword = abi.encodePacked(contentAssetStorageAddress, cas.getAssertionIdByIndex(tokenId, 0));\\n\\n        bytes32 agreementId = hashingProxy.callHashFunction(\\n            HASH_FUNCTION_ID,\\n            abi.encodePacked(contentAssetStorageAddress, tokenId, keyword)\\n        );\\n\\n        bytes32 unfinalizedState = unfinalizedStateStorage.getUnfinalizedState(tokenId);\\n\\n        if (unfinalizedState != bytes32(0))\\n            revert ContentAssetErrors.UpdateIsNotFinalized(contentAssetStorageAddress, tokenId, unfinalizedState);\\n\\n        ServiceAgreementStorageProxy sasProxy = serviceAgreementStorageProxy;\\n        ParametersStorage params = parametersStorage;\\n\\n        uint256 timeNow = block.timestamp;\\n        uint256 epochStart = sasProxy.getAgreementStartTime(agreementId);\\n        uint256 commitPhaseEnd = epochStart +\\n            (sasProxy.getAgreementEpochLength(agreementId) * params.commitWindowDurationPerc()) /\\n            100;\\n        uint256 epochEnd = epochStart + sasProxy.getAgreementEpochLength(agreementId);\\n        uint16 epoch = 0;\\n        uint8 commitsCount = sasProxy.getCommitsCount(\\n            keccak256(abi.encodePacked(agreementId, epoch, cas.getAssertionIdsLength(tokenId) - 1))\\n        );\\n        uint32 r0 = params.r0();\\n\\n        if ((timeNow < commitPhaseEnd) && (commitsCount < r0)) {\\n            revert ContentAssetErrors.CommitPhaseOngoing(agreementId);\\n        } else if ((timeNow < epochEnd) && (commitsCount >= r0)) {\\n            revert ContentAssetErrors.CommitPhaseSucceeded(agreementId);\\n        } else if (timeNow > epochEnd) {\\n            revert ContentAssetErrors.FirstEpochHasAlreadyEnded(agreementId);\\n        }\\n\\n        uint96 tokenAmount = sasProxy.getAgreementTokenAmount(agreementId);\\n\\n        cas.deleteAsset(tokenId);\\n        cas.burn(tokenId);\\n        serviceAgreementV1.terminateAgreement(msg.sender, agreementId);\\n\\n        emit AssetBurnt(contentAssetStorageAddress, tokenId, tokenAmount);\\n    }\\n\\n    function updateAssetState(\\n        uint256 tokenId,\\n        bytes32 assertionId,\\n        uint128 size,\\n        uint32 triplesNumber,\\n        uint96 chunksNumber,\\n        uint96 updateTokenAmount\\n    ) external onlyAssetOwner(tokenId) onlyMutable(tokenId) {\\n        ContentAssetStorage cas = contentAssetStorage;\\n        UnfinalizedStateStorage uss = unfinalizedStateStorage;\\n        ServiceAgreementStorageProxy sasProxy = serviceAgreementStorageProxy;\\n\\n        address contentAssetStorageAddress = address(cas);\\n\\n        bytes memory keyword = abi.encodePacked(contentAssetStorageAddress, cas.getAssertionIdByIndex(tokenId, 0));\\n\\n        bytes32 agreementId = hashingProxy.callHashFunction(\\n            HASH_FUNCTION_ID,\\n            abi.encodePacked(contentAssetStorageAddress, tokenId, keyword)\\n        );\\n\\n        uint256 startTime;\\n        uint16 epochsNumber;\\n        uint128 epochLength;\\n        uint8[2] memory scoreFunctionIdAndProofWindowOffsetPerc;\\n        (startTime, epochsNumber, epochLength, , scoreFunctionIdAndProofWindowOffsetPerc) = sasProxy.getAgreementData(\\n            agreementId\\n        );\\n\\n        if (block.timestamp > startTime + epochsNumber * epochLength) revert ContentAssetErrors.AssetExpired(tokenId);\\n\\n        bytes32 unfinalizedState = uss.getUnfinalizedState(tokenId);\\n\\n        if (unfinalizedState != bytes32(0))\\n            revert ContentAssetErrors.UpdateIsNotFinalized(contentAssetStorageAddress, tokenId, unfinalizedState);\\n\\n        assertionContract.createAssertion(assertionId, size, triplesNumber, chunksNumber);\\n        uss.setUnfinalizedState(tokenId, assertionId);\\n        uss.setIssuer(tokenId, msg.sender);\\n\\n        if (!sasProxy.agreementV1U1Exists(agreementId)) {\\n            sasProxy.createV1U1ServiceAgreementObject(\\n                agreementId,\\n                startTime,\\n                epochsNumber,\\n                epochLength,\\n                0,\\n                scoreFunctionIdAndProofWindowOffsetPerc[0],\\n                scoreFunctionIdAndProofWindowOffsetPerc[1]\\n            );\\n        }\\n\\n        if (updateTokenAmount != 0) serviceAgreementV1.addUpdateTokens(msg.sender, agreementId, updateTokenAmount);\\n\\n        uint256 unfinalizedStateIndex = cas.getAssertionIdsLength(tokenId);\\n        sasProxy.setUpdateCommitsDeadline(\\n            keccak256(abi.encodePacked(agreementId, unfinalizedStateIndex)),\\n            block.timestamp + parametersStorage.updateCommitWindowDuration()\\n        );\\n\\n        emit AssetStateUpdated(contentAssetStorageAddress, tokenId, unfinalizedStateIndex, updateTokenAmount);\\n    }\\n\\n    function cancelAssetStateUpdate(uint256 tokenId) external onlyAssetOwner(tokenId) {\\n        ContentAssetStorage cas = contentAssetStorage;\\n        ServiceAgreementStorageProxy sasProxy = serviceAgreementStorageProxy;\\n        UnfinalizedStateStorage uss = unfinalizedStateStorage;\\n\\n        address contentAssetStorageAddress = address(cas);\\n\\n        bytes memory keyword = abi.encodePacked(contentAssetStorageAddress, cas.getAssertionIdByIndex(tokenId, 0));\\n\\n        bytes32 agreementId = hashingProxy.callHashFunction(\\n            HASH_FUNCTION_ID,\\n            abi.encodePacked(contentAssetStorageAddress, tokenId, keyword)\\n        );\\n\\n        uint256 startTime;\\n        uint16 epochsNumber;\\n        uint128 epochLength;\\n        (startTime, epochsNumber, epochLength, , ) = sasProxy.getAgreementData(agreementId);\\n\\n        if (block.timestamp > startTime + epochsNumber * epochLength) revert ContentAssetErrors.AssetExpired(tokenId);\\n\\n        bytes32 unfinalizedState = uss.getUnfinalizedState(tokenId);\\n        uint256 unfinalizedStateIndex = cas.getAssertionIdsLength(tokenId);\\n\\n        if (unfinalizedState == bytes32(0)) {\\n            revert ContentAssetErrors.NoPendingUpdate(contentAssetStorageAddress, tokenId);\\n        } else if (\\n            block.timestamp <=\\n            sasProxy.getUpdateCommitsDeadline(keccak256(abi.encodePacked(agreementId, unfinalizedStateIndex)))\\n        ) {\\n            revert ContentAssetErrors.PendingUpdateFinalization(\\n                contentAssetStorageAddress,\\n                tokenId,\\n                unfinalizedStateIndex\\n            );\\n        }\\n\\n        uint96 updateTokenAmount = sasProxy.getAgreementUpdateTokenAmount(agreementId);\\n        sasProxy.setAgreementUpdateTokenAmount(agreementId, 0);\\n        sasProxy.transferV1U1AgreementTokens(msg.sender, updateTokenAmount);\\n\\n        uss.deleteIssuer(tokenId);\\n        uss.deleteUnfinalizedState(tokenId);\\n\\n        emit AssetStateUpdateCanceled(\\n            contentAssetStorageAddress,\\n            tokenId,\\n            cas.getAssertionIdsLength(tokenId),\\n            updateTokenAmount\\n        );\\n    }\\n\\n    function extendAssetStoringPeriod(\\n        uint256 tokenId,\\n        uint16 epochsNumber,\\n        uint96 tokenAmount\\n    ) external onlyAssetOwner(tokenId) {\\n        ContentAssetStorage cas = contentAssetStorage;\\n        ServiceAgreementV1 sasV1 = serviceAgreementV1;\\n\\n        address contentAssetStorageAddress = address(cas);\\n\\n        bytes32 unfinalizedState = unfinalizedStateStorage.getUnfinalizedState(tokenId);\\n\\n        if (unfinalizedState != bytes32(0))\\n            revert ContentAssetErrors.UpdateIsNotFinalized(contentAssetStorageAddress, tokenId, unfinalizedState);\\n\\n        bytes memory keyword = abi.encodePacked(contentAssetStorageAddress, cas.getAssertionIdByIndex(tokenId, 0));\\n\\n        bytes32 agreementId = hashingProxy.callHashFunction(\\n            HASH_FUNCTION_ID,\\n            abi.encodePacked(contentAssetStorageAddress, tokenId, keyword)\\n        );\\n\\n        uint256 startTime;\\n        uint16 oldEpochsNumber;\\n        uint128 epochLength;\\n        (startTime, oldEpochsNumber, epochLength, , ) = serviceAgreementStorageProxy.getAgreementData(agreementId);\\n\\n        if (block.timestamp > startTime + oldEpochsNumber * epochLength) {\\n            revert ContentAssetErrors.AssetExpired(tokenId);\\n        }\\n\\n        sasV1.extendStoringPeriod(msg.sender, agreementId, epochsNumber, tokenAmount);\\n\\n        emit AssetStoringPeriodExtended(contentAssetStorageAddress, tokenId, epochsNumber, tokenAmount);\\n    }\\n\\n    function increaseAssetTokenAmount(uint256 tokenId, uint96 tokenAmount) external onlyAssetOwner(tokenId) {\\n        ContentAssetStorage cas = contentAssetStorage;\\n        ServiceAgreementV1 sasV1 = serviceAgreementV1;\\n\\n        address contentAssetStorageAddress = address(cas);\\n\\n        bytes32 unfinalizedState = unfinalizedStateStorage.getUnfinalizedState(tokenId);\\n\\n        if (unfinalizedState != bytes32(0))\\n            revert ContentAssetErrors.UpdateIsNotFinalized(contentAssetStorageAddress, tokenId, unfinalizedState);\\n\\n        bytes memory keyword = abi.encodePacked(contentAssetStorageAddress, cas.getAssertionIdByIndex(tokenId, 0));\\n\\n        bytes32 agreementId = hashingProxy.callHashFunction(\\n            HASH_FUNCTION_ID,\\n            abi.encodePacked(contentAssetStorageAddress, tokenId, keyword)\\n        );\\n\\n        uint256 startTime;\\n        uint16 epochsNumber;\\n        uint128 epochLength;\\n        (startTime, epochsNumber, epochLength, , ) = serviceAgreementStorageProxy.getAgreementData(agreementId);\\n\\n        if (block.timestamp > startTime + epochsNumber * epochLength) revert ContentAssetErrors.AssetExpired(tokenId);\\n\\n        sasV1.addTokens(msg.sender, agreementId, tokenAmount);\\n\\n        emit AssetPaymentIncreased(contentAssetStorageAddress, tokenId, tokenAmount);\\n    }\\n\\n    function increaseAssetUpdateTokenAmount(uint256 tokenId, uint96 tokenAmount) external onlyAssetOwner(tokenId) {\\n        ContentAssetStorage cas = contentAssetStorage;\\n        ServiceAgreementV1 sasV1 = serviceAgreementV1;\\n\\n        address contentAssetStorageAddress = address(cas);\\n\\n        bytes32 unfinalizedState = unfinalizedStateStorage.getUnfinalizedState(tokenId);\\n\\n        if (unfinalizedState == bytes32(0))\\n            revert ContentAssetErrors.NoPendingUpdate(contentAssetStorageAddress, tokenId);\\n\\n        bytes memory keyword = abi.encodePacked(contentAssetStorageAddress, cas.getAssertionIdByIndex(tokenId, 0));\\n\\n        bytes32 agreementId = hashingProxy.callHashFunction(\\n            HASH_FUNCTION_ID,\\n            abi.encodePacked(contentAssetStorageAddress, tokenId, keyword)\\n        );\\n\\n        uint256 startTime;\\n        uint16 epochsNumber;\\n        uint128 epochLength;\\n        (startTime, epochsNumber, epochLength, , ) = serviceAgreementStorageProxy.getAgreementData(agreementId);\\n\\n        if (block.timestamp > startTime + epochsNumber * epochLength) revert ContentAssetErrors.AssetExpired(tokenId);\\n\\n        sasV1.addUpdateTokens(msg.sender, agreementId, tokenAmount);\\n\\n        emit AssetUpdatePaymentIncreased(contentAssetStorageAddress, tokenId, tokenAmount);\\n    }\\n\\n    function _createAsset(\\n        bytes32 assertionId,\\n        uint128 size,\\n        uint32 triplesNumber,\\n        uint96 chunksNumber,\\n        uint16 epochsNumber,\\n        uint96 tokenAmount,\\n        uint8 scoreFunctionId,\\n        bool immutable_\\n    ) internal virtual {\\n        ContentAssetStorage cas = contentAssetStorage;\\n\\n        uint256 tokenId = cas.generateTokenId();\\n        cas.mint(msg.sender, tokenId);\\n\\n        assertionContract.createAssertion(assertionId, size, triplesNumber, chunksNumber);\\n        cas.setAssertionIssuer(tokenId, assertionId, msg.sender);\\n        cas.setMutability(tokenId, immutable_);\\n        cas.pushAssertionId(tokenId, assertionId);\\n\\n        address contentAssetStorageAddress = address(cas);\\n\\n        serviceAgreementV1.createServiceAgreement(\\n            ServiceAgreementStructsV1.ServiceAgreementInputArgs({\\n                assetCreator: msg.sender,\\n                assetContract: contentAssetStorageAddress,\\n                tokenId: tokenId,\\n                keyword: abi.encodePacked(contentAssetStorageAddress, assertionId),\\n                hashFunctionId: HASH_FUNCTION_ID,\\n                epochsNumber: epochsNumber,\\n                tokenAmount: tokenAmount,\\n                scoreFunctionId: scoreFunctionId\\n            })\\n        );\\n\\n        emit AssetMinted(contentAssetStorageAddress, tokenId, assertionId);\\n    }\\n\\n    function _checkAssetOwner(uint256 tokenId) internal view virtual {\\n        require(msg.sender == contentAssetStorage.ownerOf(tokenId), \\\"Only asset owner can use this fn\\\");\\n    }\\n\\n    function _checkMutability(uint256 tokenId) internal view virtual {\\n        require(contentAssetStorage.isMutable(tokenId), \\\"Asset is immutable\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x4a48d8c186a6f423e4e5eaf21211a9bd29bc5e55106ddc869845913f55653dbc\",\"license\":\"MIT\"},\"contracts/constants/IdentityConstants.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nuint256 constant ADMIN_KEY = 1;\\nuint256 constant OPERATIONAL_KEY = 2;\\nuint256 constant ECDSA = 1;\\nuint256 constant RSA = 2;\\n\",\"keccak256\":\"0x29659af4aa4e72f889ceee74029f11aac7d40b5a3f6d3f55323863be1a2a587c\",\"license\":\"MIT\"},\"contracts/constants/ShardingTableConstants.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nuint72 constant NULL = 0;\\n\",\"keccak256\":\"0xe80366170c622c9277da5d2bfbe7883b4b2e9d77c8f9407a3ce964c99ab24aa7\",\"license\":\"MIT\"},\"contracts/constants/assets/ContentAssetConstants.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nuint8 constant HASH_FUNCTION_ID = 1; // SHA256\\n\",\"keccak256\":\"0xac5589d2f229ae638bf00bea4b01566b468a50082653a2528ca31294cf48fc9f\",\"license\":\"MIT\"},\"contracts/errors/GeneralErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nlibrary GeneralErrors {\\n    error OnlyHubOwnerFunction(address caller);\\n    error OnlyHubContractsFunction(address caller);\\n}\\n\",\"keccak256\":\"0x8b4676f9bcab2615efa6de8c4dd9a6b56a51388dd3dc4f3cab46b2951f3d53eb\",\"license\":\"MIT\"},\"contracts/errors/ServiceAgreementErrorsV1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nlibrary ServiceAgreementErrorsV1 {\\n    error ServiceAgreementDoesntExist(bytes32 agreementId);\\n    error EmptyAssetCreatorAddress();\\n    error AssetStorageNotInTheHub(address contractAddress);\\n    error EmptyKeyword();\\n    error ZeroEpochsNumber();\\n    error ZeroTokenAmount();\\n    error ScoreFunctionDoesntExist(uint8 scoreFunctionId);\\n    error TooLowAllowance(uint256 amount);\\n    error TooLowBalance(uint256 amount);\\n    error ServiceAgreementHasBeenExpired(\\n        bytes32 agreementId,\\n        uint256 startTime,\\n        uint16 epochsNumber,\\n        uint128 epochLength\\n    );\\n    error CommitWindowClosed(\\n        bytes32 agreementId,\\n        uint16 epoch,\\n        uint256 commitWindowOpen,\\n        uint256 commitWindowClose,\\n        uint256 timeNow\\n    );\\n    error NodeNotInShardingTable(uint72 identityId, bytes nodeId, uint96 ask, uint96 stake);\\n    error ProofWindowClosed(\\n        bytes32 agreementId,\\n        uint16 epoch,\\n        uint256 proofWindowOpen,\\n        uint256 proofWindowClose,\\n        uint256 timeNow\\n    );\\n    error NodeAlreadyRewarded(bytes32 agreementId, uint16 epoch, uint72 identityId, bytes nodeId);\\n    error NodeNotAwarded(bytes32 agreementId, uint16 epoch, uint72 identityId, bytes nodeId, uint8 rank);\\n    error WrongMerkleProof(\\n        bytes32 agreementId,\\n        uint16 epoch,\\n        uint72 identityId,\\n        bytes nodeId,\\n        bytes32[] merkleProof,\\n        bytes32 merkleRoot,\\n        bytes32 chunkHash,\\n        uint256 challenge\\n    );\\n    error NodeAlreadySubmittedCommit(bytes32 agreementId, uint16 epoch, uint72 identityId, bytes nodeId);\\n}\\n\",\"keccak256\":\"0xe22b0062d14df083c65c6f8da9d6ed591fc428940096b2fddbf3d94a9966ca09\",\"license\":\"MIT\"},\"contracts/errors/ServiceAgreementErrorsV1U1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nlibrary ServiceAgreementErrorsV1U1 {\\n    error ServiceAgreementDoesntExist(bytes32 agreementId);\\n    error EmptyAssetCreatorAddress();\\n    error AssetStorageNotInTheHub(address contractAddress);\\n    error EmptyKeyword();\\n    error ZeroEpochsNumber();\\n    error ZeroTokenAmount();\\n    error ScoreFunctionDoesntExist(uint8 scoreFunctionId);\\n    error HashFunctionDoesntExist(uint8 hashFunctionId);\\n    error TooLowAllowance(uint256 amount);\\n    error TooLowBalance(uint256 amount);\\n    error ServiceAgreementHasBeenExpired(\\n        bytes32 agreementId,\\n        uint256 startTime,\\n        uint16 epochsNumber,\\n        uint128 epochLength\\n    );\\n    error CommitWindowClosed(\\n        bytes32 agreementId,\\n        uint16 epoch,\\n        uint256 stateIndex,\\n        uint256 commitWindowOpen,\\n        uint256 commitWindowClose,\\n        uint256 timeNow\\n    );\\n    error NodeNotInShardingTable(uint72 identityId, bytes nodeId, uint96 ask, uint96 stake);\\n    error ProofWindowClosed(\\n        bytes32 agreementId,\\n        uint16 epoch,\\n        uint256 stateIndex,\\n        uint256 proofWindowOpen,\\n        uint256 proofWindowClose,\\n        uint256 timeNow\\n    );\\n    error NodeAlreadyRewarded(bytes32 agreementId, uint16 epoch, uint256 stateIndex, uint72 identityId, bytes nodeId);\\n    error NodeNotAwarded(\\n        bytes32 agreementId,\\n        uint16 epoch,\\n        uint256 stateIndex,\\n        uint72 identityId,\\n        bytes nodeId,\\n        uint8 rank\\n    );\\n    error WrongMerkleProof(\\n        bytes32 agreementId,\\n        uint16 epoch,\\n        uint256 stateIndex,\\n        uint72 identityId,\\n        bytes nodeId,\\n        bytes32[] merkleProof,\\n        bytes32 merkleRoot,\\n        bytes32 chunkHash,\\n        uint256 challenge\\n    );\\n    error NodeAlreadySubmittedCommit(\\n        bytes32 agreementId,\\n        uint16 epoch,\\n        uint256 stateIndex,\\n        uint72 identityId,\\n        bytes nodeId\\n    );\\n    error NoPendingUpdate(address assetStorage, uint256 tokenId);\\n}\\n\",\"keccak256\":\"0xa12c3a2af6ee9118b2172c7412e2d33890332772cb8588c0e4cbc8d08add0a53\",\"license\":\"MIT\"},\"contracts/errors/assets/ContentAssetErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nlibrary ContentAssetErrors {\\n    error AssetDoesntExist(uint256 tokenId);\\n    error AssetExpired(uint256 tokenId);\\n    error CommitPhaseOngoing(bytes32 agreementId);\\n    error CommitPhaseSucceeded(bytes32 agreementId);\\n    error FirstEpochHasAlreadyEnded(bytes32 agreementId);\\n    error NoPendingUpdate(address assetStorage, uint256 tokenId);\\n    error UpdateIsNotFinalized(address assetStorage, uint256 tokenId, bytes32 latestState);\\n    error PendingUpdateFinalization(address assetStorage, uint256 tokenId, uint256 latestStateIndex);\\n}\\n\",\"keccak256\":\"0xc79bcd0071e145d7053ff478d32535eda0f53a795a3060dad36263a9293aeb33\",\"license\":\"MIT\"},\"contracts/interface/ICustodian.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\ninterface ICustodian {\\n    function getOwners() external view returns (address[] memory);\\n}\\n\",\"keccak256\":\"0xf9c1575729c595ec1c4c6cec71e0890774efda80299b476b3c243b4fd168c69d\",\"license\":\"MIT\"},\"contracts/interface/IERC734Extended.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\ninterface IERC734Extended {\\n    event KeyAdded(uint72 indexed identityId, bytes32 indexed key, uint256 purpose, uint256 keyType);\\n    event KeyRemoved(uint72 indexed identityId, bytes32 indexed key, uint256 purpose, uint256 keyType);\\n\\n    struct Key {\\n        uint256 purpose; //e.g., ADMIN_KEY = 1, OPERATIONAL_KEY = 2, etc.\\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\\n        bytes32 key;\\n    }\\n\\n    function addKey(uint72 identityId, bytes32 _key, uint256 _purpose, uint256 _keyType) external;\\n\\n    function removeKey(uint72 identityId, bytes32 _key) external;\\n\\n    function keyHasPurpose(uint72 identityId, bytes32 _key, uint256 _purpose) external view returns (bool exists);\\n\\n    function getKey(\\n        uint72 identityId,\\n        bytes32 _key\\n    ) external view returns (uint256 purpose, uint256 keyType, bytes32 key);\\n\\n    function getKeysByPurpose(uint72 identityId, uint256 _purpose) external view returns (bytes32[] memory keys);\\n}\\n\",\"keccak256\":\"0xf96ebcda84c7f83dc1f91f97caf955724ef10c6f243a68f346e2715cc8700a88\",\"license\":\"MIT\"},\"contracts/interface/IHashFunction.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\ninterface IHashFunction {\\n    function hash(bytes calldata data) external pure returns (bytes32);\\n}\\n\",\"keccak256\":\"0x2fca3d77fdcb26c5026f75259e19b326354d5c759775838fd070b49a766c75bd\",\"license\":\"MIT\"},\"contracts/interface/IScoreFunction.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\ninterface IScoreFunction {\\n    function calculateScore(uint256 distance, uint96 stake) external view returns (uint40);\\n\\n    function calculateDistance(\\n        uint8 hashFunctionId,\\n        bytes calldata nodeId,\\n        bytes calldata keyword\\n    ) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x28e494c1d81aeaba8d3c96035a07e56139a991a741a9165d4f55f400b4d71d31\",\"license\":\"MIT\"},\"contracts/interface/Indexable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\ninterface Indexable {\\n    function id() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0xa5142e26633487e63c7448e3419186e24b97353b5d5c0b5b2886c2d15884cd9d\",\"license\":\"MIT\"},\"contracts/interface/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\ninterface Initializable {\\n    function initialize() external;\\n}\\n\",\"keccak256\":\"0xac823de4540de0fac2d1ec548a5083404ab8abd858c34a69f4f8947b24789507\",\"license\":\"MIT\"},\"contracts/interface/Named.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\ninterface Named {\\n    function name() external view returns (string memory);\\n}\\n\",\"keccak256\":\"0xb468c85b178d2377c1a6dd77f2e4f843fe280932663ffef8d9fba56dcdc7b796\",\"license\":\"MIT\"},\"contracts/interface/Versioned.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\ninterface Versioned {\\n    function version() external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x6012f1a5c6b2fe5d8457ab1b913602c6f2d40dbea225bb4cec9fe3e325209f90\",\"license\":\"MIT\"},\"contracts/storage/AssertionStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport {HubDependent} from \\\"../abstract/HubDependent.sol\\\";\\nimport {Named} from \\\"../interface/Named.sol\\\";\\nimport {Versioned} from \\\"../interface/Versioned.sol\\\";\\nimport {AssertionStructs} from \\\"../structs/AssertionStructs.sol\\\";\\n\\ncontract AssertionStorage is Named, Versioned, HubDependent {\\n    string private constant _NAME = \\\"AssertionStorage\\\";\\n    string private constant _VERSION = \\\"1.0.0\\\";\\n\\n    // assertionId => Assertion\\n    mapping(bytes32 => AssertionStructs.Assertion) internal assertions;\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(address hubAddress) HubDependent(hubAddress) {}\\n\\n    function name() external pure virtual override returns (string memory) {\\n        return _NAME;\\n    }\\n\\n    function version() external pure virtual override returns (string memory) {\\n        return _VERSION;\\n    }\\n\\n    function createAssertion(\\n        bytes32 assertionId,\\n        uint128 size,\\n        uint32 triplesNumber,\\n        uint96 chunksNumber\\n    ) external onlyContracts {\\n        assertions[assertionId] = AssertionStructs.Assertion({\\n            timestamp: block.timestamp,\\n            size: size,\\n            triplesNumber: triplesNumber,\\n            chunksNumber: chunksNumber\\n        });\\n    }\\n\\n    function deleteAssertion(bytes32 assertionId) external onlyContracts {\\n        delete assertions[assertionId];\\n    }\\n\\n    function getAssertion(bytes32 assertionId) external view returns (AssertionStructs.Assertion memory) {\\n        return assertions[assertionId];\\n    }\\n\\n    function getAssertionTimestamp(bytes32 assertionId) external view returns (uint256) {\\n        return assertions[assertionId].timestamp;\\n    }\\n\\n    function getAssertionSize(bytes32 assertionId) external view returns (uint128) {\\n        return assertions[assertionId].size;\\n    }\\n\\n    function getAssertionTriplesNumber(bytes32 assertionId) external view returns (uint32) {\\n        return assertions[assertionId].triplesNumber;\\n    }\\n\\n    function getAssertionChunksNumber(bytes32 assertionId) external view returns (uint96) {\\n        return assertions[assertionId].chunksNumber;\\n    }\\n\\n    function assertionExists(bytes32 assertionId) external view returns (bool) {\\n        return assertions[assertionId].timestamp != 0;\\n    }\\n}\\n\",\"keccak256\":\"0xf523695eba20ece14bab74fc2581e01d7b9f02220c3d0577fc5f4eafeb4eeb88\",\"license\":\"MIT\"},\"contracts/storage/IdentityStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport {HubDependent} from \\\"../abstract/HubDependent.sol\\\";\\nimport {IERC734Extended} from \\\"../interface/IERC734Extended.sol\\\";\\nimport {Named} from \\\"../interface/Named.sol\\\";\\nimport {Versioned} from \\\"../interface/Versioned.sol\\\";\\nimport {ByteArr} from \\\"../utils/ByteArr.sol\\\";\\nimport {OPERATIONAL_KEY} from \\\"../constants/IdentityConstants.sol\\\";\\n\\ncontract IdentityStorage is IERC734Extended, Named, Versioned, HubDependent {\\n    using ByteArr for bytes32[];\\n\\n    string private constant _NAME = \\\"IdentityStorage\\\";\\n    string private constant _VERSION = \\\"1.0.0\\\";\\n\\n    uint72 private _identityId;\\n\\n    struct Identity {\\n        mapping(bytes32 => Key) keys;\\n        mapping(uint256 => bytes32[]) keysByPurpose;\\n    }\\n\\n    // operationalKey => identityId\\n    mapping(bytes32 => uint72) public identityIds;\\n    // identityId => Identity\\n    mapping(uint72 => Identity) internal identities;\\n\\n    constructor(address hubAddress) HubDependent(hubAddress) {\\n        _identityId = 1;\\n    }\\n\\n    function name() external pure virtual override returns (string memory) {\\n        return _NAME;\\n    }\\n\\n    function version() external pure virtual override returns (string memory) {\\n        return _VERSION;\\n    }\\n\\n    function deleteIdentity(uint72 identityId) external onlyContracts {\\n        bytes32[] memory operationalKeys = identities[identityId].keysByPurpose[OPERATIONAL_KEY];\\n        uint256 operationalKeysNumber = operationalKeys.length;\\n\\n        for (uint256 i; i < operationalKeysNumber; ) {\\n            delete identityIds[operationalKeys[i]];\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        delete identities[identityId];\\n    }\\n\\n    function addKey(uint72 identityId, bytes32 _key, uint256 _purpose, uint256 _type) external override onlyContracts {\\n        Identity storage identity = identities[identityId];\\n        identity.keys[_key].purpose = _purpose;\\n        identity.keys[_key].keyType = _type;\\n        identity.keys[_key].key = _key;\\n        identity.keysByPurpose[_purpose].push(_key);\\n\\n        emit KeyAdded(identityId, _key, _purpose, _type);\\n    }\\n\\n    function removeKey(uint72 identityId, bytes32 _key) external override onlyContracts {\\n        Identity storage identity = identities[identityId];\\n\\n        uint256 index;\\n        (index, ) = identity.keysByPurpose[identity.keys[_key].purpose].indexOf(_key);\\n        identity.keysByPurpose[identity.keys[_key].purpose].removeByIndex(index);\\n\\n        delete identity.keys[_key];\\n\\n        emit KeyRemoved(identityId, identity.keys[_key].key, identity.keys[_key].purpose, identity.keys[_key].keyType);\\n    }\\n\\n    function keyHasPurpose(uint72 identityId, bytes32 _key, uint256 _purpose) external view override returns (bool) {\\n        return identities[identityId].keys[_key].purpose == _purpose;\\n    }\\n\\n    function getKey(uint72 identityId, bytes32 _key) external view override returns (uint256, uint256, bytes32) {\\n        return (\\n            identities[identityId].keys[_key].purpose,\\n            identities[identityId].keys[_key].keyType,\\n            identities[identityId].keys[_key].key\\n        );\\n    }\\n\\n    function getKeysByPurpose(uint72 identityId, uint256 _purpose) external view override returns (bytes32[] memory) {\\n        return identities[identityId].keysByPurpose[_purpose];\\n    }\\n\\n    function getIdentityId(address operational) external view returns (uint72) {\\n        return identityIds[keccak256(abi.encodePacked(operational))];\\n    }\\n\\n    function setOperationalKeyIdentityId(bytes32 operationalKey, uint72 identityId) external onlyContracts {\\n        identityIds[operationalKey] = identityId;\\n    }\\n\\n    function removeOperationalKeyIdentityId(bytes32 operationalKey) external onlyContracts {\\n        delete identityIds[operationalKey];\\n    }\\n\\n    function generateIdentityId() external onlyContracts returns (uint72) {\\n        unchecked {\\n            return _identityId++;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x50d2f7a594213a4f2b6bf35019bafbab59b6a6b7cb151680031d3c8db572a0b1\",\"license\":\"MIT\"},\"contracts/storage/ParametersStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport {HubDependent} from \\\"../abstract/HubDependent.sol\\\";\\nimport {Named} from \\\"../interface/Named.sol\\\";\\nimport {Versioned} from \\\"../interface/Versioned.sol\\\";\\n\\ncontract ParametersStorage is Named, Versioned, HubDependent {\\n    event ParameterChanged(string parameterName, uint256 parameterValue);\\n\\n    string private constant _NAME = \\\"ParametersStorage\\\";\\n    string private constant _VERSION = \\\"1.1.0\\\";\\n\\n    // 0 - minProofWindowOffsetPerc\\n    // 1 - maxProofWindowOffsetPerc\\n    // 2 - commitWindowDurationPerc\\n    // 3 - proofWindowDurationPerc\\n    // 4 - replacementWindowDurationPerc\\n    // 5 - finalizationCommitsNumber\\n    uint8[6] internal args1;\\n\\n    // 0 - r0\\n    // 1 - r1\\n    // 2 - slashingFreezeDuration\\n    uint32[3] internal args2;\\n    uint48 public r2;\\n\\n    // 0 - minimumStake\\n    // 1 - maximumStake\\n    uint96[2] internal args3;\\n\\n    uint128 public epochLength;\\n\\n    // 0 - stakeWithdrawalDelay\\n    // 1 - rewardWithdrawalDelay\\n    uint24[2] internal args4;\\n\\n    uint16 public updateCommitWindowDuration;\\n\\n    constructor(address hubAddress) HubDependent(hubAddress) {\\n        // minimumStake\\n        args3[0] = 50_000 ether;\\n        // maximumStake\\n        args3[1] = 5_000_000 ether;\\n\\n        r2 = 20;\\n        // r1\\n        args2[1] = 8;\\n        // r0\\n        args2[0] = 3;\\n\\n        // minProofWindowOffsetPerc\\n        args1[0] = 50;\\n        // maxProofWindowOffsetPerc\\n        args1[1] = 75;\\n        // commitWindowDurationPerc\\n        args1[2] = 25;\\n        // proofWindowDurationPerc\\n        args1[3] = 25;\\n        // replacementWindowDurationPerc\\n        args1[4] = 0;\\n\\n        epochLength = 90 days;\\n\\n        // stakeWithdrawalDelay\\n        args4[0] = 5 minutes;\\n        // rewardWithdrawalDelay\\n        args4[1] = 5 minutes;\\n        // slashingFreezeDuration\\n        args2[2] = 730 days;\\n\\n        updateCommitWindowDuration = 30 minutes;\\n\\n        // finalizationCommitsNumber\\n        args1[5] = 3;\\n    }\\n\\n    function name() external pure virtual override returns (string memory) {\\n        return _NAME;\\n    }\\n\\n    function version() external pure virtual override returns (string memory) {\\n        return _VERSION;\\n    }\\n\\n    function minimumStake() external view returns (uint96) {\\n        return args3[0];\\n    }\\n\\n    function setMinimumStake(uint96 newMinimumStake) external onlyHubOwner {\\n        args3[0] = newMinimumStake;\\n\\n        emit ParameterChanged(\\\"minimumStake\\\", newMinimumStake);\\n    }\\n\\n    function maximumStake() external view returns (uint96) {\\n        return args3[1];\\n    }\\n\\n    function setMaximumStake(uint96 newMaximumStake) external onlyHubOwner {\\n        args3[1] = newMaximumStake;\\n\\n        emit ParameterChanged(\\\"maximumStake\\\", newMaximumStake);\\n    }\\n\\n    function setR2(uint48 newR2) external onlyHubOwner {\\n        r2 = newR2;\\n\\n        emit ParameterChanged(\\\"r2\\\", newR2);\\n    }\\n\\n    function r1() external view returns (uint32) {\\n        return args2[1];\\n    }\\n\\n    function setR1(uint32 newR1) external onlyHubOwner {\\n        require(newR1 >= (2 * args2[0] - 1), \\\"R1 should be >= 2*R0-1\\\");\\n\\n        args2[1] = newR1;\\n\\n        emit ParameterChanged(\\\"r1\\\", newR1);\\n    }\\n\\n    function r0() external view returns (uint32) {\\n        return args2[0];\\n    }\\n\\n    function setR0(uint32 newR0) external onlyHubOwner {\\n        require(newR0 <= ((args2[1] + 1) / 2), \\\"R0 should be <= (R1+1)/2\\\");\\n\\n        args2[0] = newR0;\\n\\n        emit ParameterChanged(\\\"r0\\\", newR0);\\n    }\\n\\n    function minProofWindowOffsetPerc() external view returns (uint8) {\\n        return args1[0];\\n    }\\n\\n    function setMinProofWindowOffsetPerc(uint8 newMinProofWindowOffsetPerc) external onlyHubOwner {\\n        args1[0] = newMinProofWindowOffsetPerc;\\n\\n        emit ParameterChanged(\\\"minProofWindowOffsetPerc\\\", newMinProofWindowOffsetPerc);\\n    }\\n\\n    function maxProofWindowOffsetPerc() external view returns (uint8) {\\n        return args1[1];\\n    }\\n\\n    function setMaxProofWindowOffsetPerc(uint8 newMaxProofWindowOffsetPerc) external onlyHubOwner {\\n        args1[1] = newMaxProofWindowOffsetPerc;\\n\\n        emit ParameterChanged(\\\"maxProofWindowOffsetPerc\\\", newMaxProofWindowOffsetPerc);\\n    }\\n\\n    function commitWindowDurationPerc() external view returns (uint8) {\\n        return args1[2];\\n    }\\n\\n    function setCommitWindowDurationPerc(uint8 newCommitWindowDurationPerc) external onlyHubOwner {\\n        args1[2] = newCommitWindowDurationPerc;\\n\\n        emit ParameterChanged(\\\"commitWindowDurationPerc\\\", newCommitWindowDurationPerc);\\n    }\\n\\n    function proofWindowDurationPerc() external view returns (uint8) {\\n        return args1[3];\\n    }\\n\\n    function setProofWindowDurationPerc(uint8 newProofWindowDurationPerc) external onlyHubOwner {\\n        args1[3] = newProofWindowDurationPerc;\\n\\n        emit ParameterChanged(\\\"proofWindowDurationPerc\\\", newProofWindowDurationPerc);\\n    }\\n\\n    function replacementWindowDurationPerc() external view returns (uint8) {\\n        return args1[4];\\n    }\\n\\n    function setReplacementWindowDurationPerc(uint8 newReplacementWindowDurationPerc) external onlyHubOwner {\\n        args1[4] = newReplacementWindowDurationPerc;\\n\\n        emit ParameterChanged(\\\"replacementWindowDurationPerc\\\", newReplacementWindowDurationPerc);\\n    }\\n\\n    function setEpochLength(uint128 newEpochLength) external onlyHubOwner {\\n        epochLength = newEpochLength;\\n\\n        emit ParameterChanged(\\\"epochLength\\\", newEpochLength);\\n    }\\n\\n    function stakeWithdrawalDelay() external view returns (uint24) {\\n        return args4[0];\\n    }\\n\\n    function setStakeWithdrawalDelay(uint24 newStakeWithdrawalDelay) external onlyHubOwner {\\n        args4[0] = newStakeWithdrawalDelay;\\n\\n        emit ParameterChanged(\\\"stakeWithdrawalDelay\\\", newStakeWithdrawalDelay);\\n    }\\n\\n    function rewardWithdrawalDelay() external view returns (uint24) {\\n        return args4[1];\\n    }\\n\\n    function setRewardWithdrawalDelay(uint24 newRewardWithdrawalDelay) external onlyHubOwner {\\n        args4[1] = newRewardWithdrawalDelay;\\n\\n        emit ParameterChanged(\\\"rewardWithdrawalDelay\\\", newRewardWithdrawalDelay);\\n    }\\n\\n    function slashingFreezeDuration() external view returns (uint32) {\\n        return args2[2];\\n    }\\n\\n    function setSlashingFreezeDuration(uint32 newSlashingFreezeDuration) external onlyHubOwner {\\n        args2[2] = newSlashingFreezeDuration;\\n\\n        emit ParameterChanged(\\\"slashingFreezeDuration\\\", newSlashingFreezeDuration);\\n    }\\n\\n    function setUpdateCommitWindowDuration(uint16 newUpdateCommitWindowDuration) external onlyHubOwner {\\n        updateCommitWindowDuration = newUpdateCommitWindowDuration;\\n\\n        emit ParameterChanged(\\\"updateCommitWindowDuration\\\", newUpdateCommitWindowDuration);\\n    }\\n\\n    function finalizationCommitsNumber() external view returns (uint8) {\\n        return args1[5];\\n    }\\n\\n    function setFinalizationCommitsNumber(uint8 newFinalizationCommitsNumber) external onlyHubOwner {\\n        args1[5] = newFinalizationCommitsNumber;\\n\\n        emit ParameterChanged(\\\"finalizationCommitsNumber\\\", newFinalizationCommitsNumber);\\n    }\\n}\\n\",\"keccak256\":\"0xcf85cdc898aa106de1841fc603229d8a8985c1bed128e8efd3c2e827b9c0cca1\",\"license\":\"MIT\"},\"contracts/storage/ProfileStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport {Guardian} from \\\"../Guardian.sol\\\";\\nimport {Shares} from \\\"../Shares.sol\\\";\\nimport {Named} from \\\"../interface/Named.sol\\\";\\nimport {Versioned} from \\\"../interface/Versioned.sol\\\";\\n\\ncontract ProfileStorage is Named, Versioned, Guardian {\\n    string private constant _NAME = \\\"ProfileStorage\\\";\\n    string private constant _VERSION = \\\"1.0.0\\\";\\n\\n    struct ProfileDefinition {\\n        bytes nodeId;\\n        uint96 ask;\\n        uint96 accumulatedOperatorFee;\\n        uint96 accumulatedOperatorFeeWithdrawalAmount;\\n        uint256 operatorFeeWithdrawalTimestamp;\\n        address sharesContractAddress;\\n        mapping(uint8 => bytes32) nodeAddresses;\\n    }\\n\\n    // nodeId => isRegistered?\\n    mapping(bytes => bool) public nodeIdsList;\\n    // identityId => Profile\\n    mapping(uint72 => ProfileDefinition) internal profiles;\\n\\n    // shares token name => isTaken?\\n    mapping(string => bool) public sharesNames;\\n    // shares token ID => isTaken?\\n    mapping(string => bool) public sharesSymbols;\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(address hubAddress) Guardian(hubAddress) {}\\n\\n    function name() external pure virtual override returns (string memory) {\\n        return _NAME;\\n    }\\n\\n    function version() external pure virtual override returns (string memory) {\\n        return _VERSION;\\n    }\\n\\n    function createProfile(\\n        uint72 identityId,\\n        bytes calldata nodeId,\\n        address sharesContractAddress\\n    ) external onlyContracts {\\n        ProfileDefinition storage profile = profiles[identityId];\\n        profile.nodeId = nodeId;\\n        profile.sharesContractAddress = sharesContractAddress;\\n\\n        nodeIdsList[nodeId] = true;\\n\\n        Shares sharesContract = Shares(sharesContractAddress);\\n        sharesNames[sharesContract.name()] = true;\\n        sharesSymbols[sharesContract.symbol()] = true;\\n    }\\n\\n    function getProfile(\\n        uint72 identityId\\n    ) external view returns (bytes memory nodeId, uint96[2] memory profileSettings, address sharesContractAddress) {\\n        ProfileDefinition storage profile = profiles[identityId];\\n        return (profile.nodeId, [profile.ask, profile.accumulatedOperatorFee], profile.sharesContractAddress);\\n    }\\n\\n    function deleteProfile(uint72 identityId) external onlyContracts {\\n        nodeIdsList[profiles[identityId].nodeId] = false;\\n        delete profiles[identityId];\\n    }\\n\\n    function getNodeId(uint72 identityId) external view returns (bytes memory) {\\n        return profiles[identityId].nodeId;\\n    }\\n\\n    function setNodeId(uint72 identityId, bytes calldata nodeId) external onlyContracts {\\n        ProfileDefinition storage profile = profiles[identityId];\\n\\n        nodeIdsList[profile.nodeId] = false;\\n        profile.nodeId = nodeId;\\n        nodeIdsList[nodeId] = true;\\n    }\\n\\n    function getAsk(uint72 identityId) external view returns (uint96) {\\n        return profiles[identityId].ask;\\n    }\\n\\n    function setAsk(uint72 identityId, uint96 ask) external onlyContracts {\\n        profiles[identityId].ask = ask;\\n    }\\n\\n    function getAccumulatedOperatorFee(uint72 identityId) external view returns (uint96) {\\n        return profiles[identityId].accumulatedOperatorFee;\\n    }\\n\\n    function setAccumulatedOperatorFee(uint72 identityId, uint96 newOperatorFeeAmount) external onlyContracts {\\n        profiles[identityId].accumulatedOperatorFee = newOperatorFeeAmount;\\n    }\\n\\n    function getAccumulatedOperatorFeeWithdrawalAmount(uint72 identityId) external view returns (uint96) {\\n        return profiles[identityId].accumulatedOperatorFeeWithdrawalAmount;\\n    }\\n\\n    function setAccumulatedOperatorFeeWithdrawalAmount(\\n        uint72 identityId,\\n        uint96 accumulatedOperatorFeeWithdrawalAmount\\n    ) external onlyContracts {\\n        profiles[identityId].accumulatedOperatorFeeWithdrawalAmount = accumulatedOperatorFeeWithdrawalAmount;\\n    }\\n\\n    function getAccumulatedOperatorFeeWithdrawalTimestamp(uint72 identityId) external view returns (uint256) {\\n        return profiles[identityId].operatorFeeWithdrawalTimestamp;\\n    }\\n\\n    function setAccumulatedOperatorFeeWithdrawalTimestamp(\\n        uint72 identityId,\\n        uint256 operatorFeeWithdrawalTimestamp\\n    ) external onlyContracts {\\n        profiles[identityId].operatorFeeWithdrawalTimestamp = operatorFeeWithdrawalTimestamp;\\n    }\\n\\n    function getSharesContractAddress(uint72 identityId) external view returns (address) {\\n        return profiles[identityId].sharesContractAddress;\\n    }\\n\\n    function setSharesContractAddress(uint72 identityId, address sharesContractAddress) external onlyContracts {\\n        profiles[identityId].sharesContractAddress = sharesContractAddress;\\n    }\\n\\n    function getNodeAddress(uint72 identityId, uint8 hashFunctionId) external view returns (bytes32) {\\n        return profiles[identityId].nodeAddresses[hashFunctionId];\\n    }\\n\\n    function setNodeAddress(uint72 identityId, uint8 hashFunctionId, bytes32 nodeAddress) external onlyContracts {\\n        profiles[identityId].nodeAddresses[hashFunctionId] = nodeAddress;\\n    }\\n\\n    function profileExists(uint72 identityId) external view returns (bool) {\\n        return keccak256(profiles[identityId].nodeId) != keccak256(bytes(\\\"\\\"));\\n    }\\n\\n    function transferAccumulatedOperatorFee(address receiver, uint96 amount) external onlyContracts {\\n        tokenContract.transfer(receiver, amount);\\n    }\\n}\\n\",\"keccak256\":\"0x658280fecb28870447d89924e8114b8847a3107b674ca5c27d402499b1921332\",\"license\":\"MIT\"},\"contracts/storage/ServiceAgreementStorageProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport {ServiceAgreementStorageV1} from \\\"./ServiceAgreementStorageV1.sol\\\";\\nimport {ServiceAgreementStorageV1U1} from \\\"./ServiceAgreementStorageV1U1.sol\\\";\\nimport {ServiceAgreementStructsV1} from \\\"../structs/ServiceAgreementStructsV1.sol\\\";\\nimport {HubDependent} from \\\"../abstract/HubDependent.sol\\\";\\nimport {Initializable} from \\\"../interface/Initializable.sol\\\";\\nimport {Named} from \\\"../interface/Named.sol\\\";\\nimport {Versioned} from \\\"../interface/Versioned.sol\\\";\\nimport {GeneralErrors} from \\\"../errors/GeneralErrors.sol\\\";\\n\\ncontract ServiceAgreementStorageProxy is Named, Versioned, HubDependent, Initializable {\\n    string private constant _NAME = \\\"ServiceAgreementStorageProxy\\\";\\n    string private constant _VERSION = \\\"1.0.0\\\";\\n\\n    ServiceAgreementStorageV1 public storageV1;\\n    ServiceAgreementStorageV1U1 public storageV1U1;\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(address hubAddress) HubDependent(hubAddress) {}\\n\\n    function initialize() public onlyHubOwner {\\n        storageV1 = ServiceAgreementStorageV1(hub.getContractAddress(\\\"ServiceAgreementStorageV1\\\"));\\n        storageV1U1 = ServiceAgreementStorageV1U1(hub.getContractAddress(\\\"ServiceAgreementStorageV1U1\\\"));\\n    }\\n\\n    function name() external pure virtual override returns (string memory) {\\n        return _NAME;\\n    }\\n\\n    function version() external pure virtual override returns (string memory) {\\n        return _VERSION;\\n    }\\n\\n    function migrateV1ServiceAgreement(bytes32 agreementId) external onlyContracts {\\n        ServiceAgreementStorageV1 sasV1 = storageV1;\\n        ServiceAgreementStorageV1U1 sasV1U1 = storageV1U1;\\n\\n        uint96 tokenAmount = sasV1.getAgreementTokenAmount(agreementId);\\n\\n        sasV1.deleteServiceAgreementObject(agreementId);\\n\\n        sasV1U1.setAgreementTokenAmount(agreementId, tokenAmount);\\n        sasV1.transferAgreementTokens(address(sasV1U1), tokenAmount);\\n    }\\n\\n    function createV1U1ServiceAgreementObject(\\n        bytes32 agreementId,\\n        uint256 startTime,\\n        uint16 epochsNumber,\\n        uint128 epochLength,\\n        uint96 tokenAmount,\\n        uint8 scoreFunctionId,\\n        uint8 proofWindowOffsetPerc\\n    ) external onlyContracts {\\n        storageV1U1.createServiceAgreementObject(\\n            agreementId,\\n            startTime,\\n            epochsNumber,\\n            epochLength,\\n            tokenAmount,\\n            scoreFunctionId,\\n            proofWindowOffsetPerc\\n        );\\n    }\\n\\n    function createV1ServiceAgreementObject(\\n        bytes32 agreementId,\\n        uint16 epochsNumber,\\n        uint128 epochLength,\\n        uint96 tokenAmount,\\n        uint8 scoreFunctionId,\\n        uint8 proofWindowOffsetPerc\\n    ) external onlyContracts {\\n        storageV1.createServiceAgreementObject(\\n            agreementId,\\n            epochsNumber,\\n            epochLength,\\n            tokenAmount,\\n            scoreFunctionId,\\n            proofWindowOffsetPerc\\n        );\\n    }\\n\\n    function deleteServiceAgreementObject(bytes32 agreementId) external onlyContracts {\\n        if (this.agreementV1Exists(agreementId)) {\\n            storageV1.deleteServiceAgreementObject(agreementId);\\n        } else {\\n            storageV1U1.deleteServiceAgreementObject(agreementId);\\n        }\\n    }\\n\\n    function getAgreementData(\\n        bytes32 agreementId\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 startTime,\\n            uint16 epochsNumber,\\n            uint128 epochLength,\\n            uint96[2] memory tokens,\\n            uint8[2] memory scoreFunctionIdAndProofWindowOffsetPerc\\n        )\\n    {\\n        if (this.agreementV1Exists(agreementId)) {\\n            uint96 tokenAmount;\\n            (startTime, epochsNumber, epochLength, tokenAmount, scoreFunctionIdAndProofWindowOffsetPerc) = storageV1\\n                .getAgreementData(agreementId);\\n            return (\\n                startTime,\\n                epochsNumber,\\n                epochLength,\\n                [tokenAmount, storageV1U1.getAgreementUpdateTokenAmount(agreementId)],\\n                scoreFunctionIdAndProofWindowOffsetPerc\\n            );\\n        } else {\\n            return storageV1U1.getAgreementData(agreementId);\\n        }\\n    }\\n\\n    function getAgreementStartTime(bytes32 agreementId) external view returns (uint256) {\\n        if (this.agreementV1Exists(agreementId)) {\\n            return storageV1.getAgreementStartTime(agreementId);\\n        } else {\\n            return storageV1U1.getAgreementStartTime(agreementId);\\n        }\\n    }\\n\\n    function setAgreementStartTime(bytes32 agreementId, uint256 startTime) external onlyContracts {\\n        if (this.agreementV1Exists(agreementId)) {\\n            storageV1.setAgreementStartTime(agreementId, startTime);\\n        } else {\\n            storageV1U1.setAgreementStartTime(agreementId, startTime);\\n        }\\n    }\\n\\n    function getAgreementEpochsNumber(bytes32 agreementId) external view returns (uint16) {\\n        if (this.agreementV1Exists(agreementId)) {\\n            return storageV1.getAgreementEpochsNumber(agreementId);\\n        } else {\\n            return storageV1U1.getAgreementEpochsNumber(agreementId);\\n        }\\n    }\\n\\n    function setAgreementEpochsNumber(bytes32 agreementId, uint16 epochsNumber) external onlyContracts {\\n        if (this.agreementV1Exists(agreementId)) {\\n            storageV1.setAgreementEpochsNumber(agreementId, epochsNumber);\\n        } else {\\n            storageV1U1.setAgreementEpochsNumber(agreementId, epochsNumber);\\n        }\\n    }\\n\\n    function getAgreementEpochLength(bytes32 agreementId) external view returns (uint128) {\\n        if (this.agreementV1Exists(agreementId)) {\\n            return storageV1.getAgreementEpochLength(agreementId);\\n        } else {\\n            return storageV1U1.getAgreementEpochLength(agreementId);\\n        }\\n    }\\n\\n    function setAgreementEpochLength(bytes32 agreementId, uint128 epochLength) external onlyContracts {\\n        if (this.agreementV1Exists(agreementId)) {\\n            storageV1.setAgreementEpochLength(agreementId, epochLength);\\n        } else {\\n            storageV1U1.setAgreementEpochLength(agreementId, epochLength);\\n        }\\n    }\\n\\n    function getAgreementTokenAmount(bytes32 agreementId) external view returns (uint96) {\\n        if (this.agreementV1Exists(agreementId)) {\\n            return storageV1.getAgreementTokenAmount(agreementId);\\n        } else {\\n            return storageV1U1.getAgreementTokenAmount(agreementId);\\n        }\\n    }\\n\\n    function setAgreementTokenAmount(bytes32 agreementId, uint96 tokenAmount) external onlyContracts {\\n        if (this.agreementV1Exists(agreementId)) {\\n            storageV1.setAgreementTokenAmount(agreementId, tokenAmount);\\n        } else {\\n            storageV1U1.setAgreementTokenAmount(agreementId, tokenAmount);\\n        }\\n    }\\n\\n    function getAgreementUpdateTokenAmount(bytes32 agreementId) external view returns (uint96) {\\n        return storageV1U1.getAgreementUpdateTokenAmount(agreementId);\\n    }\\n\\n    function setAgreementUpdateTokenAmount(bytes32 agreementId, uint96 updateTokenAmount) external onlyContracts {\\n        storageV1U1.setAgreementUpdateTokenAmount(agreementId, updateTokenAmount);\\n    }\\n\\n    function getAgreementScoreFunctionId(bytes32 agreementId) external view returns (uint8) {\\n        if (this.agreementV1Exists(agreementId)) {\\n            return storageV1.getAgreementScoreFunctionId(agreementId);\\n        } else {\\n            return storageV1U1.getAgreementScoreFunctionId(agreementId);\\n        }\\n    }\\n\\n    function setAgreementScoreFunctionId(bytes32 agreementId, uint8 newScoreFunctionId) external onlyContracts {\\n        if (this.agreementV1Exists(agreementId)) {\\n            storageV1.setAgreementScoreFunctionId(agreementId, newScoreFunctionId);\\n        } else {\\n            storageV1U1.setAgreementScoreFunctionId(agreementId, newScoreFunctionId);\\n        }\\n    }\\n\\n    function getAgreementProofWindowOffsetPerc(bytes32 agreementId) external view returns (uint8) {\\n        if (this.agreementV1Exists(agreementId)) {\\n            return storageV1.getAgreementProofWindowOffsetPerc(agreementId);\\n        } else {\\n            return storageV1U1.getAgreementProofWindowOffsetPerc(agreementId);\\n        }\\n    }\\n\\n    function setAgreementProofWindowOffsetPerc(\\n        bytes32 agreementId,\\n        uint8 proofWindowOffsetPerc\\n    ) external onlyContracts {\\n        if (this.agreementV1Exists(agreementId)) {\\n            storageV1.setAgreementProofWindowOffsetPerc(agreementId, proofWindowOffsetPerc);\\n        } else {\\n            storageV1U1.setAgreementProofWindowOffsetPerc(agreementId, proofWindowOffsetPerc);\\n        }\\n    }\\n\\n    function getV1U1AgreementEpochSubmissionHead(\\n        bytes32 agreementId,\\n        uint16 epoch,\\n        uint256 stateIndex\\n    ) external view returns (bytes32) {\\n        return storageV1U1.getAgreementEpochSubmissionHead(agreementId, epoch, stateIndex);\\n    }\\n\\n    function getV1AgreementEpochSubmissionHead(bytes32 agreementId, uint16 epoch) external view returns (bytes32) {\\n        return storageV1.getAgreementEpochSubmissionHead(agreementId, epoch);\\n    }\\n\\n    function setV1U1AgreementEpochSubmissionHead(\\n        bytes32 agreementId,\\n        uint16 epoch,\\n        uint256 stateIndex,\\n        bytes32 headCommitId\\n    ) external onlyContracts {\\n        storageV1U1.setAgreementEpochSubmissionHead(agreementId, epoch, stateIndex, headCommitId);\\n    }\\n\\n    function setV1AgreementEpochSubmissionHead(\\n        bytes32 agreementId,\\n        uint16 epoch,\\n        bytes32 headCommitId\\n    ) external onlyContracts {\\n        storageV1.setAgreementEpochSubmissionHead(agreementId, epoch, headCommitId);\\n    }\\n\\n    function incrementAgreementRewardedNodesNumber(bytes32 agreementId, uint16 epoch) external onlyContracts {\\n        if (this.agreementV1Exists(agreementId)) {\\n            storageV1.incrementAgreementRewardedNodesNumber(agreementId, epoch);\\n        } else {\\n            storageV1U1.incrementAgreementRewardedNodesNumber(agreementId, epoch);\\n        }\\n    }\\n\\n    function decrementAgreementRewardedNodesNumber(bytes32 agreementId, uint16 epoch) external onlyContracts {\\n        if (this.agreementV1Exists(agreementId)) {\\n            storageV1.decrementAgreementRewardedNodesNumber(agreementId, epoch);\\n        } else {\\n            storageV1U1.decrementAgreementRewardedNodesNumber(agreementId, epoch);\\n        }\\n    }\\n\\n    function getAgreementRewardedNodesNumber(bytes32 agreementId, uint16 epoch) external view returns (uint32) {\\n        if (this.agreementV1Exists(agreementId)) {\\n            return storageV1.getAgreementRewardedNodesNumber(agreementId, epoch);\\n        } else {\\n            return storageV1U1.getAgreementRewardedNodesNumber(agreementId, epoch);\\n        }\\n    }\\n\\n    function setAgreementRewardedNodesNumber(\\n        bytes32 agreementId,\\n        uint16 epoch,\\n        uint32 rewardedNodesNumber\\n    ) external onlyContracts {\\n        if (this.agreementV1Exists(agreementId)) {\\n            storageV1.setAgreementRewardedNodesNumber(agreementId, epoch, rewardedNodesNumber);\\n        } else {\\n            storageV1U1.setAgreementRewardedNodesNumber(agreementId, epoch, rewardedNodesNumber);\\n        }\\n    }\\n\\n    function deleteAgreementRewardedNodesNumber(bytes32 agreementId, uint16 epoch) external onlyContracts {\\n        if (this.agreementV1Exists(agreementId)) {\\n            storageV1.setAgreementRewardedNodesNumber(agreementId, epoch, 0);\\n        } else {\\n            storageV1U1.deleteAgreementRewardedNodesNumber(agreementId, epoch);\\n        }\\n    }\\n\\n    function createV1CommitSubmissionObject(\\n        bytes32 commitId,\\n        uint72 identityId,\\n        uint72 prevIdentityId,\\n        uint72 nextIdentityId,\\n        uint40 score\\n    ) external onlyContracts {\\n        storageV1.createCommitSubmissionObject(commitId, identityId, prevIdentityId, nextIdentityId, score);\\n    }\\n\\n    function createV1U1CommitSubmissionObject(\\n        bytes32 commitId,\\n        uint72 identityId,\\n        uint72 prevIdentityId,\\n        uint72 nextIdentityId,\\n        uint40 score\\n    ) external onlyContracts {\\n        storageV1U1.createEpochStateCommitSubmissionObject(commitId, identityId, prevIdentityId, nextIdentityId, score);\\n    }\\n\\n    function deleteCommitSubmissionsObject(bytes32 commitId) external onlyContracts {\\n        if (this.commitV1U1Exists(commitId)) {\\n            storageV1U1.deleteEpochStateCommitSubmissionsObject(commitId);\\n        } else {\\n            storageV1.deleteCommitSubmissionsObject(commitId);\\n        }\\n    }\\n\\n    function getCommitSubmission(\\n        bytes32 commitId\\n    ) external view returns (ServiceAgreementStructsV1.CommitSubmission memory) {\\n        if (this.commitV1U1Exists(commitId)) {\\n            return storageV1U1.getEpochStateCommitSubmission(commitId);\\n        } else {\\n            return storageV1.getCommitSubmission(commitId);\\n        }\\n    }\\n\\n    function getCommitSubmissionIdentityId(bytes32 commitId) external view returns (uint72) {\\n        if (this.commitV1U1Exists(commitId)) {\\n            return storageV1U1.getEpochStateCommitSubmissionIdentityId(commitId);\\n        } else {\\n            return storageV1.getCommitSubmissionIdentityId(commitId);\\n        }\\n    }\\n\\n    function setCommitSubmissionIdentityId(bytes32 commitId, uint72 identityId) external onlyContracts {\\n        if (this.commitV1U1Exists(commitId)) {\\n            storageV1U1.setEpochStateCommitSubmissionIdentityId(commitId, identityId);\\n        } else {\\n            storageV1.setCommitSubmissionIdentityId(commitId, identityId);\\n        }\\n    }\\n\\n    function getCommitSubmissionPrevIdentityId(bytes32 commitId) external view returns (uint72) {\\n        if (this.commitV1U1Exists(commitId)) {\\n            return storageV1U1.getEpochStateCommitSubmissionPrevIdentityId(commitId);\\n        } else {\\n            return storageV1.getCommitSubmissionPrevIdentityId(commitId);\\n        }\\n    }\\n\\n    function setCommitSubmissionPrevIdentityId(bytes32 commitId, uint72 prevIdentityId) external onlyContracts {\\n        if (this.commitV1U1Exists(commitId)) {\\n            storageV1U1.setEpochStateCommitSubmissionPrevIdentityId(commitId, prevIdentityId);\\n        } else {\\n            storageV1.setCommitSubmissionPrevIdentityId(commitId, prevIdentityId);\\n        }\\n    }\\n\\n    function getCommitSubmissionNextIdentityId(bytes32 commitId) external view returns (uint72) {\\n        if (this.commitV1U1Exists(commitId)) {\\n            return storageV1U1.getEpochStateCommitSubmissionNextIdentityId(commitId);\\n        } else {\\n            return storageV1.getCommitSubmissionNextIdentityId(commitId);\\n        }\\n    }\\n\\n    function setCommitSubmissionNextIdentityId(bytes32 commitId, uint72 nextIdentityId) external onlyContracts {\\n        if (this.commitV1U1Exists(commitId)) {\\n            storageV1U1.setEpochStateCommitSubmissionNextIdentityId(commitId, nextIdentityId);\\n        } else {\\n            storageV1.setCommitSubmissionNextIdentityId(commitId, nextIdentityId);\\n        }\\n    }\\n\\n    function getCommitSubmissionScore(bytes32 commitId) external view returns (uint40) {\\n        if (this.commitV1U1Exists(commitId)) {\\n            return storageV1U1.getEpochStateCommitSubmissionScore(commitId);\\n        } else {\\n            return storageV1.getCommitSubmissionScore(commitId);\\n        }\\n    }\\n\\n    function setCommitSubmissionScore(bytes32 commitId, uint40 score) external onlyContracts {\\n        if (this.commitV1U1Exists(commitId)) {\\n            storageV1U1.setEpochStateCommitSubmissionScore(commitId, score);\\n        } else {\\n            storageV1.setCommitSubmissionScore(commitId, score);\\n        }\\n    }\\n\\n    function commitSubmissionExists(bytes32 commitId) external view returns (bool) {\\n        if (this.commitV1U1Exists(commitId)) {\\n            return storageV1U1.epochStateCommitSubmissionExists(commitId);\\n        } else {\\n            return storageV1.commitSubmissionExists(commitId);\\n        }\\n    }\\n\\n    function incrementCommitsCount(bytes32 epochStateId) external onlyContracts {\\n        storageV1U1.incrementEpochStateCommitsCount(epochStateId);\\n    }\\n\\n    function decrementCommitsCount(bytes32 epochStateId) external onlyContracts {\\n        storageV1U1.decrementEpochStateCommitsCount(epochStateId);\\n    }\\n\\n    function getCommitsCount(bytes32 epochStateId) external view returns (uint8) {\\n        return storageV1U1.getEpochStateCommitsCount(epochStateId);\\n    }\\n\\n    function setCommitsCount(bytes32 epochStateId, uint8 epochStateCommitsCount) external onlyContracts {\\n        storageV1U1.setEpochStateCommitsCount(epochStateId, epochStateCommitsCount);\\n    }\\n\\n    function deleteCommitsCount(bytes32 epochStateId) external onlyContracts {\\n        storageV1U1.deleteEpochStateCommitsCount(epochStateId);\\n    }\\n\\n    function getUpdateCommitsDeadline(bytes32 stateId) external view returns (uint256) {\\n        return storageV1U1.getUpdateCommitsDeadline(stateId);\\n    }\\n\\n    function setUpdateCommitsDeadline(bytes32 stateId, uint256 deadline) external onlyContracts {\\n        storageV1U1.setUpdateCommitsDeadline(stateId, deadline);\\n    }\\n\\n    function deleteUpdateCommitsDeadline(bytes32 stateId) external onlyContracts {\\n        storageV1U1.deleteUpdateCommitsDeadline(stateId);\\n    }\\n\\n    function transferAgreementTokens(bytes32 agreementId, address receiver, uint96 tokenAmount) external onlyContracts {\\n        if (this.agreementV1Exists(agreementId)) {\\n            storageV1.transferAgreementTokens(receiver, tokenAmount);\\n        } else {\\n            storageV1U1.transferAgreementTokens(receiver, tokenAmount);\\n        }\\n    }\\n\\n    function transferV1AgreementTokens(address receiver, uint96 tokenAmount) external onlyContracts {\\n        storageV1.transferAgreementTokens(receiver, tokenAmount);\\n    }\\n\\n    function transferV1U1AgreementTokens(address receiver, uint96 tokenAmount) external onlyContracts {\\n        storageV1U1.transferAgreementTokens(receiver, tokenAmount);\\n    }\\n\\n    function agreementV1Exists(bytes32 agreementId) external view returns (bool) {\\n        return storageV1.serviceAgreementExists(agreementId);\\n    }\\n\\n    function agreementV1U1Exists(bytes32 agreementId) external view returns (bool) {\\n        return storageV1U1.serviceAgreementExists(agreementId);\\n    }\\n\\n    function serviceAgreementExists(bytes32 agreementId) external view returns (bool) {\\n        return storageV1.serviceAgreementExists(agreementId) || storageV1U1.serviceAgreementExists(agreementId);\\n    }\\n\\n    function commitV1Exists(bytes32 commitId) external view returns (bool) {\\n        return storageV1.commitSubmissionExists(commitId);\\n    }\\n\\n    function commitV1U1Exists(bytes32 commitId) external view returns (bool) {\\n        return storageV1U1.epochStateCommitSubmissionExists(commitId);\\n    }\\n\\n    function agreementV1StorageAddress() external view returns (address) {\\n        return address(storageV1);\\n    }\\n\\n    function agreementV1U1StorageAddress() external view returns (address) {\\n        return address(storageV1U1);\\n    }\\n}\\n\",\"keccak256\":\"0x3615c48f64deb12c57692b15a052d523c3da362dd3c927ec3f2902a7c5307a06\",\"license\":\"MIT\"},\"contracts/storage/ServiceAgreementStorageV1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport {Guardian} from \\\"../Guardian.sol\\\";\\nimport {Named} from \\\"../interface/Named.sol\\\";\\nimport {Versioned} from \\\"../interface/Versioned.sol\\\";\\nimport {ServiceAgreementStructsV1} from \\\"../structs/ServiceAgreementStructsV1.sol\\\";\\n\\ncontract ServiceAgreementStorageV1 is Named, Versioned, Guardian {\\n    string private constant _NAME = \\\"ServiceAgreementStorageV1\\\";\\n    string private constant _VERSION = \\\"1.0.0\\\";\\n\\n    // CommitId [keccak256(agreementId + epoch + identityId)] => CommitSubmission\\n    mapping(bytes32 => ServiceAgreementStructsV1.CommitSubmission) internal commitSubmissions;\\n\\n    // AgreementId [hash(asset type contract + tokenId + key)] => ServiceAgreement\\n    mapping(bytes32 => ServiceAgreementStructsV1.ServiceAgreement) internal serviceAgreements;\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(address hubAddress) Guardian(hubAddress) {}\\n\\n    function name() external pure virtual override returns (string memory) {\\n        return _NAME;\\n    }\\n\\n    function version() external pure virtual override returns (string memory) {\\n        return _VERSION;\\n    }\\n\\n    function createServiceAgreementObject(\\n        bytes32 agreementId,\\n        uint16 epochsNumber,\\n        uint128 epochLength,\\n        uint96 tokenAmount,\\n        uint8 scoreFunctionId,\\n        uint8 proofWindowOffsetPerc\\n    ) external onlyContracts {\\n        ServiceAgreementStructsV1.ServiceAgreement storage agreement = serviceAgreements[agreementId];\\n        agreement.startTime = block.timestamp;\\n        agreement.epochsNumber = epochsNumber;\\n        agreement.epochLength = epochLength;\\n        agreement.tokenAmount = tokenAmount;\\n        agreement.scoreFunctionId = scoreFunctionId;\\n        agreement.proofWindowOffsetPerc = proofWindowOffsetPerc;\\n    }\\n\\n    function deleteServiceAgreementObject(bytes32 agreementId) external onlyContracts {\\n        delete serviceAgreements[agreementId];\\n    }\\n\\n    function getAgreementData(\\n        bytes32 agreementId\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 startTime,\\n            uint16 epochsNumber,\\n            uint128 epochLength,\\n            uint96 tokenAmount,\\n            uint8[2] memory scoreFunctionIdAndProofWindowOffsetPerc\\n        )\\n    {\\n        return (\\n            serviceAgreements[agreementId].startTime,\\n            serviceAgreements[agreementId].epochsNumber,\\n            serviceAgreements[agreementId].epochLength,\\n            serviceAgreements[agreementId].tokenAmount,\\n            [serviceAgreements[agreementId].scoreFunctionId, serviceAgreements[agreementId].proofWindowOffsetPerc]\\n        );\\n    }\\n\\n    function getAgreementStartTime(bytes32 agreementId) external view returns (uint256) {\\n        return serviceAgreements[agreementId].startTime;\\n    }\\n\\n    function setAgreementStartTime(bytes32 agreementId, uint256 startTime) external onlyContracts {\\n        serviceAgreements[agreementId].startTime = startTime;\\n    }\\n\\n    function getAgreementEpochsNumber(bytes32 agreementId) external view returns (uint16) {\\n        return serviceAgreements[agreementId].epochsNumber;\\n    }\\n\\n    function setAgreementEpochsNumber(bytes32 agreementId, uint16 epochsNumber) external onlyContracts {\\n        serviceAgreements[agreementId].epochsNumber = epochsNumber;\\n    }\\n\\n    function getAgreementEpochLength(bytes32 agreementId) external view returns (uint128) {\\n        return serviceAgreements[agreementId].epochLength;\\n    }\\n\\n    function setAgreementEpochLength(bytes32 agreementId, uint128 epochLength) external onlyContracts {\\n        serviceAgreements[agreementId].epochLength = epochLength;\\n    }\\n\\n    function getAgreementTokenAmount(bytes32 agreementId) external view returns (uint96) {\\n        return serviceAgreements[agreementId].tokenAmount;\\n    }\\n\\n    function setAgreementTokenAmount(bytes32 agreementId, uint96 tokenAmount) external onlyContracts {\\n        serviceAgreements[agreementId].tokenAmount = tokenAmount;\\n    }\\n\\n    function getAgreementScoreFunctionId(bytes32 agreementId) external view returns (uint8) {\\n        return serviceAgreements[agreementId].scoreFunctionId;\\n    }\\n\\n    function setAgreementScoreFunctionId(bytes32 agreementId, uint8 newScoreFunctionId) external onlyContracts {\\n        serviceAgreements[agreementId].scoreFunctionId = newScoreFunctionId;\\n    }\\n\\n    function getAgreementProofWindowOffsetPerc(bytes32 agreementId) external view returns (uint8) {\\n        return serviceAgreements[agreementId].proofWindowOffsetPerc;\\n    }\\n\\n    function setAgreementProofWindowOffsetPerc(\\n        bytes32 agreementId,\\n        uint8 proofWindowOffsetPerc\\n    ) external onlyContracts {\\n        serviceAgreements[agreementId].proofWindowOffsetPerc = proofWindowOffsetPerc;\\n    }\\n\\n    function getAgreementEpochSubmissionHead(bytes32 agreementId, uint16 epoch) external view returns (bytes32) {\\n        return serviceAgreements[agreementId].epochSubmissionHeads[epoch];\\n    }\\n\\n    function setAgreementEpochSubmissionHead(\\n        bytes32 agreementId,\\n        uint16 epoch,\\n        bytes32 headCommitId\\n    ) external onlyContracts {\\n        serviceAgreements[agreementId].epochSubmissionHeads[epoch] = headCommitId;\\n    }\\n\\n    function incrementAgreementRewardedNodesNumber(bytes32 agreementId, uint16 epoch) external onlyContracts {\\n        serviceAgreements[agreementId].rewardedNodesNumber[epoch]++;\\n    }\\n\\n    function decrementAgreementRewardedNodesNumber(bytes32 agreementId, uint16 epoch) external onlyContracts {\\n        serviceAgreements[agreementId].rewardedNodesNumber[epoch]--;\\n    }\\n\\n    function getAgreementRewardedNodesNumber(bytes32 agreementId, uint16 epoch) external view returns (uint32) {\\n        return serviceAgreements[agreementId].rewardedNodesNumber[epoch];\\n    }\\n\\n    function setAgreementRewardedNodesNumber(\\n        bytes32 agreementId,\\n        uint16 epoch,\\n        uint32 rewardedNodesNumber\\n    ) external onlyContracts {\\n        serviceAgreements[agreementId].rewardedNodesNumber[epoch] = rewardedNodesNumber;\\n    }\\n\\n    function serviceAgreementExists(bytes32 agreementId) external view returns (bool) {\\n        return serviceAgreements[agreementId].startTime != 0;\\n    }\\n\\n    function createCommitSubmissionObject(\\n        bytes32 commitId,\\n        uint72 identityId,\\n        uint72 prevIdentityId,\\n        uint72 nextIdentityId,\\n        uint40 score\\n    ) external onlyContracts {\\n        commitSubmissions[commitId] = ServiceAgreementStructsV1.CommitSubmission({\\n            identityId: identityId,\\n            prevIdentityId: prevIdentityId,\\n            nextIdentityId: nextIdentityId,\\n            score: score\\n        });\\n    }\\n\\n    function deleteCommitSubmissionsObject(bytes32 commitId) external onlyContracts {\\n        delete commitSubmissions[commitId];\\n    }\\n\\n    function getCommitSubmission(\\n        bytes32 commitId\\n    ) external view returns (ServiceAgreementStructsV1.CommitSubmission memory) {\\n        return commitSubmissions[commitId];\\n    }\\n\\n    function getCommitSubmissionIdentityId(bytes32 commitId) external view returns (uint72) {\\n        return commitSubmissions[commitId].identityId;\\n    }\\n\\n    function setCommitSubmissionIdentityId(bytes32 commitId, uint72 identityId) external onlyContracts {\\n        commitSubmissions[commitId].identityId = identityId;\\n    }\\n\\n    function getCommitSubmissionPrevIdentityId(bytes32 commitId) external view returns (uint72) {\\n        return commitSubmissions[commitId].prevIdentityId;\\n    }\\n\\n    function setCommitSubmissionPrevIdentityId(bytes32 commitId, uint72 prevIdentityId) external onlyContracts {\\n        commitSubmissions[commitId].prevIdentityId = prevIdentityId;\\n    }\\n\\n    function getCommitSubmissionNextIdentityId(bytes32 commitId) external view returns (uint72) {\\n        return commitSubmissions[commitId].nextIdentityId;\\n    }\\n\\n    function setCommitSubmissionNextIdentityId(bytes32 commitId, uint72 nextIdentityId) external onlyContracts {\\n        commitSubmissions[commitId].nextIdentityId = nextIdentityId;\\n    }\\n\\n    function getCommitSubmissionScore(bytes32 commitId) external view returns (uint40) {\\n        return commitSubmissions[commitId].score;\\n    }\\n\\n    function setCommitSubmissionScore(bytes32 commitId, uint40 score) external onlyContracts {\\n        commitSubmissions[commitId].score = score;\\n    }\\n\\n    function commitSubmissionExists(bytes32 commitId) external view returns (bool) {\\n        return commitSubmissions[commitId].identityId != 0;\\n    }\\n\\n    function transferAgreementTokens(address receiver, uint96 tokenAmount) external onlyContracts {\\n        tokenContract.transfer(receiver, tokenAmount);\\n    }\\n}\\n\",\"keccak256\":\"0x8c2b2d43615369d9fe71beb9d4267ea40c46fb416d4c7b22ab81272a2c690117\",\"license\":\"MIT\"},\"contracts/storage/ServiceAgreementStorageV1U1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport {Guardian} from \\\"../Guardian.sol\\\";\\nimport {Named} from \\\"../interface/Named.sol\\\";\\nimport {Versioned} from \\\"../interface/Versioned.sol\\\";\\nimport {ServiceAgreementStructsV1} from \\\"../structs/ServiceAgreementStructsV1.sol\\\";\\n\\ncontract ServiceAgreementStorageV1U1 is Named, Versioned, Guardian {\\n    string private constant _NAME = \\\"ServiceAgreementStorageV1U1\\\";\\n    string private constant _VERSION = \\\"1.0.0\\\";\\n\\n    // AgreementId [hash(assetStorage + tokenId + key)] => ExtendedServiceAgreement\\n    mapping(bytes32 => ServiceAgreementStructsV1.ExtendedServiceAgreement) internal serviceAgreements;\\n\\n    // CommitId [keccak256(agreementId + epoch + stateIndex + identityId)] => stateCommitSubmission\\n    mapping(bytes32 => ServiceAgreementStructsV1.CommitSubmission) internal epochStateCommitSubmissions;\\n\\n    // EpochStateId [keccak256(agreementId + epoch + stateIndex)] => epochStateCommitsCount\\n    mapping(bytes32 => uint8) internal epochStateCommitsCount;\\n\\n    // StateId [keccak256(agreementId + stateIndex)] => updateCommitsDeadline\\n    mapping(bytes32 => uint256) internal updateCommitsDeadlines;\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(address hubAddress) Guardian(hubAddress) {}\\n\\n    function name() external pure virtual override returns (string memory) {\\n        return _NAME;\\n    }\\n\\n    function version() external pure virtual override returns (string memory) {\\n        return _VERSION;\\n    }\\n\\n    function createServiceAgreementObject(\\n        bytes32 agreementId,\\n        uint256 startTime,\\n        uint16 epochsNumber,\\n        uint128 epochLength,\\n        uint96 tokenAmount,\\n        uint8 scoreFunctionId,\\n        uint8 proofWindowOffsetPerc\\n    ) external onlyContracts {\\n        ServiceAgreementStructsV1.ExtendedServiceAgreement storage agreement = serviceAgreements[agreementId];\\n        agreement.startTime = startTime;\\n        agreement.epochsNumber = epochsNumber;\\n        agreement.epochLength = epochLength;\\n        agreement.tokenAmount = tokenAmount;\\n        agreement.scoreFunctionId = scoreFunctionId;\\n        agreement.proofWindowOffsetPerc = proofWindowOffsetPerc;\\n    }\\n\\n    function deleteServiceAgreementObject(bytes32 agreementId) external onlyContracts {\\n        delete serviceAgreements[agreementId];\\n    }\\n\\n    function getAgreementData(\\n        bytes32 agreementId\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 startTime,\\n            uint16 epochsNumber,\\n            uint128 epochLength,\\n            uint96[2] memory tokens,\\n            uint8[2] memory scoreFunctionIdAndProofWindowOffsetPerc\\n        )\\n    {\\n        return (\\n            serviceAgreements[agreementId].startTime,\\n            serviceAgreements[agreementId].epochsNumber,\\n            serviceAgreements[agreementId].epochLength,\\n            [serviceAgreements[agreementId].tokenAmount, serviceAgreements[agreementId].updateTokenAmount],\\n            [serviceAgreements[agreementId].scoreFunctionId, serviceAgreements[agreementId].proofWindowOffsetPerc]\\n        );\\n    }\\n\\n    function getAgreementStartTime(bytes32 agreementId) external view returns (uint256) {\\n        return serviceAgreements[agreementId].startTime;\\n    }\\n\\n    function setAgreementStartTime(bytes32 agreementId, uint256 startTime) external onlyContracts {\\n        serviceAgreements[agreementId].startTime = startTime;\\n    }\\n\\n    function getAgreementEpochsNumber(bytes32 agreementId) external view returns (uint16) {\\n        return serviceAgreements[agreementId].epochsNumber;\\n    }\\n\\n    function setAgreementEpochsNumber(bytes32 agreementId, uint16 epochsNumber) external onlyContracts {\\n        serviceAgreements[agreementId].epochsNumber = epochsNumber;\\n    }\\n\\n    function getAgreementEpochLength(bytes32 agreementId) external view returns (uint128) {\\n        return serviceAgreements[agreementId].epochLength;\\n    }\\n\\n    function setAgreementEpochLength(bytes32 agreementId, uint128 epochLength) external onlyContracts {\\n        serviceAgreements[agreementId].epochLength = epochLength;\\n    }\\n\\n    function getAgreementTokenAmount(bytes32 agreementId) external view returns (uint96) {\\n        return serviceAgreements[agreementId].tokenAmount;\\n    }\\n\\n    function setAgreementTokenAmount(bytes32 agreementId, uint96 tokenAmount) external onlyContracts {\\n        serviceAgreements[agreementId].tokenAmount = tokenAmount;\\n    }\\n\\n    function getAgreementUpdateTokenAmount(bytes32 agreementId) external view returns (uint96) {\\n        return serviceAgreements[agreementId].updateTokenAmount;\\n    }\\n\\n    function setAgreementUpdateTokenAmount(bytes32 agreementId, uint96 updateTokenAmount) external onlyContracts {\\n        serviceAgreements[agreementId].updateTokenAmount = updateTokenAmount;\\n    }\\n\\n    function getAgreementScoreFunctionId(bytes32 agreementId) external view returns (uint8) {\\n        return serviceAgreements[agreementId].scoreFunctionId;\\n    }\\n\\n    function setAgreementScoreFunctionId(bytes32 agreementId, uint8 newScoreFunctionId) external onlyContracts {\\n        serviceAgreements[agreementId].scoreFunctionId = newScoreFunctionId;\\n    }\\n\\n    function getAgreementProofWindowOffsetPerc(bytes32 agreementId) external view returns (uint8) {\\n        return serviceAgreements[agreementId].proofWindowOffsetPerc;\\n    }\\n\\n    function setAgreementProofWindowOffsetPerc(\\n        bytes32 agreementId,\\n        uint8 proofWindowOffsetPerc\\n    ) external onlyContracts {\\n        serviceAgreements[agreementId].proofWindowOffsetPerc = proofWindowOffsetPerc;\\n    }\\n\\n    function getAgreementEpochSubmissionHead(\\n        bytes32 agreementId,\\n        uint16 epoch,\\n        uint256 stateIndex\\n    ) external view returns (bytes32) {\\n        return serviceAgreements[agreementId].epochSubmissionHeads[keccak256(abi.encodePacked(epoch, stateIndex))];\\n    }\\n\\n    function setAgreementEpochSubmissionHead(\\n        bytes32 agreementId,\\n        uint16 epoch,\\n        uint256 stateIndex,\\n        bytes32 headCommitId\\n    ) external onlyContracts {\\n        serviceAgreements[agreementId].epochSubmissionHeads[\\n            keccak256(abi.encodePacked(epoch, stateIndex))\\n        ] = headCommitId;\\n    }\\n\\n    function incrementAgreementRewardedNodesNumber(bytes32 agreementId, uint16 epoch) external onlyContracts {\\n        serviceAgreements[agreementId].rewardedNodesNumber[epoch]++;\\n    }\\n\\n    function decrementAgreementRewardedNodesNumber(bytes32 agreementId, uint16 epoch) external onlyContracts {\\n        serviceAgreements[agreementId].rewardedNodesNumber[epoch]--;\\n    }\\n\\n    function getAgreementRewardedNodesNumber(bytes32 agreementId, uint16 epoch) external view returns (uint32) {\\n        return serviceAgreements[agreementId].rewardedNodesNumber[epoch];\\n    }\\n\\n    function setAgreementRewardedNodesNumber(\\n        bytes32 agreementId,\\n        uint16 epoch,\\n        uint32 rewardedNodesNumber\\n    ) external onlyContracts {\\n        serviceAgreements[agreementId].rewardedNodesNumber[epoch] = rewardedNodesNumber;\\n    }\\n\\n    function deleteAgreementRewardedNodesNumber(bytes32 agreementId, uint16 epoch) external onlyContracts {\\n        delete serviceAgreements[agreementId].rewardedNodesNumber[epoch];\\n    }\\n\\n    function serviceAgreementExists(bytes32 agreementId) external view returns (bool) {\\n        return serviceAgreements[agreementId].startTime != 0;\\n    }\\n\\n    function createEpochStateCommitSubmissionObject(\\n        bytes32 commitId,\\n        uint72 identityId,\\n        uint72 prevIdentityId,\\n        uint72 nextIdentityId,\\n        uint40 score\\n    ) external onlyContracts {\\n        epochStateCommitSubmissions[commitId] = ServiceAgreementStructsV1.CommitSubmission({\\n            identityId: identityId,\\n            prevIdentityId: prevIdentityId,\\n            nextIdentityId: nextIdentityId,\\n            score: score\\n        });\\n    }\\n\\n    function deleteEpochStateCommitSubmissionsObject(bytes32 commitId) external onlyContracts {\\n        delete epochStateCommitSubmissions[commitId];\\n    }\\n\\n    function getEpochStateCommitSubmission(\\n        bytes32 commitId\\n    ) external view returns (ServiceAgreementStructsV1.CommitSubmission memory) {\\n        return epochStateCommitSubmissions[commitId];\\n    }\\n\\n    function getEpochStateCommitSubmissionIdentityId(bytes32 commitId) external view returns (uint72) {\\n        return epochStateCommitSubmissions[commitId].identityId;\\n    }\\n\\n    function setEpochStateCommitSubmissionIdentityId(bytes32 commitId, uint72 identityId) external onlyContracts {\\n        epochStateCommitSubmissions[commitId].identityId = identityId;\\n    }\\n\\n    function getEpochStateCommitSubmissionPrevIdentityId(bytes32 commitId) external view returns (uint72) {\\n        return epochStateCommitSubmissions[commitId].prevIdentityId;\\n    }\\n\\n    function setEpochStateCommitSubmissionPrevIdentityId(\\n        bytes32 commitId,\\n        uint72 prevIdentityId\\n    ) external onlyContracts {\\n        epochStateCommitSubmissions[commitId].prevIdentityId = prevIdentityId;\\n    }\\n\\n    function getEpochStateCommitSubmissionNextIdentityId(bytes32 commitId) external view returns (uint72) {\\n        return epochStateCommitSubmissions[commitId].nextIdentityId;\\n    }\\n\\n    function setEpochStateCommitSubmissionNextIdentityId(\\n        bytes32 commitId,\\n        uint72 nextIdentityId\\n    ) external onlyContracts {\\n        epochStateCommitSubmissions[commitId].nextIdentityId = nextIdentityId;\\n    }\\n\\n    function getEpochStateCommitSubmissionScore(bytes32 commitId) external view returns (uint40) {\\n        return epochStateCommitSubmissions[commitId].score;\\n    }\\n\\n    function setEpochStateCommitSubmissionScore(bytes32 commitId, uint40 score) external onlyContracts {\\n        epochStateCommitSubmissions[commitId].score = score;\\n    }\\n\\n    function epochStateCommitSubmissionExists(bytes32 commitId) external view returns (bool) {\\n        return epochStateCommitSubmissions[commitId].identityId != 0;\\n    }\\n\\n    function incrementEpochStateCommitsCount(bytes32 epochStateId) external onlyContracts {\\n        epochStateCommitsCount[epochStateId]++;\\n    }\\n\\n    function decrementEpochStateCommitsCount(bytes32 epochStateId) external onlyContracts {\\n        epochStateCommitsCount[epochStateId]--;\\n    }\\n\\n    function getEpochStateCommitsCount(bytes32 epochStateId) external view returns (uint8) {\\n        return epochStateCommitsCount[epochStateId];\\n    }\\n\\n    function setEpochStateCommitsCount(bytes32 epochStateId, uint8 newEpochStateCommitsCount) external onlyContracts {\\n        epochStateCommitsCount[epochStateId] = newEpochStateCommitsCount;\\n    }\\n\\n    function deleteEpochStateCommitsCount(bytes32 epochStateId) external onlyContracts {\\n        delete epochStateCommitsCount[epochStateId];\\n    }\\n\\n    function getUpdateCommitsDeadline(bytes32 stateId) external view returns (uint256) {\\n        return updateCommitsDeadlines[stateId];\\n    }\\n\\n    function setUpdateCommitsDeadline(bytes32 stateId, uint256 deadline) external onlyContracts {\\n        updateCommitsDeadlines[stateId] = deadline;\\n    }\\n\\n    function deleteUpdateCommitsDeadline(bytes32 stateId) external onlyContracts {\\n        delete updateCommitsDeadlines[stateId];\\n    }\\n\\n    function transferAgreementTokens(address receiver, uint96 tokenAmount) external onlyContracts {\\n        tokenContract.transfer(receiver, tokenAmount);\\n    }\\n}\\n\",\"keccak256\":\"0xa4d25de399b6bccc3a892d0f71abd185892b50a717106fe88328a42fc1e52d98\",\"license\":\"MIT\"},\"contracts/storage/ShardingTableStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport {HubDependent} from \\\"../abstract/HubDependent.sol\\\";\\nimport {Named} from \\\"../interface/Named.sol\\\";\\nimport {Versioned} from \\\"../interface/Versioned.sol\\\";\\nimport {ShardingTableStructs} from \\\"../structs/ShardingTableStructs.sol\\\";\\nimport {NULL} from \\\"../constants/ShardingTableConstants.sol\\\";\\n\\ncontract ShardingTableStorage is Named, Versioned, HubDependent {\\n    string private constant _NAME = \\\"ShardingTableStorage\\\";\\n    string private constant _VERSION = \\\"1.0.0\\\";\\n\\n    uint72 public head;\\n    uint72 public tail;\\n    uint72 public nodesCount;\\n\\n    // identityId => Node\\n    mapping(uint72 => ShardingTableStructs.Node) internal nodes;\\n\\n    constructor(address hubAddress) HubDependent(hubAddress) {\\n        head = NULL;\\n        tail = NULL;\\n    }\\n\\n    function name() external pure virtual override returns (string memory) {\\n        return _NAME;\\n    }\\n\\n    function version() external pure virtual override returns (string memory) {\\n        return _VERSION;\\n    }\\n\\n    function incrementNodesCount() external onlyContracts {\\n        nodesCount++;\\n    }\\n\\n    function decrementNodesCount() external onlyContracts {\\n        nodesCount--;\\n    }\\n\\n    function setHead(uint72 identityId) external onlyContracts {\\n        head = identityId;\\n    }\\n\\n    function setTail(uint72 identityId) external onlyContracts {\\n        tail = identityId;\\n    }\\n\\n    function createNodeObject(uint72 identityId, uint72 prevIdentityId, uint72 nextIdentityId) external onlyContracts {\\n        nodes[identityId] = ShardingTableStructs.Node({\\n            identityId: identityId,\\n            prevIdentityId: prevIdentityId,\\n            nextIdentityId: nextIdentityId\\n        });\\n    }\\n\\n    function getNode(uint72 identityId) external view returns (ShardingTableStructs.Node memory) {\\n        return nodes[identityId];\\n    }\\n\\n    function deleteNodeObject(uint72 identityId) external onlyContracts {\\n        delete nodes[identityId];\\n    }\\n\\n    function nodeExists(uint72 identityId) external view returns (bool) {\\n        return nodes[identityId].identityId != 0;\\n    }\\n\\n    function setPrevIdentityId(uint72 identityId, uint72 newPrevIdentityId) external onlyContracts {\\n        nodes[identityId].prevIdentityId = newPrevIdentityId;\\n    }\\n\\n    function setNextIdentityId(uint72 identityId, uint72 newNextIdentityId) external onlyContracts {\\n        nodes[identityId].nextIdentityId = newNextIdentityId;\\n    }\\n\\n    function getMultipleNodes(\\n        uint72 firstIdentityId,\\n        uint16 nodesNumber\\n    ) external view returns (ShardingTableStructs.Node[] memory) {\\n        ShardingTableStructs.Node[] memory nodesPage = new ShardingTableStructs.Node[](nodesNumber);\\n\\n        ShardingTableStructs.Node memory currentNode = nodes[firstIdentityId];\\n        for (uint256 i; i < nodesNumber; ) {\\n            nodesPage[i] = currentNode;\\n            currentNode = nodes[currentNode.nextIdentityId];\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        return nodesPage;\\n    }\\n\\n    function link(uint72 leftNodeIdentityId, uint72 rightNodeIdentityId) external onlyContracts {\\n        nodes[leftNodeIdentityId].nextIdentityId = rightNodeIdentityId;\\n        nodes[rightNodeIdentityId].prevIdentityId = leftNodeIdentityId;\\n    }\\n}\\n\",\"keccak256\":\"0xac72b874995c1c6d181539ef17b90b5165f242076235e4c05282f2bd0311f3cf\",\"license\":\"MIT\"},\"contracts/storage/StakingStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport {Guardian} from \\\"../Guardian.sol\\\";\\nimport {Named} from \\\"../interface/Named.sol\\\";\\nimport {Versioned} from \\\"../interface/Versioned.sol\\\";\\n\\ncontract StakingStorage is Named, Versioned, Guardian {\\n    string private constant _NAME = \\\"StakingStorage\\\";\\n    string private constant _VERSION = \\\"1.0.0\\\";\\n\\n    struct WithdrawalRequest {\\n        uint96 amount;\\n        uint256 timestamp;\\n    }\\n\\n    // identityId => totalStake\\n    mapping(uint72 => uint96) public totalStakes;\\n\\n    // identityId => operatorFee\\n    mapping(uint72 => uint96) public operatorFees;\\n\\n    // identityId => withdrawalRequest\\n    mapping(uint72 => mapping(address => WithdrawalRequest)) public withdrawalRequests;\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(address hubAddress) Guardian(hubAddress) {}\\n\\n    function name() external pure virtual override returns (string memory) {\\n        return _NAME;\\n    }\\n\\n    function version() external pure virtual override returns (string memory) {\\n        return _VERSION;\\n    }\\n\\n    function setTotalStake(uint72 identityId, uint96 newTotalStake) external onlyContracts {\\n        totalStakes[identityId] = newTotalStake;\\n    }\\n\\n    function setOperatorFee(uint72 identityId, uint96 operatorFee) external onlyContracts {\\n        operatorFees[identityId] = operatorFee;\\n    }\\n\\n    function createWithdrawalRequest(\\n        uint72 identityId,\\n        address staker,\\n        uint96 amount,\\n        uint256 timestamp\\n    ) external onlyContracts {\\n        withdrawalRequests[identityId][staker] = WithdrawalRequest({amount: amount, timestamp: timestamp});\\n    }\\n\\n    function deleteWithdrawalRequest(uint72 identityId, address staker) external onlyContracts {\\n        delete withdrawalRequests[identityId][staker];\\n    }\\n\\n    function getWithdrawalRequestAmount(uint72 identityId, address staker) external view returns (uint96) {\\n        return withdrawalRequests[identityId][staker].amount;\\n    }\\n\\n    function getWithdrawalRequestTimestamp(uint72 identityId, address staker) external view returns (uint256) {\\n        return withdrawalRequests[identityId][staker].timestamp;\\n    }\\n\\n    function withdrawalRequestExists(uint72 identityId, address staker) external view returns (bool) {\\n        return withdrawalRequests[identityId][staker].amount != 0;\\n    }\\n\\n    function transferStake(address receiver, uint96 stakeAmount) external onlyContracts {\\n        tokenContract.transfer(receiver, stakeAmount);\\n    }\\n}\\n\",\"keccak256\":\"0x1901534fb150957d6433fa06b6a59a2c2d1594fc9b9a4e9901f024fea947a4db\",\"license\":\"MIT\"},\"contracts/storage/UnfinalizedStateStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport {HubDependent} from \\\"../abstract/HubDependent.sol\\\";\\nimport {Named} from \\\"../interface/Named.sol\\\";\\nimport {Versioned} from \\\"../interface/Versioned.sol\\\";\\n\\ncontract UnfinalizedStateStorage is Named, Versioned, HubDependent {\\n    string private constant _NAME = \\\"UnfinalizedStateStorage\\\";\\n    string private constant _VERSION = \\\"1.0.0\\\";\\n\\n    // tokenId => latestState\\n    mapping(uint256 => bytes32) internal unfinalizedStates;\\n    // tokenId => issuer\\n    mapping(uint256 => address) internal issuers;\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(address hubAddress) HubDependent(hubAddress) {}\\n\\n    function name() external pure virtual override returns (string memory) {\\n        return _NAME;\\n    }\\n\\n    function version() external pure virtual override returns (string memory) {\\n        return _VERSION;\\n    }\\n\\n    function getUnfinalizedState(uint256 tokenId) external view returns (bytes32) {\\n        return unfinalizedStates[tokenId];\\n    }\\n\\n    function setUnfinalizedState(uint256 tokenId, bytes32 state) external onlyContracts {\\n        unfinalizedStates[tokenId] = state;\\n    }\\n\\n    function deleteUnfinalizedState(uint256 tokenId) external onlyContracts {\\n        delete unfinalizedStates[tokenId];\\n    }\\n\\n    function getIssuer(uint256 tokenId) external view returns (address) {\\n        return issuers[tokenId];\\n    }\\n\\n    function setIssuer(uint256 tokenId, address issuer) external onlyContracts {\\n        issuers[tokenId] = issuer;\\n    }\\n\\n    function deleteIssuer(uint256 tokenId) external onlyContracts {\\n        delete issuers[tokenId];\\n    }\\n\\n    function hasPendingUpdate(uint256 tokenId) external view returns (bool) {\\n        return unfinalizedStates[tokenId] != bytes32(0);\\n    }\\n}\\n\",\"keccak256\":\"0xcb877837ff9dbc4f873514c5acdff80ac9178b519827445ae8ae7dfa89b28a81\",\"license\":\"MIT\"},\"contracts/storage/assets/ContentAssetStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport {AbstractAsset} from \\\"../../abstract/AbstractAsset.sol\\\";\\nimport {Named} from \\\"../../interface/Named.sol\\\";\\nimport {ContentAssetStructs} from \\\"../../structs/assets/ContentAssetStructs.sol\\\";\\nimport {ERC721} from \\\"@openzeppelin/contracts/token/ERC721/ERC721.sol\\\";\\n\\ncontract ContentAssetStorage is AbstractAsset, ERC721 {\\n    string private constant _NAME = \\\"ContentAssetStorage\\\";\\n    string private constant _VERSION = \\\"1.0.0\\\";\\n\\n    uint256 private _tokenId;\\n\\n    // tokenId => Asset\\n    mapping(uint256 => ContentAssetStructs.Asset) internal assets;\\n\\n    // keccak256(tokenId + assertionId + assertionIdIndex) => issuer\\n    mapping(bytes32 => address) public issuers;\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(address hubAddress) AbstractAsset(hubAddress) ERC721(\\\"ContentAssetStorage\\\", \\\"DKG\\\") {}\\n\\n    function name() public view override(Named, ERC721) returns (string memory) {\\n        return ERC721.name();\\n    }\\n\\n    function version() external pure override returns (string memory) {\\n        return _VERSION;\\n    }\\n\\n    function mint(address to, uint256 tokenId) external onlyContracts {\\n        _mint(to, tokenId);\\n    }\\n\\n    function burn(uint256 tokenId) external onlyContracts {\\n        _burn(tokenId);\\n    }\\n\\n    function generateTokenId() external onlyContracts returns (uint256) {\\n        unchecked {\\n            return _tokenId++;\\n        }\\n    }\\n\\n    function deleteAsset(uint256 tokenId) external onlyContracts {\\n        bytes32[] memory assertionIds = assets[tokenId].assertionIds;\\n        uint256 assertionIdsLength = assertionIds.length;\\n\\n        for (uint256 i; i < assertionIdsLength; ) {\\n            delete issuers[_generateAssetAssertionId(tokenId, assertionIds[i], i)];\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        delete assets[tokenId];\\n    }\\n\\n    function getAsset(uint256 tokenId) external view returns (ContentAssetStructs.Asset memory) {\\n        return assets[tokenId];\\n    }\\n\\n    function setMutability(uint256 tokenId, bool immutable_) external onlyContracts {\\n        assets[tokenId].immutable_ = immutable_;\\n    }\\n\\n    function isMutable(uint256 tokenId) external view returns (bool) {\\n        return !assets[tokenId].immutable_;\\n    }\\n\\n    function pushAssertionId(uint256 tokenId, bytes32 assertionId) external onlyContracts {\\n        assets[tokenId].assertionIds.push(assertionId);\\n    }\\n\\n    function getAssertionIds(uint256 tokenId) public view override returns (bytes32[] memory) {\\n        return assets[tokenId].assertionIds;\\n    }\\n\\n    function setAssertionIssuer(uint256 tokenId, bytes32 assertionId, address issuer) external onlyContracts {\\n        issuers[_generateAssetAssertionId(tokenId, assertionId, this.getAssertionIdsLength(tokenId))] = issuer;\\n    }\\n\\n    function deleteAssertionIssuer(uint256 tokenId, bytes32 assertionId, uint256 index) external onlyContracts {\\n        delete issuers[_generateAssetAssertionId(tokenId, assertionId, index)];\\n    }\\n\\n    function getAssertionIssuer(\\n        uint256 tokenId,\\n        bytes32 assertionId,\\n        uint256 assertionIndex\\n    ) external view returns (address) {\\n        return issuers[keccak256(abi.encodePacked(tokenId, assertionId, assertionIndex))];\\n    }\\n\\n    function assertionExists(bytes32 assetAssertionId) external view returns (bool) {\\n        return issuers[assetAssertionId] != address(0);\\n    }\\n\\n    function _generateAssetAssertionId(\\n        uint256 tokenId,\\n        bytes32 assertionId,\\n        uint256 index\\n    ) internal pure virtual returns (bytes32) {\\n        return keccak256(abi.encodePacked(tokenId, assertionId, index));\\n    }\\n}\\n\",\"keccak256\":\"0x00757f97793401b694879c996125cb2e826a37008ec1325ea18103577995f6c4\",\"license\":\"MIT\"},\"contracts/structs/AssertionStructs.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nlibrary AssertionStructs {\\n    struct Assertion {\\n        uint256 timestamp;\\n        uint128 size;\\n        uint32 triplesNumber;\\n        uint96 chunksNumber;\\n    }\\n}\\n\",\"keccak256\":\"0x8d76943e65e0ad3a959570064870312a0cfa4287c117516b1a1c35e685beb49b\",\"license\":\"MIT\"},\"contracts/structs/ServiceAgreementStructsV1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nlibrary ServiceAgreementStructsV1 {\\n    struct CommitSubmission {\\n        uint72 identityId;\\n        uint72 prevIdentityId;\\n        uint72 nextIdentityId;\\n        uint40 score;\\n    }\\n\\n    struct ServiceAgreementInputArgs {\\n        address assetCreator;\\n        address assetContract;\\n        uint256 tokenId;\\n        bytes keyword;\\n        uint8 hashFunctionId;\\n        uint16 epochsNumber;\\n        uint96 tokenAmount;\\n        uint8 scoreFunctionId;\\n    }\\n\\n    struct ServiceAgreement {\\n        uint256 startTime;\\n        uint16 epochsNumber;\\n        uint128 epochLength;\\n        uint96 tokenAmount;\\n        uint8 scoreFunctionId;\\n        uint8 proofWindowOffsetPerc;\\n        // epoch => headCommitId\\n        mapping(uint16 => bytes32) epochSubmissionHeads;\\n        // epoch => number of nodes received rewards\\n        mapping(uint16 => uint32) rewardedNodesNumber;\\n    }\\n\\n    struct ExtendedServiceAgreement {\\n        uint256 startTime;\\n        uint16 epochsNumber;\\n        uint128 epochLength;\\n        uint96 tokenAmount;\\n        uint96 updateTokenAmount;\\n        uint8 scoreFunctionId;\\n        uint8 proofWindowOffsetPerc;\\n        // keccak256(epoch + stateIndex) => headCommitId\\n        mapping(bytes32 => bytes32) epochSubmissionHeads;\\n        // epoch => number of nodes received rewards\\n        mapping(uint16 => uint32) rewardedNodesNumber;\\n    }\\n\\n    struct CommitInputArgs {\\n        address assetContract;\\n        uint256 tokenId;\\n        bytes keyword;\\n        uint8 hashFunctionId;\\n        uint16 epoch;\\n    }\\n\\n    struct ProofInputArgs {\\n        address assetContract;\\n        uint256 tokenId;\\n        bytes keyword;\\n        uint8 hashFunctionId;\\n        uint16 epoch;\\n        bytes32[] proof;\\n        bytes32 chunkHash;\\n    }\\n}\\n\",\"keccak256\":\"0x5b33bc12e685dacf652dfe81b7fff14806297132be7df872c45a598ff783d638\",\"license\":\"MIT\"},\"contracts/structs/ShardingTableStructs.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nlibrary ShardingTableStructs {\\n    struct NodeInfo {\\n        bytes nodeId;\\n        uint72 identityId;\\n        uint96 ask;\\n        uint96 stake;\\n    }\\n\\n    struct Node {\\n        uint72 identityId;\\n        uint72 prevIdentityId;\\n        uint72 nextIdentityId;\\n    }\\n}\\n\",\"keccak256\":\"0xf6f18e4e0643f4c6fa96480189e89d8c7e6fb8de7a4a3f36da24ab3b0ea31d76\",\"license\":\"MIT\"},\"contracts/structs/assets/ContentAssetStructs.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nlibrary ContentAssetStructs {\\n    struct AssetInputArgs {\\n        bytes32 assertionId;\\n        uint128 size;\\n        uint32 triplesNumber;\\n        uint96 chunksNumber;\\n        uint16 epochsNumber;\\n        uint96 tokenAmount;\\n        uint8 scoreFunctionId;\\n        bool immutable_;\\n    }\\n\\n    struct Asset {\\n        bool immutable_;\\n        bytes32[] assertionIds;\\n    }\\n}\\n\",\"keccak256\":\"0xd5565a67a37705de77f4f156c5adf256e60dba55eacbbfd47c8002edbdfa2c45\",\"license\":\"MIT\"},\"contracts/utils/ByteArr.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nlibrary ByteArr {\\n    function indexOf(bytes32[] storage self, bytes32 item) internal view returns (uint index, bool isThere) {\\n        for (uint i; i < self.length; i++) {\\n            if (self[i] == item) {\\n                return (i, true);\\n            }\\n        }\\n        return (0, false);\\n    }\\n\\n    function removeByIndex(bytes32[] storage self, uint256 index) internal returns (bytes32[] memory) {\\n        require(index < self.length, \\\"Index is out of array length\\\");\\n\\n        self[index] = self[self.length - 1];\\n        self.pop();\\n\\n        return self;\\n    }\\n\\n    function getFuncHash(bytes storage _data) internal view returns (bytes4) {\\n        bytes4 output;\\n        for (uint i; i < 4; i++) {\\n            output |= bytes4(_data[i] & 0xFF) >> (i * 8);\\n        }\\n        return output;\\n    }\\n}\\n\",\"keccak256\":\"0xa1a88491b2a586eeebb1f6a6fb7f026931633fb3fb6a5635c74e62621b9f03ba\",\"license\":\"MIT\"},\"contracts/utils/UnorderedIndexableContractDynamicSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport {Indexable} from \\\"../interface/Indexable.sol\\\";\\n\\nlibrary UnorderedIndexableContractDynamicSetLib {\\n    struct Contract {\\n        uint8 id;\\n        address addr;\\n    }\\n\\n    struct Set {\\n        mapping(uint8 => uint256) indexPointers;\\n        Contract[] contractList;\\n    }\\n\\n    function append(Set storage self, uint8 id, address addr) internal {\\n        require(id != 0, \\\"IndexableContractSet: ID canot be 0\\\");\\n        require(addr != address(0), \\\"IndexableContractSet: Address cannot be 0x0\\\");\\n        require(!exists(self, id), \\\"IndexableContractSet: Contract with given ID already exists\\\");\\n        self.indexPointers[id] = size(self);\\n        self.contractList.push(Contract(id, addr));\\n    }\\n\\n    function update(Set storage self, uint8 id, address addr) internal {\\n        require(addr != address(0), \\\"IndexableContractSet: Address cannot be 0x0\\\");\\n        require(exists(self, id), \\\"IndexableContractSet: Contract with given ID doesn't exists\\\");\\n        self.contractList[self.indexPointers[id]].addr = addr;\\n    }\\n\\n    function remove(Set storage self, uint8 id) internal {\\n        require(exists(self, id), \\\"IndexableContractSet: Contract with given ID doesn't exists\\\");\\n        uint256 contractToRemoveIndex = self.indexPointers[id];\\n        Contract memory contractToMove = self.contractList[size(self) - 1];\\n        uint8 contractToMoveId = Indexable(contractToMove.addr).id();\\n\\n        self.indexPointers[contractToMoveId] = contractToRemoveIndex;\\n        self.contractList[contractToRemoveIndex] = contractToMove;\\n\\n        delete self.indexPointers[id];\\n        self.contractList.pop();\\n    }\\n\\n    function get(Set storage self, uint8 id) internal view returns (Contract memory) {\\n        require(exists(self, id), \\\"IndexableContractSet: Contract with given ID doesn't exists\\\");\\n        return self.contractList[self.indexPointers[id]];\\n    }\\n\\n    function getAll(Set storage self) internal view returns (Contract[] memory) {\\n        return self.contractList;\\n    }\\n\\n    function getIndex(Set storage self, uint8 id) internal view returns (uint256) {\\n        return self.indexPointers[id];\\n    }\\n\\n    function getByIndex(Set storage self, uint256 index) internal view returns (Contract memory) {\\n        return self.contractList[index];\\n    }\\n\\n    function exists(Set storage self, uint8 id) internal view returns (bool) {\\n        if (size(self) == 0) return false;\\n        return self.contractList[self.indexPointers[id]].id == id;\\n    }\\n\\n    function size(Set storage self) internal view returns (uint256) {\\n        return self.contractList.length;\\n    }\\n}\\n\",\"keccak256\":\"0xc255ea1ea548b3deb7384a5e8f2b706c53688631ca423c73c24ec5cf674055d6\",\"license\":\"MIT\"},\"contracts/utils/UnorderedNamedContractDynamicSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nlibrary UnorderedNamedContractDynamicSetLib {\\n    struct Contract {\\n        string name;\\n        address addr;\\n    }\\n\\n    struct Set {\\n        mapping(string => uint256) stringIndexPointers;\\n        mapping(address => uint256) addressIndexPointers;\\n        Contract[] contractList;\\n    }\\n\\n    function append(Set storage self, string calldata name, address addr) internal {\\n        require(\\n            keccak256(abi.encodePacked(name)) != keccak256(abi.encodePacked(\\\"\\\")),\\n            \\\"NamedContractSet: Name cannot be empty\\\"\\n        );\\n        require(addr != address(0), \\\"NamedContractSet: Address cannot be 0x0\\\");\\n        require(!exists(self, name), \\\"NamedContractSet: Contract with given name already exists\\\");\\n        self.stringIndexPointers[name] = size(self);\\n        self.addressIndexPointers[addr] = size(self);\\n        self.contractList.push(Contract(name, addr));\\n    }\\n\\n    function update(Set storage self, string calldata name, address addr) internal {\\n        require(addr != address(0), \\\"NamedContractSet: Address cannot be 0x0\\\");\\n        require(exists(self, name), \\\"NamedContractSet: Contract with given name doesn't exists\\\");\\n        delete self.addressIndexPointers[self.contractList[self.stringIndexPointers[name]].addr];\\n        self.addressIndexPointers[addr] = self.stringIndexPointers[name];\\n        self.contractList[self.stringIndexPointers[name]].addr = addr;\\n    }\\n\\n    function remove(Set storage self, string calldata name) internal {\\n        require(exists(self, name), \\\"NamedContractSet: Contract with given name doesn't exist\\\");\\n        uint256 contractToRemoveIndex = self.stringIndexPointers[name];\\n\\n        delete self.addressIndexPointers[self.contractList[contractToRemoveIndex].addr];\\n\\n        Contract memory contractToMove = self.contractList[size(self) - 1];\\n\\n        self.stringIndexPointers[contractToMove.name] = contractToRemoveIndex;\\n        self.addressIndexPointers[contractToMove.addr] = contractToRemoveIndex;\\n        self.contractList[contractToRemoveIndex] = contractToMove;\\n\\n        delete self.stringIndexPointers[name];\\n        self.contractList.pop();\\n    }\\n\\n    function remove(Set storage self, address addr) internal {\\n        require(exists(self, addr), \\\"NamedContractSet: Contract with given address doesn't exist\\\");\\n        uint256 contractToRemoveIndex = self.addressIndexPointers[addr];\\n\\n        delete self.stringIndexPointers[self.contractList[contractToRemoveIndex].name];\\n\\n        Contract memory contractToMove = self.contractList[size(self) - 1];\\n\\n        self.stringIndexPointers[contractToMove.name] = contractToRemoveIndex;\\n        self.addressIndexPointers[contractToMove.addr] = contractToRemoveIndex;\\n        self.contractList[contractToRemoveIndex] = contractToMove;\\n\\n        delete self.addressIndexPointers[addr];\\n        self.contractList.pop();\\n    }\\n\\n    function get(Set storage self, string calldata name) internal view returns (Contract memory) {\\n        require(exists(self, name), \\\"NamedContractSet: Contract with given name doesn't exist\\\");\\n        return self.contractList[self.stringIndexPointers[name]];\\n    }\\n\\n    function get(Set storage self, address addr) internal view returns (Contract memory) {\\n        require(exists(self, addr), \\\"NamedContractSet: Contract with given address doesn't exist\\\");\\n        return self.contractList[self.addressIndexPointers[addr]];\\n    }\\n\\n    function get(Set storage self, uint256 index) internal view returns (Contract memory) {\\n        return self.contractList[index];\\n    }\\n\\n    function getAll(Set storage self) internal view returns (Contract[] memory) {\\n        return self.contractList;\\n    }\\n\\n    function getIndex(Set storage self, string calldata name) internal view returns (uint256) {\\n        return self.stringIndexPointers[name];\\n    }\\n\\n    function getIndex(Set storage self, address addr) internal view returns (uint256) {\\n        return self.addressIndexPointers[addr];\\n    }\\n\\n    function exists(Set storage self, string calldata name) internal view returns (bool) {\\n        if (size(self) == 0) return false;\\n        return\\n            keccak256(abi.encodePacked(self.contractList[self.stringIndexPointers[name]].name)) ==\\n            keccak256(abi.encodePacked(name));\\n    }\\n\\n    function exists(Set storage self, address addr) internal view returns (bool) {\\n        if (size(self) == 0) return false;\\n        return addr == self.contractList[self.addressIndexPointers[addr]].addr;\\n    }\\n\\n    function size(Set storage self) internal view returns (uint256) {\\n        return self.contractList.length;\\n    }\\n}\\n\",\"keccak256\":\"0x2da60d9913c236156764f13a514bc7a9a294feadd4fad9c7a111072fd6bef25a\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608034620000c657601f62002e8338819003918201601f19168301916001600160401b03831184841017620000cb57808492602094604052833981010312620000c657516001600160a01b03811690819003620000c65780156200008157600080546001600160a01b031916919091179055604051612da19081620000e28239f35b60405162461bcd60e51b815260206004820152601960248201527f48756220416464726573732063616e6e6f7420626520307830000000000000006044820152606490fd5b600080fd5b634e487b7160e01b600052604160045260246000fdfe608080604052600436101561001357600080fd5b600090813560e01c90816306fdde03146125ca5750806311c94ee8146125a15780631e98f3ae146122d757806322729ad01461224c578063365a86fc146122255780634b4aeac7146121fc5780634f0350e314611c6c57806354fd4d5014611c22578063631fe36e146118f2578063639a86a3146118c95780636f2f5780146115825780637b5561fd146114f65780638129fc1c1461111c5780638f08d44d146109bb57806390b8145a146109925780639f00b0681461016f578063bd1346ae14610146578063c3573ec71461011d5763c6a2eeca146100f257600080fd5b3461011a578060031936011261011a576006546040516001600160a01b039091168152602090f35b80fd5b503461011a578060031936011261011a576007546040516001600160a01b039091168152602090f35b503461011a578060031936011261011a576003546040516001600160a01b039091168152602090f35b503461011a5760c036600319011261011a576001600160801b0360443516604435036106525763ffffffff6064351660643503610652576001600160601b036084351660843503610652576101c2612674565b906101ce600435612cb4565b6003546040516318d069bd60e01b815260048035908201526001600160a01b0390911690602081602481855afa90811561065f578391610973575b5015610939576007546005546040516375e5231b60e01b81526004803590820152602481018590526001600160a01b039283169590939092909116602084604481855afa9384156108f9578594610904575b5060206102c46102936102d06102eb976040519283918887840190916034926001600160601b03199060601b16825260148201520190565b036102a6601f19918281018552846126ec565b60018060a01b0360025416926040519485916004358a89850161272d565b039081018452836126ec565b60405180809881946345ed59e560e01b835260048301612760565b03915afa9384156108f95785946108c5575b506040805161030b816126b4565b3690376040516337f80ad760e11b81526004810185905260e081602481855afa9081156108ba5786918788928992610883575b5061035f6001600160801b036103588561ffff851661279d565b16856127d4565b421161086a5760405163273267a360e11b815260048035908201529960208b602481845afa9a8b1561085f578a9b61082b575b508a6107f9576001548a969594939291906001600160a01b0316803b156107f557876040518092635c1c1c7960e11b82528183816103de608435606435604435602435600486016128c8565b03925af19081156107d65788916107e1575b5050803b1561076c57604051633972192d60e01b815260043560048201526024356024820152878160448183865af19081156107d65788916107c2575b5050803b1561076c578680916044604051809481936303a59c5760e11b835260043560048401523360248401525af190811561079f5787916107aa575b50506040516307936c9360e11b8152600481018a9052602081602481895afa90811561079f578791610770575b50156106e5575b505050506001600160601b03841661066a575b60405163fef57daf60e01b8152600480359082015294602086602481875afa95861561065f578396610623575b5060405160208101918252866040820152604081526104fc816126d0565b5190206004805460405163daa303cf60e01b81529160209183919082906001600160a01b03165afa9081156106185784916105d7575b5061ffff6105419116426127d4565b823b156105c85760448492836040519586948593636988c39d60e11b8552600485015260248401525af180156105cc576105b4575b50506001600160601b03604051921682527f69c8288fbbca6d30ee12fcf4280fec7b680b04b11a312c85292cb47a7610aa43602060043593a4604051f35b6105bd9061268a565b6105c8578385610576565b8380fd5b6040513d84823e3d90fd5b90506020813d602011610610575b816105f2602093836126ec565b810103126105c85761ffff610609610541926127f5565b9150610532565b3d91506105e5565b6040513d86823e3d90fd5b925094506020823d602011610657575b81610640602093836126ec565b810103126106525785915194876104de565b600080fd5b3d9150610633565b6040513d85823e3d90fd5b6006546001600160a01b0316803b156106e1576040516357856ce160e11b8152336004820152602481018790526001600160601b03861660448201529083908290606490829084905af190811561065f5783916106c9575b50506104b1565b6106d29061268a565b6106dd5781876106c2565b5080fd5b8280fd5b60ff6020818451169301511692853b1561076c5761ffff6001600160801b039260405196630925ffd960e01b88528c6004890152602488015216604486015216606484015284608484015260a483015260c4820152828160e48183865af190811561065f578391610758575b808061049e565b6107619061268a565b6106dd578187610751565b8680fd5b610792915060203d602011610798575b61078a81836126ec565b8101906128fe565b8b610497565b503d610780565b6040513d89823e3d90fd5b6107b39061268a565b6107be57858b61046a565b8580fd5b6107cb9061268a565b61076c57868c61042d565b6040513d8a823e3d90fd5b6107ea9061268a565b61076c57868c6103f0565b8780fd5b60405163ba69cfd960e01b81526001600160a01b038816600480830191909152356024820152604481018c9052606490fd5b909a506020813d602011610857575b81610847602093836126ec565b8101031261065257519938610392565b3d915061083a565b6040513d8c823e3d90fd5b602460405163f72d5efd60e01b81526004356004820152fd5b925050506108a9915060e03d60e0116108b3575b6108a181836126ec565b810190612804565b919290503861033e565b503d610897565b6040513d88823e3d90fd5b9093506020813d6020116108f1575b816108e1602093836126ec565b81010312610652575192386102fd565b3d91506108d4565b6040513d87823e3d90fd5b93506020843d602011610931575b8161091f602093836126ec565b8101031261065257925192602061025b565b3d9150610912565b60405162461bcd60e51b8152602060048201526012602482015271417373657420697320696d6d757461626c6560701b6044820152606490fd5b61098c915060203d6020116107985761078a81836126ec565b38610209565b503461011a578060031936011261011a576005546040516001600160a01b039091168152602090f35b503461011a576020806003193601126106dd57600435916109db83612cb4565b60018060a01b03928360035416604051936375e5231b60e01b855282600486015260249584878701528186604481865afa9586156108f95785966110ed575b50816102c4610a51610a7a610a95996040519283918987840190916034926001600160601b03199060601b16825260148201520190565b03610a64601f19918281018552846126ec565b8560025416926040519485918b8b89850161272d565b60405180809a81946345ed59e560e01b835260048301612760565b03915afa9586156108f95785966110be575b50868282600754166040519283809263273267a360e11b82528960048301525afa9081156108ba578691611091575b5080611061575080600554168160045416604051630271c2cf60e61b815288600482015284818b81865afa9081156107d6578891611034575b5060405163484a47e760e01b808252600482018b905286828d81885afa91821561085f578a92610ffd575b50604051637ad65f2760e01b81528781600481885afa908115610f12578d9594928d94928a928e91610fb2575b5060ff6064610b9092610b876001600160801b039788948593169061279d565b160416856127d4565b966040519586928352600483015281895afa8015610f12578b90610f74575b610bbb935016906127d4565b60405163fef57daf60e01b815260048101899052909286828d818b5afa91821561085f578a92610f45575b506000198201918211610f325760405191878301908c82528b60408501526042840152604283528c608084019184831067ffffffffffffffff841117610f1d57604083905284519020634849174160e01b835260848501528890829081895afa928315610f12579088918c94610ed6575b505060405163659621b560e01b815293849060049082905afa92831561085f578a93610e96575b50421080610e84575b15610ca45760405163136e51c560e21b8152600481018b90528b90fd5b8242109182610e6e575b505015610ccd5760405163279363a160e21b8152600481018990528990fd5b9187918994934211610e565787929184869260405197888092634089a17d60e01b82528760048301525afa958615610618578496610e1f575b50863b156105c857604051637eb79b5360e01b81526004810189905284818481838c5af19081156108f9578591610e0b575b5050863b156105c857604051630852cd8d60e31b81526004810189905284818481838c5af19081156108f9578591610df7575b50506006541691823b156105c857604484928360405195869485936388adf4cd60e01b85523360048601528401525af180156105cc57610ddf575b50507fd3a95f1c237197f6a34313d9091d204fe02cb5e29a25bb37fe5396bc0ac0c2d0916001600160601b0360405191168152a3604051f35b610de89061268a565b610df3578486610da6565b8480fd5b610e009061268a565b6105c857838a610d6b565b610e149061268a565b6105c857838a610d38565b9095508481813d8311610e4f575b610e3781836126ec565b810103126105c857610e48906127e1565b9489610d06565b503d610e2d565b60405163220e7b1960e11b8152600481018490528590fd5b60ff91925063ffffffff16911610153880610cae565b5063ffffffff821660ff821610610c87565b9092508681813d8311610ecf575b610eae81836126ec565b81010312610ecb575163ffffffff81168103610ecb579138610c7e565b8980fd5b503d610ea4565b90929350813d8311610f0b575b610eed81856126ec565b81010312610ecb579086610f036004949361278f565b929338610c57565b503d610ee3565b6040513d8d823e3d90fd5b50634e487b7160e01b60009081526041600452fd5b634e487b7160e01b8a5260116004528b8afd5b9091508681813d8311610f6d575b610f5d81836126ec565b8101031261065257519038610be6565b503d610f53565b5090918781813d8311610fab575b610f8c81836126ec565b81010312610fa75790610fa2610bbb939261277b565b610baf565b8a80fd5b503d610f82565b939550509294955081813d8311610ff6575b610fce81836126ec565b81010312610fa75791878d959492610b9060ff8f96610fee60649161278f565b925050610b67565b503d610fc4565b9091508681813d831161102d575b61101581836126ec565b81010312610ecb576110269061277b565b9038610b3a565b503d61100b565b90508481813d831161105a575b61104b81836126ec565b81010312610652575138610b0f565b503d611041565b60405163ba69cfd960e01b81526001600160a01b0385166004820152602481018690526044810191909152606490fd5b90508281813d83116110b7575b6110a881836126ec565b81010312610652575138610ad6565b503d61109e565b9095508181813d83116110e6575b6110d681836126ec565b8101031261065257519438610aa7565b503d6110cc565b95508186813d8311611115575b61110481836126ec565b810103126106525794519481610a1a565b503d6110fa565b503461011a578060031936011261011a578054604051638da5cb5b60e01b81526001600160a01b0391821691906020908181600481875afa80156108f957839186916114d9575b50163303611496578360405193630110ceef60e21b908186528360048701526024906009828801526044926820b9b9b2b93a34b7b760b91b8489015260649186898481845afa9889156108ba578699611477575b50876001600160601b0360a01b9916896001541617600155604051828152876004820152600c858201526b48617368696e6750726f787960a01b8682015287818581855afa801561079f578991889161145a575b5016896002541617600255604051633222517f60e11b815287600482015260138582015272436f6e74656e74417373657453746f7261676560681b8682015287818581855afa801561079f578991889161143d575b501689600354161760035560405182815287600482015260118582015270506172616d657465727353746f7261676560781b8682015287818581855afa801561079f5789918891611420575b5016896004541617600455604051828152876004820152601c858201527f5365727669636541677265656d656e7453746f7261676550726f7879000000008682015287818581855afa801561079f5789918891611403575b5016896005541617600555604051828152876004820152601285820152715365727669636541677265656d656e74563160701b8682015287818581855afa95861561079f578989977f556e66696e616c697a6564537461746553746f726167650000000000000000009360179a916113e6575b50168b6006541617600655604051978896879586528860048701528501528301525afa9182156108f95785926113b9575b505016906007541617600755604051f35b6113d89250803d106113df575b6113d081836126ec565b81019061270e565b38806113a8565b503d6113c6565b6113fd9150893d8b116113df576113d081836126ec565b38611377565b61141a9150893d8b116113df576113d081836126ec565b38611304565b6114379150893d8b116113df576113d081836126ec565b386112ac565b6114549150893d8b116113df576113d081836126ec565b38611260565b6114719150893d8b116113df576113d081836126ec565b3861120b565b61148f919950873d89116113df576113d081836126ec565b97386111b7565b6064906040519062461bcd60e51b825280600483015260248201527f466e2063616e206f6e6c79206265207573656420627920687562206f776e65726044820152fd5b6114f09150833d85116113df576113d081836126ec565b38611163565b503461011a5761010036600319011261011a576024356001600160801b03811681036106525760443563ffffffff81168103610652576064356001600160601b03811681036106525760843561ffff8116810361065257611555612674565b9060c4359260ff8416840361076c5760e4359485151586036107f55761157d96600435612916565b604051f35b503461011a57606036600319011261011a576004356024803561ffff9081811680910361065257604435916001600160601b038316809303610652576115c785612cb4565b60018060a01b03806003541694816006541691806007541693604051809563273267a360e11b82528a6004830152818560209889935afa908115610f12578b9161189c575b508061186c57506040516375e5231b60e01b81528960048201528a8482015285816044818c5afa8015610f12578a87918d9061183b575b6116bc93506116a18c61167660405193849287840190916034926001600160601b03199060601b16825260148201520190565b03611689601f19918281018552846126ec565b8d6102c489600254169460405196879389850161272d565b60405180809581946345ed59e560e01b835260048301612760565b03915afa928315610f125784918c94611807575b5060e09060055416604051928380926337f80ad760e11b82528760048301525afa8015610f1257611721928c809381936117d0575b509161171a916001600160801b03931661279d565b16906127d4565b42116117b95790829189933b156105c857608484928360405195869485936399a5c86b60e01b85523360048601528401528960448401528a60648401525af180156105cc576117a1575b5050907ff95dba7d7d00ab9b8357396c7d1f2a9bab2ba9a9dab4c76b19417c1e56129a66926040928351928352820152a3604051f35b6117ad9093929361268a565b6107be5790853861176b565b5060405163f72d5efd60e01b815260048101889052fd5b61171a9294506001600160801b0393506117f9915060e03d60e0116108b3576108a181836126ec565b505091949091935091611705565b87809295508193503d8311611834575b61182181836126ec565b81010312610652575191839060e06116d0565b503d611817565b505081813d8311611865575b61185181836126ec565b8101031261065257858a6116bc9251611643565b503d611847565b60405163ba69cfd960e01b81526001600160a01b038a166004820152602481018b90526044810191909152606490fd5b90508581813d83116118c2575b6118b381836126ec565b8101031261065257513861160c565b503d6118a9565b503461011a578060031936011261011a576004546040516001600160a01b039091168152602090f35b503461011a57604036600319011261011a5760043561190f61265e565b61191882612cb4565b60018060a01b0390816003541691806006541690806007541691604051809363273267a360e11b825287600483015281602460209687935afa9081156107d6578891611bf5575b5080611bc55750604051916375e5231b60e01b83528660048401528760248401528383604481895afa9283156107d6578785918a95611b92575b50604051606089901b6001600160601b0319168382019081526014810196909652611a0e956119f39082906034015b036119db601f19918281018552846126ec565b8a6102c487600254169460405196879389850161272d565b60405180809781946345ed59e560e01b835260048301612760565b03915afa9283156107d6578893611b62575b5060e060249160055416604051928380926337f80ad760e11b82528760048301525afa9081156107d657611a719189908a8b91611b29575b6001600160801b039293509061ffff61171a921661279d565b4211611b1057908187923b156106e157604051637ca3fa7360e01b815233600482015260248101929092526001600160601b038516604483015282908290606490829084905af180156105cc57611afc575b50507f94bb2d6c0b0156b69860650cb41ebb691db20169e5ea6b8d02e791fd32213740916001600160601b0360405191168152a3604051f35b611b059061268a565b610df3578438611ac3565b60405163f72d5efd60e01b815260048101879052602490fd5b5050506001600160801b0361171a611b5261ffff9360e03d60e0116108b3576108a181836126ec565b5092955085945092509050611a58565b9092508381813d8311611b8b575b611b7a81836126ec565b8101031261065257519160e0611a20565b503d611b70565b94505083813d8311611bbe575b611ba981836126ec565b810103126106525791519183876119c8611999565b503d611b9f565b60405163ba69cfd960e01b81526001600160a01b0387166004820152602481018890526044810191909152606490fd5b90508381813d8311611c1b575b611c0c81836126ec565b8101031261065257513861195f565b503d611c02565b503461011a578060031936011261011a57611c68604051611c42816126b4565b60058152640312e302e360dc1b6020820152604051918291602083526020830190612639565b0390f35b503461011a576020806003193601126106dd5760043591611c8c83612cb4565b60018060a01b03806003541692816005541691806007541692604051936375e5231b60e01b8552876004860152602494868682015284816044818b5afa90811561079f578886928b928a916121c3575b50611d3b96611d14926102c46119f393604051958691848a840190916034926001600160601b03199060601b16825260148201520190565b0392611d28601f19948581018852876126ec565b600254169460405196879389850161272d565b03915afa9283156108ba578693612194575b506040516337f80ad760e11b81526004810184905260e0818781865afa801561079f5790611d97918890898a91611b29576001600160801b039293509061ffff61171a921661279d565b421161217c5760405163273267a360e11b8152600481018990529184838781855afa92831561079f57879361214d575b5060405163fef57daf60e01b808252600482018b905293868289818d5afa918215612142578992612113575b50611e20576040516340501bd760e01b81526001600160a01b038a166004820152602481018b9052604490fd5b6040999799989698518681019086825282604082015260408152611e43816126d0565b519020604051906315ce5a4560e01b8252600482015286818b81865afa908115610f12578b916120e6575b504211156120c35750908892916040519463044c990b60e41b865280600487015286868b81855afa9586156108f957859661208c575b50813b15610df3576040519063e25aa72560e01b82526004820152848a820152848160448183865af19081156108f9578591612078575b5050803b156105c857836001600160601b0360448b97836040519586948593632c640e6d60e01b855233600486015216809b8401525af1908115610618578491612064575b5050803b156106e15760405163a021d76d60e01b81526004810188905283818a8183865af1908115610618578491612050575b5050803b156106e1578280918960405180968193635498a1d160e11b83528c60048401525af192831561204357859361202a575b5050604051968791825286600483015281865afa9485156108ba578695611fd9575b50907fbf781c6dda1607f992095470fe21fac1ed7628c89a45ca78b7dfde2ed2e72b3b91604051908152a4604051f35b918091955082813d8311612023575b611ff281836126ec565b81010312610652579051937fbf781c6dda1607f992095470fe21fac1ed7628c89a45ca78b7dfde2ed2e72b3b611fa9565b503d611fe8565b6120369192935061268a565b61076c5782908738611f87565b50604051903d90823e3d90fd5b6120599061268a565b6106e1578238611f53565b61206d9061268a565b6106e1578238611f20565b6120819061268a565b6105c8578338611edb565b9095508681813d83116120bc575b6120a481836126ec565b81010312610df3576120b5906127e1565b9438611ea4565b503d61209a565b86606491898b6040519363343304af60e01b855260048501528301526044820152fd5b90508681813d831161210c575b6120fd81836126ec565b81010312610652575138611e6e565b503d6120f3565b9091508681813d831161213b575b61212b81836126ec565b8101031261065257519038611df3565b503d612121565b6040513d8b823e3d90fd5b9092508481813d8311612175575b61216581836126ec565b8101031261065257519138611dc7565b503d61215b565b60405163f72d5efd60e01b8152600481018990528590fd5b9092508381813d83116121bc575b6121ac81836126ec565b8101031261065257519138611d4d565b503d6121a2565b96939250505084813d83116121f5575b6121dd81836126ec565b81010312610652579251849089908990611d3b611cdc565b503d6121d3565b503461011a578060031936011261011a576001546040516001600160a01b039091168152602090f35b503461011a578060031936011261011a57546040516001600160a01b039091168152602090f35b503461011a5761010036600319011261011a576024356001600160801b03811681036106dd5760443563ffffffff811681036106e1576064356001600160601b0380821682036106525760843561ffff811681036107be5760a43591821682036106525760c4359260ff8416840361076c5760e4359485151586036107f55761157d96600435612916565b503461011a57604036600319011261011a576004356122f461265e565b6122fd82612cb4565b60018060a01b038060035416918160065416826007541692604051809463273267a360e11b825287600483015281602460209788935afa9081156107d6578891612574575b501561254c57604051906375e5231b60e01b82528660048301528760248301528482604481895afa9182156107d6578786918a94612519575b50604051606089901b6001600160601b03191683820190815260148101959095526123c9946123ae9082906034016119c8565b60405180809681946345ed59e560e01b835260048301612760565b03915afa9182156107d65788926124e9575b5060e060249160055416604051928380926337f80ad760e11b82528660048301525afa9081156107d65761242b9189908a8b91611b29576001600160801b039293509061ffff61171a921661279d565b4211611b10578690823b156106dd576040516357856ce160e11b815233600482015260248101919091526001600160601b0384166044820152918290606490829084905af180156108ba576124b4575b50907ff70a2f6971e3b06b83151f5a9b7dc691b79b15e828db0adcf68dc8f97cd29997916001600160601b0360405191168152a3604051f35b946124e17ff70a2f6971e3b06b83151f5a9b7dc691b79b15e828db0adcf68dc8f97cd2999793929661268a565b94909161247b565b9091508481813d8311612512575b61250181836126ec565b810103126107f557519060e06123db565b503d6124f7565b93505082813d8311612545575b61253081836126ec565b810103126107f55790519084876119c861237b565b503d612526565b6040516340501bd760e01b81526001600160a01b038616600482015260248101879052604490fd5b90508481813d831161259a575b61258b81836126ec565b810103126107f5575138612342565b503d612581565b503461011a578060031936011261011a576002546040516001600160a01b039091168152602090f35b9050346106dd57816003193601126106dd57806125e9611c68926126b4565b600c81526b10dbdb9d195b9d105cdcd95d60a21b6020820152604051918291602083526020830190612639565b60005b8381106126295750506000910152565b8181015183820152602001612619565b9060209161265281518092818552858086019101612616565b601f01601f1916010190565b602435906001600160601b038216820361065257565b60a435906001600160601b038216820361065257565b67ffffffffffffffff811161269e57604052565b634e487b7160e01b600052604160045260246000fd5b6040810190811067ffffffffffffffff82111761269e57604052565b6060810190811067ffffffffffffffff82111761269e57604052565b90601f8019910116810190811067ffffffffffffffff82111761269e57604052565b9081602091031261065257516001600160a01b03811681036106525790565b9091603493926001600160601b03199060601b168252601482015261275b8251809360208685019101612616565b010190565b90604061277892600181528160208201520190612639565b90565b51906001600160801b038216820361065257565b519060ff8216820361065257565b6001600160801b0391828092169182911692048211811515166127be570290565b634e487b7160e01b600052601160045260246000fd5b919082018092116127be57565b51906001600160601b038216820361065257565b519061ffff8216820361065257565b9160e083830312610652578251926020916128208383016127f5565b9361282d6040840161277b565b9381607f850112156106525760405191612846836126b4565b8260a0860193828511610652578360608801915b8683106128b057505050948160bf82011215610652576040519361287d856126b4565b60e085920192831161065257905b828210612899575050505090565b8380916128a58461278f565b81520191019061288b565b81906128bb846127e1565b815201910190849061285a565b929363ffffffff6001600160601b039296956001600160801b036060956080880199885216602087015216604085015216910152565b90816020910312610652575180151581036106525790565b600354604051636db6095560e01b8152919891976001600160a01b039091169660009690959194909360208a6004818b8d5af1998a156107d657889a612c80575b50883b156107f5576040516340c10f1960e01b8152336004820152602481018b90528881604481838e5af1801561214257612c6d575b506001546001600160a01b031690813b15612c695790889291838d6129c860405197889687958694635c1c1c7960e11b8652600486016128c8565b03925af180156108ba57908691612c55575b5050853b15610df35760405163eaeb169560e01b81528760048201528860248201523360448201528581606481838b5af180156108ba57908691612c41575b5050853b15610df3576040516312d540c560e01b81526004810188905290151560248201528481604481838a5af180156108f957908591612c2d575b5050843b156105c85760405163367bcd9f60e01b81528660048201528760248201528481604481838a5af180156108f957908591612c19575b5050600654604051606087901b6001600160601b031916602082015260348082018a905281526001600160a01b039091169290612acc6054826126ec565b60405194610100860186811067ffffffffffffffff82111761269e5760ff946001600160601b039361ffff926040523389528a60208a01528b60408a01526060890152600160808901521660a08701521660c08501521660e0830152803b156106e1578291829160405180948180946370ab967360e11b82526020600483015260018060a01b03815116602483015260018060a01b0360208201511660448301526040810151606483015260ff60e0612b9660608401516101006084870152610124860190612639565b928260808201511660a486015261ffff60a08201511660c48601526001600160601b0360c08201511660e486015201511661010483015203925af180156105cc57612c05575b507f60e45db7c8cb9f55f92f3de18053b0b426eb919a763a1daca0ea9ad20961e87890604051a4565b612c0f829161268a565b61011a5738612bdc565b612c229061268a565b6105c8578338612a8e565b612c369061268a565b6105c8578338612a55565b612c4a9061268a565b610df3578438612a19565b612c5e9061268a565b610df35784386129da565b8880fd5b612c799098919861268a565b963861298d565b9099506020813d602011612cac575b81612c9c602093836126ec565b810103126107f557519838612957565b3d9150612c8f565b6003546040516331a9108f60e11b815260048101929092526001600160a01b0391906020908290602490829086165afa908115612d5f57600091612d41575b50163303612cfd57565b606460405162461bcd60e51b815260206004820152602060248201527f4f6e6c79206173736574206f776e65722063616e20757365207468697320666e6044820152fd5b612d59915060203d81116113df576113d081836126ec565b38612cf3565b6040513d6000823e3d90fdfea26469706673582212206d56174992a7bb3955e147b99a7ff4d3e61b49283e82e8a8ff690d751e3947a364736f6c63430008100033",
  "deployedBytecode": "0x608080604052600436101561001357600080fd5b600090813560e01c90816306fdde03146125ca5750806311c94ee8146125a15780631e98f3ae146122d757806322729ad01461224c578063365a86fc146122255780634b4aeac7146121fc5780634f0350e314611c6c57806354fd4d5014611c22578063631fe36e146118f2578063639a86a3146118c95780636f2f5780146115825780637b5561fd146114f65780638129fc1c1461111c5780638f08d44d146109bb57806390b8145a146109925780639f00b0681461016f578063bd1346ae14610146578063c3573ec71461011d5763c6a2eeca146100f257600080fd5b3461011a578060031936011261011a576006546040516001600160a01b039091168152602090f35b80fd5b503461011a578060031936011261011a576007546040516001600160a01b039091168152602090f35b503461011a578060031936011261011a576003546040516001600160a01b039091168152602090f35b503461011a5760c036600319011261011a576001600160801b0360443516604435036106525763ffffffff6064351660643503610652576001600160601b036084351660843503610652576101c2612674565b906101ce600435612cb4565b6003546040516318d069bd60e01b815260048035908201526001600160a01b0390911690602081602481855afa90811561065f578391610973575b5015610939576007546005546040516375e5231b60e01b81526004803590820152602481018590526001600160a01b039283169590939092909116602084604481855afa9384156108f9578594610904575b5060206102c46102936102d06102eb976040519283918887840190916034926001600160601b03199060601b16825260148201520190565b036102a6601f19918281018552846126ec565b60018060a01b0360025416926040519485916004358a89850161272d565b039081018452836126ec565b60405180809881946345ed59e560e01b835260048301612760565b03915afa9384156108f95785946108c5575b506040805161030b816126b4565b3690376040516337f80ad760e11b81526004810185905260e081602481855afa9081156108ba5786918788928992610883575b5061035f6001600160801b036103588561ffff851661279d565b16856127d4565b421161086a5760405163273267a360e11b815260048035908201529960208b602481845afa9a8b1561085f578a9b61082b575b508a6107f9576001548a969594939291906001600160a01b0316803b156107f557876040518092635c1c1c7960e11b82528183816103de608435606435604435602435600486016128c8565b03925af19081156107d65788916107e1575b5050803b1561076c57604051633972192d60e01b815260043560048201526024356024820152878160448183865af19081156107d65788916107c2575b5050803b1561076c578680916044604051809481936303a59c5760e11b835260043560048401523360248401525af190811561079f5787916107aa575b50506040516307936c9360e11b8152600481018a9052602081602481895afa90811561079f578791610770575b50156106e5575b505050506001600160601b03841661066a575b60405163fef57daf60e01b8152600480359082015294602086602481875afa95861561065f578396610623575b5060405160208101918252866040820152604081526104fc816126d0565b5190206004805460405163daa303cf60e01b81529160209183919082906001600160a01b03165afa9081156106185784916105d7575b5061ffff6105419116426127d4565b823b156105c85760448492836040519586948593636988c39d60e11b8552600485015260248401525af180156105cc576105b4575b50506001600160601b03604051921682527f69c8288fbbca6d30ee12fcf4280fec7b680b04b11a312c85292cb47a7610aa43602060043593a4604051f35b6105bd9061268a565b6105c8578385610576565b8380fd5b6040513d84823e3d90fd5b90506020813d602011610610575b816105f2602093836126ec565b810103126105c85761ffff610609610541926127f5565b9150610532565b3d91506105e5565b6040513d86823e3d90fd5b925094506020823d602011610657575b81610640602093836126ec565b810103126106525785915194876104de565b600080fd5b3d9150610633565b6040513d85823e3d90fd5b6006546001600160a01b0316803b156106e1576040516357856ce160e11b8152336004820152602481018790526001600160601b03861660448201529083908290606490829084905af190811561065f5783916106c9575b50506104b1565b6106d29061268a565b6106dd5781876106c2565b5080fd5b8280fd5b60ff6020818451169301511692853b1561076c5761ffff6001600160801b039260405196630925ffd960e01b88528c6004890152602488015216604486015216606484015284608484015260a483015260c4820152828160e48183865af190811561065f578391610758575b808061049e565b6107619061268a565b6106dd578187610751565b8680fd5b610792915060203d602011610798575b61078a81836126ec565b8101906128fe565b8b610497565b503d610780565b6040513d89823e3d90fd5b6107b39061268a565b6107be57858b61046a565b8580fd5b6107cb9061268a565b61076c57868c61042d565b6040513d8a823e3d90fd5b6107ea9061268a565b61076c57868c6103f0565b8780fd5b60405163ba69cfd960e01b81526001600160a01b038816600480830191909152356024820152604481018c9052606490fd5b909a506020813d602011610857575b81610847602093836126ec565b8101031261065257519938610392565b3d915061083a565b6040513d8c823e3d90fd5b602460405163f72d5efd60e01b81526004356004820152fd5b925050506108a9915060e03d60e0116108b3575b6108a181836126ec565b810190612804565b919290503861033e565b503d610897565b6040513d88823e3d90fd5b9093506020813d6020116108f1575b816108e1602093836126ec565b81010312610652575192386102fd565b3d91506108d4565b6040513d87823e3d90fd5b93506020843d602011610931575b8161091f602093836126ec565b8101031261065257925192602061025b565b3d9150610912565b60405162461bcd60e51b8152602060048201526012602482015271417373657420697320696d6d757461626c6560701b6044820152606490fd5b61098c915060203d6020116107985761078a81836126ec565b38610209565b503461011a578060031936011261011a576005546040516001600160a01b039091168152602090f35b503461011a576020806003193601126106dd57600435916109db83612cb4565b60018060a01b03928360035416604051936375e5231b60e01b855282600486015260249584878701528186604481865afa9586156108f95785966110ed575b50816102c4610a51610a7a610a95996040519283918987840190916034926001600160601b03199060601b16825260148201520190565b03610a64601f19918281018552846126ec565b8560025416926040519485918b8b89850161272d565b60405180809a81946345ed59e560e01b835260048301612760565b03915afa9586156108f95785966110be575b50868282600754166040519283809263273267a360e11b82528960048301525afa9081156108ba578691611091575b5080611061575080600554168160045416604051630271c2cf60e61b815288600482015284818b81865afa9081156107d6578891611034575b5060405163484a47e760e01b808252600482018b905286828d81885afa91821561085f578a92610ffd575b50604051637ad65f2760e01b81528781600481885afa908115610f12578d9594928d94928a928e91610fb2575b5060ff6064610b9092610b876001600160801b039788948593169061279d565b160416856127d4565b966040519586928352600483015281895afa8015610f12578b90610f74575b610bbb935016906127d4565b60405163fef57daf60e01b815260048101899052909286828d818b5afa91821561085f578a92610f45575b506000198201918211610f325760405191878301908c82528b60408501526042840152604283528c608084019184831067ffffffffffffffff841117610f1d57604083905284519020634849174160e01b835260848501528890829081895afa928315610f12579088918c94610ed6575b505060405163659621b560e01b815293849060049082905afa92831561085f578a93610e96575b50421080610e84575b15610ca45760405163136e51c560e21b8152600481018b90528b90fd5b8242109182610e6e575b505015610ccd5760405163279363a160e21b8152600481018990528990fd5b9187918994934211610e565787929184869260405197888092634089a17d60e01b82528760048301525afa958615610618578496610e1f575b50863b156105c857604051637eb79b5360e01b81526004810189905284818481838c5af19081156108f9578591610e0b575b5050863b156105c857604051630852cd8d60e31b81526004810189905284818481838c5af19081156108f9578591610df7575b50506006541691823b156105c857604484928360405195869485936388adf4cd60e01b85523360048601528401525af180156105cc57610ddf575b50507fd3a95f1c237197f6a34313d9091d204fe02cb5e29a25bb37fe5396bc0ac0c2d0916001600160601b0360405191168152a3604051f35b610de89061268a565b610df3578486610da6565b8480fd5b610e009061268a565b6105c857838a610d6b565b610e149061268a565b6105c857838a610d38565b9095508481813d8311610e4f575b610e3781836126ec565b810103126105c857610e48906127e1565b9489610d06565b503d610e2d565b60405163220e7b1960e11b8152600481018490528590fd5b60ff91925063ffffffff16911610153880610cae565b5063ffffffff821660ff821610610c87565b9092508681813d8311610ecf575b610eae81836126ec565b81010312610ecb575163ffffffff81168103610ecb579138610c7e565b8980fd5b503d610ea4565b90929350813d8311610f0b575b610eed81856126ec565b81010312610ecb579086610f036004949361278f565b929338610c57565b503d610ee3565b6040513d8d823e3d90fd5b50634e487b7160e01b60009081526041600452fd5b634e487b7160e01b8a5260116004528b8afd5b9091508681813d8311610f6d575b610f5d81836126ec565b8101031261065257519038610be6565b503d610f53565b5090918781813d8311610fab575b610f8c81836126ec565b81010312610fa75790610fa2610bbb939261277b565b610baf565b8a80fd5b503d610f82565b939550509294955081813d8311610ff6575b610fce81836126ec565b81010312610fa75791878d959492610b9060ff8f96610fee60649161278f565b925050610b67565b503d610fc4565b9091508681813d831161102d575b61101581836126ec565b81010312610ecb576110269061277b565b9038610b3a565b503d61100b565b90508481813d831161105a575b61104b81836126ec565b81010312610652575138610b0f565b503d611041565b60405163ba69cfd960e01b81526001600160a01b0385166004820152602481018690526044810191909152606490fd5b90508281813d83116110b7575b6110a881836126ec565b81010312610652575138610ad6565b503d61109e565b9095508181813d83116110e6575b6110d681836126ec565b8101031261065257519438610aa7565b503d6110cc565b95508186813d8311611115575b61110481836126ec565b810103126106525794519481610a1a565b503d6110fa565b503461011a578060031936011261011a578054604051638da5cb5b60e01b81526001600160a01b0391821691906020908181600481875afa80156108f957839186916114d9575b50163303611496578360405193630110ceef60e21b908186528360048701526024906009828801526044926820b9b9b2b93a34b7b760b91b8489015260649186898481845afa9889156108ba578699611477575b50876001600160601b0360a01b9916896001541617600155604051828152876004820152600c858201526b48617368696e6750726f787960a01b8682015287818581855afa801561079f578991889161145a575b5016896002541617600255604051633222517f60e11b815287600482015260138582015272436f6e74656e74417373657453746f7261676560681b8682015287818581855afa801561079f578991889161143d575b501689600354161760035560405182815287600482015260118582015270506172616d657465727353746f7261676560781b8682015287818581855afa801561079f5789918891611420575b5016896004541617600455604051828152876004820152601c858201527f5365727669636541677265656d656e7453746f7261676550726f7879000000008682015287818581855afa801561079f5789918891611403575b5016896005541617600555604051828152876004820152601285820152715365727669636541677265656d656e74563160701b8682015287818581855afa95861561079f578989977f556e66696e616c697a6564537461746553746f726167650000000000000000009360179a916113e6575b50168b6006541617600655604051978896879586528860048701528501528301525afa9182156108f95785926113b9575b505016906007541617600755604051f35b6113d89250803d106113df575b6113d081836126ec565b81019061270e565b38806113a8565b503d6113c6565b6113fd9150893d8b116113df576113d081836126ec565b38611377565b61141a9150893d8b116113df576113d081836126ec565b38611304565b6114379150893d8b116113df576113d081836126ec565b386112ac565b6114549150893d8b116113df576113d081836126ec565b38611260565b6114719150893d8b116113df576113d081836126ec565b3861120b565b61148f919950873d89116113df576113d081836126ec565b97386111b7565b6064906040519062461bcd60e51b825280600483015260248201527f466e2063616e206f6e6c79206265207573656420627920687562206f776e65726044820152fd5b6114f09150833d85116113df576113d081836126ec565b38611163565b503461011a5761010036600319011261011a576024356001600160801b03811681036106525760443563ffffffff81168103610652576064356001600160601b03811681036106525760843561ffff8116810361065257611555612674565b9060c4359260ff8416840361076c5760e4359485151586036107f55761157d96600435612916565b604051f35b503461011a57606036600319011261011a576004356024803561ffff9081811680910361065257604435916001600160601b038316809303610652576115c785612cb4565b60018060a01b03806003541694816006541691806007541693604051809563273267a360e11b82528a6004830152818560209889935afa908115610f12578b9161189c575b508061186c57506040516375e5231b60e01b81528960048201528a8482015285816044818c5afa8015610f12578a87918d9061183b575b6116bc93506116a18c61167660405193849287840190916034926001600160601b03199060601b16825260148201520190565b03611689601f19918281018552846126ec565b8d6102c489600254169460405196879389850161272d565b60405180809581946345ed59e560e01b835260048301612760565b03915afa928315610f125784918c94611807575b5060e09060055416604051928380926337f80ad760e11b82528760048301525afa8015610f1257611721928c809381936117d0575b509161171a916001600160801b03931661279d565b16906127d4565b42116117b95790829189933b156105c857608484928360405195869485936399a5c86b60e01b85523360048601528401528960448401528a60648401525af180156105cc576117a1575b5050907ff95dba7d7d00ab9b8357396c7d1f2a9bab2ba9a9dab4c76b19417c1e56129a66926040928351928352820152a3604051f35b6117ad9093929361268a565b6107be5790853861176b565b5060405163f72d5efd60e01b815260048101889052fd5b61171a9294506001600160801b0393506117f9915060e03d60e0116108b3576108a181836126ec565b505091949091935091611705565b87809295508193503d8311611834575b61182181836126ec565b81010312610652575191839060e06116d0565b503d611817565b505081813d8311611865575b61185181836126ec565b8101031261065257858a6116bc9251611643565b503d611847565b60405163ba69cfd960e01b81526001600160a01b038a166004820152602481018b90526044810191909152606490fd5b90508581813d83116118c2575b6118b381836126ec565b8101031261065257513861160c565b503d6118a9565b503461011a578060031936011261011a576004546040516001600160a01b039091168152602090f35b503461011a57604036600319011261011a5760043561190f61265e565b61191882612cb4565b60018060a01b0390816003541691806006541690806007541691604051809363273267a360e11b825287600483015281602460209687935afa9081156107d6578891611bf5575b5080611bc55750604051916375e5231b60e01b83528660048401528760248401528383604481895afa9283156107d6578785918a95611b92575b50604051606089901b6001600160601b0319168382019081526014810196909652611a0e956119f39082906034015b036119db601f19918281018552846126ec565b8a6102c487600254169460405196879389850161272d565b60405180809781946345ed59e560e01b835260048301612760565b03915afa9283156107d6578893611b62575b5060e060249160055416604051928380926337f80ad760e11b82528760048301525afa9081156107d657611a719189908a8b91611b29575b6001600160801b039293509061ffff61171a921661279d565b4211611b1057908187923b156106e157604051637ca3fa7360e01b815233600482015260248101929092526001600160601b038516604483015282908290606490829084905af180156105cc57611afc575b50507f94bb2d6c0b0156b69860650cb41ebb691db20169e5ea6b8d02e791fd32213740916001600160601b0360405191168152a3604051f35b611b059061268a565b610df3578438611ac3565b60405163f72d5efd60e01b815260048101879052602490fd5b5050506001600160801b0361171a611b5261ffff9360e03d60e0116108b3576108a181836126ec565b5092955085945092509050611a58565b9092508381813d8311611b8b575b611b7a81836126ec565b8101031261065257519160e0611a20565b503d611b70565b94505083813d8311611bbe575b611ba981836126ec565b810103126106525791519183876119c8611999565b503d611b9f565b60405163ba69cfd960e01b81526001600160a01b0387166004820152602481018890526044810191909152606490fd5b90508381813d8311611c1b575b611c0c81836126ec565b8101031261065257513861195f565b503d611c02565b503461011a578060031936011261011a57611c68604051611c42816126b4565b60058152640312e302e360dc1b6020820152604051918291602083526020830190612639565b0390f35b503461011a576020806003193601126106dd5760043591611c8c83612cb4565b60018060a01b03806003541692816005541691806007541692604051936375e5231b60e01b8552876004860152602494868682015284816044818b5afa90811561079f578886928b928a916121c3575b50611d3b96611d14926102c46119f393604051958691848a840190916034926001600160601b03199060601b16825260148201520190565b0392611d28601f19948581018852876126ec565b600254169460405196879389850161272d565b03915afa9283156108ba578693612194575b506040516337f80ad760e11b81526004810184905260e0818781865afa801561079f5790611d97918890898a91611b29576001600160801b039293509061ffff61171a921661279d565b421161217c5760405163273267a360e11b8152600481018990529184838781855afa92831561079f57879361214d575b5060405163fef57daf60e01b808252600482018b905293868289818d5afa918215612142578992612113575b50611e20576040516340501bd760e01b81526001600160a01b038a166004820152602481018b9052604490fd5b6040999799989698518681019086825282604082015260408152611e43816126d0565b519020604051906315ce5a4560e01b8252600482015286818b81865afa908115610f12578b916120e6575b504211156120c35750908892916040519463044c990b60e41b865280600487015286868b81855afa9586156108f957859661208c575b50813b15610df3576040519063e25aa72560e01b82526004820152848a820152848160448183865af19081156108f9578591612078575b5050803b156105c857836001600160601b0360448b97836040519586948593632c640e6d60e01b855233600486015216809b8401525af1908115610618578491612064575b5050803b156106e15760405163a021d76d60e01b81526004810188905283818a8183865af1908115610618578491612050575b5050803b156106e1578280918960405180968193635498a1d160e11b83528c60048401525af192831561204357859361202a575b5050604051968791825286600483015281865afa9485156108ba578695611fd9575b50907fbf781c6dda1607f992095470fe21fac1ed7628c89a45ca78b7dfde2ed2e72b3b91604051908152a4604051f35b918091955082813d8311612023575b611ff281836126ec565b81010312610652579051937fbf781c6dda1607f992095470fe21fac1ed7628c89a45ca78b7dfde2ed2e72b3b611fa9565b503d611fe8565b6120369192935061268a565b61076c5782908738611f87565b50604051903d90823e3d90fd5b6120599061268a565b6106e1578238611f53565b61206d9061268a565b6106e1578238611f20565b6120819061268a565b6105c8578338611edb565b9095508681813d83116120bc575b6120a481836126ec565b81010312610df3576120b5906127e1565b9438611ea4565b503d61209a565b86606491898b6040519363343304af60e01b855260048501528301526044820152fd5b90508681813d831161210c575b6120fd81836126ec565b81010312610652575138611e6e565b503d6120f3565b9091508681813d831161213b575b61212b81836126ec565b8101031261065257519038611df3565b503d612121565b6040513d8b823e3d90fd5b9092508481813d8311612175575b61216581836126ec565b8101031261065257519138611dc7565b503d61215b565b60405163f72d5efd60e01b8152600481018990528590fd5b9092508381813d83116121bc575b6121ac81836126ec565b8101031261065257519138611d4d565b503d6121a2565b96939250505084813d83116121f5575b6121dd81836126ec565b81010312610652579251849089908990611d3b611cdc565b503d6121d3565b503461011a578060031936011261011a576001546040516001600160a01b039091168152602090f35b503461011a578060031936011261011a57546040516001600160a01b039091168152602090f35b503461011a5761010036600319011261011a576024356001600160801b03811681036106dd5760443563ffffffff811681036106e1576064356001600160601b0380821682036106525760843561ffff811681036107be5760a43591821682036106525760c4359260ff8416840361076c5760e4359485151586036107f55761157d96600435612916565b503461011a57604036600319011261011a576004356122f461265e565b6122fd82612cb4565b60018060a01b038060035416918160065416826007541692604051809463273267a360e11b825287600483015281602460209788935afa9081156107d6578891612574575b501561254c57604051906375e5231b60e01b82528660048301528760248301528482604481895afa9182156107d6578786918a94612519575b50604051606089901b6001600160601b03191683820190815260148101959095526123c9946123ae9082906034016119c8565b60405180809681946345ed59e560e01b835260048301612760565b03915afa9182156107d65788926124e9575b5060e060249160055416604051928380926337f80ad760e11b82528660048301525afa9081156107d65761242b9189908a8b91611b29576001600160801b039293509061ffff61171a921661279d565b4211611b10578690823b156106dd576040516357856ce160e11b815233600482015260248101919091526001600160601b0384166044820152918290606490829084905af180156108ba576124b4575b50907ff70a2f6971e3b06b83151f5a9b7dc691b79b15e828db0adcf68dc8f97cd29997916001600160601b0360405191168152a3604051f35b946124e17ff70a2f6971e3b06b83151f5a9b7dc691b79b15e828db0adcf68dc8f97cd2999793929661268a565b94909161247b565b9091508481813d8311612512575b61250181836126ec565b810103126107f557519060e06123db565b503d6124f7565b93505082813d8311612545575b61253081836126ec565b810103126107f55790519084876119c861237b565b503d612526565b6040516340501bd760e01b81526001600160a01b038616600482015260248101879052604490fd5b90508481813d831161259a575b61258b81836126ec565b810103126107f5575138612342565b503d612581565b503461011a578060031936011261011a576002546040516001600160a01b039091168152602090f35b9050346106dd57816003193601126106dd57806125e9611c68926126b4565b600c81526b10dbdb9d195b9d105cdcd95d60a21b6020820152604051918291602083526020830190612639565b60005b8381106126295750506000910152565b8181015183820152602001612619565b9060209161265281518092818552858086019101612616565b601f01601f1916010190565b602435906001600160601b038216820361065257565b60a435906001600160601b038216820361065257565b67ffffffffffffffff811161269e57604052565b634e487b7160e01b600052604160045260246000fd5b6040810190811067ffffffffffffffff82111761269e57604052565b6060810190811067ffffffffffffffff82111761269e57604052565b90601f8019910116810190811067ffffffffffffffff82111761269e57604052565b9081602091031261065257516001600160a01b03811681036106525790565b9091603493926001600160601b03199060601b168252601482015261275b8251809360208685019101612616565b010190565b90604061277892600181528160208201520190612639565b90565b51906001600160801b038216820361065257565b519060ff8216820361065257565b6001600160801b0391828092169182911692048211811515166127be570290565b634e487b7160e01b600052601160045260246000fd5b919082018092116127be57565b51906001600160601b038216820361065257565b519061ffff8216820361065257565b9160e083830312610652578251926020916128208383016127f5565b9361282d6040840161277b565b9381607f850112156106525760405191612846836126b4565b8260a0860193828511610652578360608801915b8683106128b057505050948160bf82011215610652576040519361287d856126b4565b60e085920192831161065257905b828210612899575050505090565b8380916128a58461278f565b81520191019061288b565b81906128bb846127e1565b815201910190849061285a565b929363ffffffff6001600160601b039296956001600160801b036060956080880199885216602087015216604085015216910152565b90816020910312610652575180151581036106525790565b600354604051636db6095560e01b8152919891976001600160a01b039091169660009690959194909360208a6004818b8d5af1998a156107d657889a612c80575b50883b156107f5576040516340c10f1960e01b8152336004820152602481018b90528881604481838e5af1801561214257612c6d575b506001546001600160a01b031690813b15612c695790889291838d6129c860405197889687958694635c1c1c7960e11b8652600486016128c8565b03925af180156108ba57908691612c55575b5050853b15610df35760405163eaeb169560e01b81528760048201528860248201523360448201528581606481838b5af180156108ba57908691612c41575b5050853b15610df3576040516312d540c560e01b81526004810188905290151560248201528481604481838a5af180156108f957908591612c2d575b5050843b156105c85760405163367bcd9f60e01b81528660048201528760248201528481604481838a5af180156108f957908591612c19575b5050600654604051606087901b6001600160601b031916602082015260348082018a905281526001600160a01b039091169290612acc6054826126ec565b60405194610100860186811067ffffffffffffffff82111761269e5760ff946001600160601b039361ffff926040523389528a60208a01528b60408a01526060890152600160808901521660a08701521660c08501521660e0830152803b156106e1578291829160405180948180946370ab967360e11b82526020600483015260018060a01b03815116602483015260018060a01b0360208201511660448301526040810151606483015260ff60e0612b9660608401516101006084870152610124860190612639565b928260808201511660a486015261ffff60a08201511660c48601526001600160601b0360c08201511660e486015201511661010483015203925af180156105cc57612c05575b507f60e45db7c8cb9f55f92f3de18053b0b426eb919a763a1daca0ea9ad20961e87890604051a4565b612c0f829161268a565b61011a5738612bdc565b612c229061268a565b6105c8578338612a8e565b612c369061268a565b6105c8578338612a55565b612c4a9061268a565b610df3578438612a19565b612c5e9061268a565b610df35784386129da565b8880fd5b612c799098919861268a565b963861298d565b9099506020813d602011612cac575b81612c9c602093836126ec565b810103126107f557519838612957565b3d9150612c8f565b6003546040516331a9108f60e11b815260048101929092526001600160a01b0391906020908290602490829086165afa908115612d5f57600091612d41575b50163303612cfd57565b606460405162461bcd60e51b815260206004820152602060248201527f4f6e6c79206173736574206f776e65722063616e20757365207468697320666e6044820152fd5b612d59915060203d81116113df576113d081836126ec565b38612cf3565b6040513d6000823e3d90fdfea26469706673582212206d56174992a7bb3955e147b99a7ff4d3e61b49283e82e8a8ff690d751e3947a364736f6c63430008100033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 10767,
        "contract": "contracts/assets/ContentAsset.sol:ContentAsset",
        "label": "hub",
        "offset": 0,
        "slot": "0",
        "type": "t_contract(Hub)6314"
      },
      {
        "astId": 10942,
        "contract": "contracts/assets/ContentAsset.sol:ContentAsset",
        "label": "assertionContract",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(Assertion)3104"
      },
      {
        "astId": 10945,
        "contract": "contracts/assets/ContentAsset.sol:ContentAsset",
        "label": "hashingProxy",
        "offset": 0,
        "slot": "2",
        "type": "t_contract(HashingProxy)6053"
      },
      {
        "astId": 10948,
        "contract": "contracts/assets/ContentAsset.sol:ContentAsset",
        "label": "contentAssetStorage",
        "offset": 0,
        "slot": "3",
        "type": "t_contract(ContentAssetStorage)18569"
      },
      {
        "astId": 10951,
        "contract": "contracts/assets/ContentAsset.sol:ContentAsset",
        "label": "parametersStorage",
        "offset": 0,
        "slot": "4",
        "type": "t_contract(ParametersStorage)13997"
      },
      {
        "astId": 10954,
        "contract": "contracts/assets/ContentAsset.sol:ContentAsset",
        "label": "serviceAgreementStorageProxy",
        "offset": 0,
        "slot": "5",
        "type": "t_contract(ServiceAgreementStorageProxy)15987"
      },
      {
        "astId": 10957,
        "contract": "contracts/assets/ContentAsset.sol:ContentAsset",
        "label": "serviceAgreementV1",
        "offset": 0,
        "slot": "6",
        "type": "t_contract(ServiceAgreementV1)9030"
      },
      {
        "astId": 10960,
        "contract": "contracts/assets/ContentAsset.sol:ContentAsset",
        "label": "unfinalizedStateStorage",
        "offset": 0,
        "slot": "7",
        "type": "t_contract(UnfinalizedStateStorage)18228"
      }
    ],
    "types": {
      "t_contract(Assertion)3104": {
        "encoding": "inplace",
        "label": "contract Assertion",
        "numberOfBytes": "20"
      },
      "t_contract(ContentAssetStorage)18569": {
        "encoding": "inplace",
        "label": "contract ContentAssetStorage",
        "numberOfBytes": "20"
      },
      "t_contract(HashingProxy)6053": {
        "encoding": "inplace",
        "label": "contract HashingProxy",
        "numberOfBytes": "20"
      },
      "t_contract(Hub)6314": {
        "encoding": "inplace",
        "label": "contract Hub",
        "numberOfBytes": "20"
      },
      "t_contract(ParametersStorage)13997": {
        "encoding": "inplace",
        "label": "contract ParametersStorage",
        "numberOfBytes": "20"
      },
      "t_contract(ServiceAgreementStorageProxy)15987": {
        "encoding": "inplace",
        "label": "contract ServiceAgreementStorageProxy",
        "numberOfBytes": "20"
      },
      "t_contract(ServiceAgreementV1)9030": {
        "encoding": "inplace",
        "label": "contract ServiceAgreementV1",
        "numberOfBytes": "20"
      },
      "t_contract(UnfinalizedStateStorage)18228": {
        "encoding": "inplace",
        "label": "contract UnfinalizedStateStorage",
        "numberOfBytes": "20"
      }
    }
  }
}
