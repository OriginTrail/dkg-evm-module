sequenceDiagram
actor D3 as Delegator3
actor D2 as Delegator2
actor D1 as Delegator1
participant S as Staking
participant SS as StakingStorage
participant N as Node1
participant RS as RandomSampling
participant RSS as RandomSamplingStorage

autonumber

Note over S, N: Initial State (Epoch 1): <br><br> Node1 <br> - N1.totalNodeStake: 0 <br> - N1.nodeEpochScorePerStake (epoch 1): 0 <br> - N1.epochScore (epoch 1): 0 <br><br> Delegator 1 <br> - D1.stakeBase (on N1): 0 <br> - D1.epochScore (on N1, epoch 1): 0 <br> - D1.lastSettledNodeEpochScorePerStake (on N1, epoch 1): 0 <br> - D1.lastClaimedEpoch: 0 <br><br> AllNodesEpochScore (epoch 1): 0

rect LightBlue
    Note over D1, RSS: Step 1: Delegator1 delegates 10,000 TRAC to Node 1 (Epoch 1)
    D1 ->> S: calls stake(N1_id, 10_000)

    Note over S: Check if D1 has some epochs that they didn't claim for
    alt D1.lastClaimedEpoch != currentEpoch - 1:
        Note over S: D1 has some unclaimed epoch rewards. Check if D1 has only 1 or more epochs that they didnt claim for
        alt (currentEpoch - 1) - D1.lastClaimedEpoch > 1:
            Note over S: There is more than 1 epoch that D1 needs to claim rewards for
            Note over S: REVERT: "Must claim all previous epoch rewards before changing stake"
            S -->> D1: Transaction reverted
        else
            Note over S: D1 didn't claim for only one epoch. Check if rewards for this delegator even exist in the unclaimed epoch
            alt If D1.epochScore(currentEpoch - 1) == 0 && (N1.nodeEpochScorePerStake(currentEpoch - 1) - D1.lastSettledNodeEpochScorePerStake(currentEpoch - 1))  == 0:
                Note over S: D1 has no rewards to claim for epoch 0 (currentEpoch - 1) --> set last claimed epoch for D1 to 0 (currentEpoch - 1)
                S ->> RSS: set D1.lastClaimedEpoch = currentEpoch - 1 = 0
            else:
                Note over S: D1 didn't claim their reward for currentEpoch - 1 (epoch 0)
                Note over S: REVERT: "Must claim all previous epoch rewards before changing stake"
                S -->> D1: Transaction reverted
            end
        end
    end
    
    rect LightYellow
        Note over S, RS: Phase 1: Settle D1's score before stake change
        S ->> RS: calls prepareForStakeChange(epoch 1, N1_id, D1_key)
        RS ->> RSS: get N1.nodeEpochScorePerStake (epoch 1) (is 0)
        RS ->> RSS: get D1.lastSettledNodeEpochScorePerStake (epoch 1) (is 0)
        RS ->> RSS: get D1.stakeBase (epoch 1) (is 0)
        Note over RS: scoreEarned = D1.stakeBase * (N1.nodeEpochScorePerStake - D1.lastSettledNodeEpochScorePerStake) = 0 * (0 - 0) = 0
        RS ->> RSS: set D1.epochScore (epoch 1) = 0 + 0 = 0
        RS ->> RSS: set D1.lastSettledNodeEpochScorePerStake (epoch 1) = 0
        RS ->> RSS: set D1.stakeBase (epoch 1) = 10_000 (new stake)
    end

    rect LightYellow
        Note over S, SS: Phase 2: StakingStorage updates stake
        S ->> SS: setDelegatorStakeInfo(N1_id, D1_key, base=10_000, indexed=0)
        S ->> SS: setNodeStake(N1_id, 10_000)
        S ->> SS: increase totalStake by 10_000
        D1 ->> SS: Delegator1 transfers 10_000 TRAC to StakingStorage
    end
end

Note over S, N: State after Step 1 (Epoch 1): <br><br> Node1 <br> - N1.totalNodeStake: 10_000 <br> - N1.nodeEpochScorePerStake (epoch 1): 0 <br> - N1.epochScore (epoch 1): 0 <br><br> Delegator 1 <br> - D1.stakeBase (on N1): 10_000 <br> - D1.epochScore (on N1, epoch 1): 0 <br> - D1.lastSettledNodeEpochScorePerStake (on N1, epoch 1): 0 <br> - D1.lastClaimedEpoch: 0 <br><br> Delegator 2: D2.lastClaimedEpoch: 0 <br> Delegator 3: D3.lastClaimedEpoch: 0

rect LightBlue
    Note over D2, RSS: Step 2: Delegator2 delegates 20,000 TRAC to Node 1 (Epoch 1)
    D2 ->> S: calls stake(N1_id, 20_000)

    Note over S: Check if D2 has some epochs that they didn't claim for
    alt D2.lastClaimedEpoch != currentEpoch - 1:
        Note over S: rest of the checks...
    end
    Note over S: D2.lastClaimedEpoch == currentEpoch - 1  -->  0 == 1 - 1 ✅
    
    rect LightYellow
        Note over S, RS: Phase 1: Settle D2's score before stake change
        S ->> RS: calls prepareForStakeChange(epoch 1, N1_id, D2_key)
        RS ->> RSS: get N1.nodeEpochScorePerStake (epoch 1) (is 0)
        RS ->> RSS: get D2.lastSettledNodeEpochScorePerStake (epoch 1) (is 0)
        RS ->> RSS: get D2.stakeBase (epoch 1) (is 0)
        Note over RS: scoreEarned = D2.stakeBase * (N1.nodeEpochScorePerStake - D2.lastSettledNodeEpochScorePerStake) = 0 * (0 - 0) = 0
        RS ->> RSS: set D2.epochScore (epoch 1) = 0
        RS ->> RSS: set D2.lastSettledNodeEpochScorePerStake (epoch 1) = 0
        RS ->> RSS: set D2.stakeBase (epoch 1) = 20_000
    end

    rect LightYellow
        Note over S, SS: Phase 2: StakingStorage updates stake
        S ->> SS: setDelegatorStakeInfo(N1_id, D2_key, base=20_000, indexed=0)
        S ->> SS: setNodeStake(N1_id, 30_000)
        S ->> SS: increase totalStake by 20_000
        D2 ->> SS: Delegator2 transfers 20_000 TRAC to StakingStorage
    end
end

Note over S, N: State after Step 2 (Epoch 1): <br><br> Node1 <br> - N1.totalNodeStake: 30_000 <br> - N1.nodeEpochScorePerStake (epoch 1): 0 <br> - N1.epochScore (epoch 1): 0 <br><br> Delegator 1 <br> - D1.stakeBase: 10_000, D1.epochScore: 0 <br> - D1.lastClaimedEpoch: 0 <br><br> Delegator 2 <br> - D2.stakeBase: 20_000, D2.epochScore: 0 <br> - D2.lastClaimedEpoch: 0 <br><br> Delegator 3: D3.lastClaimedEpoch: 0

rect LightBlue
    Note over D3, RSS: Step 3: Delegator3 delegates 30,000 TRAC to Node 1 (Epoch 1)
    D3 ->> S: calls stake(N1_id, 30_000)
    
    Note over S: Check if D3 has some epochs that they didn't claim for
    alt D3.lastClaimedEpoch != currentEpoch - 1:
        Note over S: rest of the checks...
    end
    Note over S: D3.lastClaimedEpoch == currentEpoch - 1  -->  0 == 1 - 1 ✅

    rect LightYellow
        Note over S, RS: Phase 1: Settle D3's score before stake change
        S ->> RS: calls prepareForStakeChange(epoch 1, N1_id, D3_key)
        RS ->> RSS: get N1.nodeEpochScorePerStake (epoch 1) (is 0)
        RS ->> RSS: get D3.lastSettledNodeEpochScorePerStake (epoch 1) (is 0)
        RS ->> RSS: get D3.stakeBase (epoch 1) (is 0)
        Note over RS: scoreEarned = D3.stakeBase * (N1.nodeEpochScorePerStake - D3.lastSettledNodeEpochScorePerStake) = 0 * (0 - 0) = 0
        RS ->> RSS: set D3.epochScore (epoch 1) = 0
        RS ->> RSS: set D3.lastSettledNodeEpochScorePerStake (epoch 1) = 0
        RS ->> RSS: set D3.stakeBase (epoch 1) = 30_000
    end

    rect LightYellow
        Note over S, SS: Phase 2: StakingStorage updates stake
        S ->> SS: setDelegatorStakeInfo(N1_id, D3_key, base=30_000, indexed=0)
        S ->> SS: setNodeStake(N1_id, 60_000)
        S ->> SS: increase totalStake by 30_000
        D3 ->> SS: Delegator3 transfers 30_000 TRAC to StakingStorage
    end
end

Note over S, N: State after Step 3 (Epoch 1): <br><br> Node1 <br> - N1.totalNodeStake: 60_000 <br> - N1.nodeEpochScorePerStake (epoch 1): 0 <br> - N1.epochScore (epoch 1): 0 <br><br> Delegator 1: D1.stakeBase: 10_000, D1.lastClaimedEpoch: 0 <br> Delegator 2: D2.stakeBase: 20_000, D2.lastClaimedEpoch: 0 <br> Delegator 3: D3.stakeBase: 30_000, D3.lastClaimedEpoch: 0

rect LightBlue
    Note over SS, RSS: Step 4: Node 1 submits proof (Epoch 1)
    N ->> RS: executes submitProof(chunk, merkleProof)
    Note over RS: Node 1 score = 0.006 (calculated based on 60k stake)
    RS ->> SS: getNodeStake(N1_id) (returns 60_000)
    Note over RS: nodeScorePerStake = 0.006 / 60_000 = 0.0000001
    RS ->> RSS: N1.nodeEpochScorePerStake (epoch 1) += 0.0000001
    RS ->> RSS: N1.epochScore (epoch 1) += 0.006
    RS ->> RSS: AllNodesEpochScore (epoch 1) += 0.006
end

Note over S, N: State after Step 4 (Epoch 1): <br><br> Node1 <br> - N1.totalNodeStake: 60_000 <br> - N1.nodeEpochScorePerStake (epoch 1): 0.0000001 <br> - N1.epochScore (epoch 1): 0.006 <br><br> All delegators still have unsettled scores for this proof period

rect LightBlue
    Note over D1, RSS: Step 5: Delegator1 delegates 10,000 more TRAC to Node 1 (Epoch 1)
    D1 ->> S: calls stake(N1_id, 10_000)
    
    Note over S: Check if D1 has some epochs that they didn't claim for
    alt D1.lastClaimedEpoch != currentEpoch - 1:
        Note over S: rest of the checks...
    end
    Note over S: D1.lastClaimedEpoch == currentEpoch - 1  -->  0 == 1 - 1 ✅

    rect LightYellow
        Note over S, RS: Phase 1: Settle D1's score before stake change
        S ->> RS: calls prepareForStakeChange(epoch 1, N1_id, D1_key) settle final score
        RS ->> RSS: get N1.nodeEpochScorePerStake (epoch 1) (is 0.0000001)
        RS ->> RSS: get D1.lastSettledNodeEpochScorePerStake (epoch 1) (is 0)
        RS ->> RSS: get D1.stakeBase (epoch 1) (is 10_000)
        Note over RS: scoreEarned = D1.stakeBase * (N1.nodeEpochScorePerStake - D1.lastSettledNodeEpochScorePerStake) = 10_000 * (0.0000001 - 0) = 0.001
        RS ->> RSS: set D1.epochScore (epoch 1) = 0 + 0.001 = 0.001
        RS ->> RSS: set D1.lastSettledNodeEpochScorePerStake (epoch 1) = 0.0000001
        RS ->> RSS: set D1.stakeBase (epoch 1) = 20_000 (new total stake)
    end

    rect LightYellow
        Note over S, SS: Phase 2: StakingStorage updates stake
        S ->> SS: setDelegatorStakeInfo(N1_id, D1_key, base=20_000, indexed=0)
        S ->> SS: setNodeStake(N1_id, 70_000)
        S ->> SS: increase totalStake by 10_000
        D1 ->> SS: Delegator1 transfers 10_000 TRAC to StakingStorage
    end
end

Note over S, N: State after Step 5 (Epoch 1): <br><br> Node1 <br> - N1.totalNodeStake: 70_000 <br> - N1.nodeEpochScorePerStake (epoch 1): 0.0000001 <br> - N1.epochScore (epoch 1): 0.006 <br><br> Delegator 1: D1.stakeBase: 20_000, D1.epochScore (epoch 1): 0.001, D1.lastClaimedEpoch: 0 <br> Delegator 2: D2.epochScore (epoch 1): 0 (unsettled), D2.lastClaimedEpoch: 0 <br> Delegator 3: D3.epochScore (epoch 1): 0 (unsettled), D3.lastClaimedEpoch: 0

rect LightBlue
    Note over SS, RSS: Step 6: Node 1 submits second proof (Epoch 1)
    N ->> RS: executes submitProof(chunk, merkleProof)
    Note over RS: Node 1 score = 0.007 (calculated based on 70k stake)
    RS ->> SS: getNodeStake(N1_id) (returns 70_000)
    Note over RS: nodeScorePerStake = 0.007 / 70_000 = 0.0000001
    RS ->> RSS: N1.nodeEpochScorePerStake (epoch 1) += 0.0000001 = 0.0000002
    RS ->> RSS: N1.epochScore (epoch 1) += 0.007 = 0.013
    RS ->> RSS: AllNodesEpochScore (epoch 1) += 0.007 = 0.013
end

Note over S, N: State after Step 6 (Epoch 1): <br><br> Node1 <br> - N1.totalNodeStake: 70_000 <br> - N1.nodeEpochScorePerStake (epoch 1): 0.0000002 <br> - N1.epochScore (epoch 1): 0.013 <br><br> Delegator 1: D1.epochScore (epoch 1): 0.001 (settled up to first proof), D1.lastClaimedEpoch: 0 <br> Delegator 2: D2.epochScore (epoch 1): 0 (unsettled for both proofs), D2.lastClaimedEpoch: 0 <br> Delegator 3: D3.epochScore (epoch 1): 0 (unsettled for both proofs), D3.lastClaimedEpoch: 0

rect LightBlue
    Note over D2, RSS: <br> Advance to epoch 2... <br>
end

rect LightBlue
    Note over D1, RSS: Step 7: Delegator1 claims reward for epoch 1 - totalEpochFees = 3900 TRAC
    D1 ->> S: calls claimDelegatorReward(N1_id, epoch 1, D1_address)

    Note over S: Check if D1 has some epochs that they didn't claim for
    alt If D1.lastClaimedEpoch == currentEpoch - 1 (0 == 2 - 1) ❌
        Note over S: REVERT: "Delegator has already claimed rewards for all finalized epochs"
        S -->> D1: Transaction reverted
    else:
        Note over S: Check if delegator is claiming for the oldes unclaimed epoch first (lastClaimedEpoch + 1) and not some epoch newer than that
        alt If D1.lastClaimedEpoch + 1 != epochDelegatorWantsToClaimFor (0 + 1 != 1) ❌
            Note over S: REVERT: "Delegator has older epochs that they didn't claim rewards for"
            S -->> D1: Transaction reverted
        end
    end

    Note over S: Calculate Node 1 total reward = 3900 TRAC
    Note over S: rewardsForDelegators = 3900 TRAC (assume 0 operator fee)

    Note over S, RS: Settle Delegator1's final score for epoch 1
    S ->> RS: calls prepareForStakeChange(epoch 1, N1_id, D1_key) settle final score
    RS ->> RSS: get N1.nodeEpochScorePerStake (epoch 1) (is 0.0000002)
    RS ->> RSS: get D1.lastSettledNodeEpochScorePerStake (epoch 1) (is 0.0000001)
    RS ->> RSS: get D1.stakeBase (epoch 1) (is 20_000)
    Note over RS: scoreEarned = D1.stakeBase * (N1.nodeEpochScorePerStake - D1.lastSettledNodeEpochScorePerStake) = 20_000 * (0.0000002 - 0.0000001) = 0.002
    RS ->> RSS: set D1.epochScore (epoch 1) = 0.001 + 0.002 = 0.003
    RS ->> RSS: set D1.lastSettledNodeEpochScorePerStake (epoch 1) = 0.0000002
    RS -->> S: returns D1.epochScore (epoch 1) = 0.003

    Note over S: totalNodeScoreForEpoch1 = N1.epochScore (epoch 1) = 0.013
    Note over S: D1_reward_share = (0.003 / 0.013) * 3900 = 900 TRAC
    S ->> SS: update D1.stakeBase += 900 (20_000 + 900 = 20_900)
    S ->> SS: update N1.totalNodeStake += 900
    S ->> SS: increase totalStake by 900
    S ->> RSS: set D1.lastClaimedEpoch = 1
end

Note over S, N: State after Step 7 (D1 claims epoch 1 rewards): <br><br> Node1 <br> - N1.totalNodeStake: 70_900 <br><br> Delegator 1 <br> - D1.stakeBase: 20_900 <br> - D1.epochScore (epoch 1): 0.003 (final) <br> - D1.lastClaimedEpoch: 1 <br><br> Delegator 2: D2.stakeBase: 20_000, D2.epochScore (epoch 1): 0 (still unsettled), D2.lastClaimedEpoch: 0 <br> Delegator 3: D3.stakeBase: 30_000, D3.epochScore (epoch 1): 0 (still unsettled), D3.lastClaimedEpoch: 0

rect LightBlue
    Note over D2, RSS: Step 8: Delegator2 claims reward for epoch 1 - totalEpochFees = 3900 TRAC
    D2 ->> S: calls claimDelegatorReward(N1_id, epoch 1, D2_address)

    Note over S: Check if D2 has some epochs that they didn't claim for
    alt If D2.lastClaimedEpoch == currentEpoch - 1 (0 == 2 - 1) ❌
        Note over S: REVERT: "Delegator has already claimed rewards for all finalized epochs"
        S -->> D2: Transaction reverted
    else:
        Note over S: Check if delegator is claiming for the oldes unclaimed epoch first (lastClaimedEpoch + 1) and not some epoch newer than that
        alt If D2.lastClaimedEpoch + 1 != epochDelegatorWantsToClaimFor (0 + 1 != 1) ❌
            Note over S: REVERT: "Delegator has older epochs that they didn't claim rewards for"
            S -->> D2: Transaction reverted
        end
    end

    Note over S: Calculate Node 1 total reward = 3900 TRAC
    Note over S: rewardsForDelegators = 3900 TRAC

    Note over S, RS: Settle Delegator2's final score for epoch 1
    S ->> RS: calls prepareForStakeChange(epoch 1, N1_id, D2_key)
    RS ->> RSS: get N1.nodeEpochScorePerStake (epoch 1) (is 0.0000002)
    RS ->> RSS: get D2.lastSettledNodeEpochScorePerStake (epoch 1) (is 0)
    RS ->> RSS: get D2.stakeBase (epoch 1) (is 20_000)
    Note over RS: scoreEarned = D2.stakeBase * (N1.nodeEpochScorePerStake - D2.lastSettledNodeEpochScorePerStake) = 20_000 * (0.0000002 - 0) = 0.004
    RS ->> RSS: set D2.epochScore (epoch 1) = 0 + 0.004 = 0.004
    RS ->> RSS: set D2.lastSettledNodeEpochScorePerStake (epoch 1) = 0.0000002
    RS -->> S: returns D2.epochScore (epoch 1) = 0.004

    Note over S: D2_reward_share = (0.004 / 0.013) * 3900 = 1200 TRAC
    S ->> SS: update D2.stakeBase += 1200 (20_000 + 1200 = 21_200)
    S ->> SS: update N1.totalNodeStake += 1200
    S ->> SS: increase totalStake by 1200
    S ->> RSS: set D2.lastClaimedEpoch = 1
end

Note over S, N: State after Step 8 (D2 claims epoch 1 rewards): <br><br> Node1 <br> - N1.totalNodeStake: 72_100 <br><br> Delegator 1: D1.stakeBase: 20_900, D1.lastClaimedEpoch: 1 <br> Delegator 2: D2.stakeBase: 21_200, D2.epochScore (epoch 1): 0.004 (final), D2.lastClaimedEpoch: 1 <br> Delegator 3: D3.stakeBase: 30_000, D3.epochScore (epoch 1): 0 (still unsettled), D3.lastClaimedEpoch: 0

rect LightBlue
    Note over D3, RSS: Step 9: Delegator3 tries to request withdrawal of 5,000 TRAC (Epoch 2) - SHOULD REVERT
    D3 ->> S: calls requestWithdrawal(N1_id, 5_000)

    Note over S: Check if D3 has some epochs that they didn't claim for
    alt D3.lastClaimedEpoch != currentEpoch - 1 (0 != 2 - 1) ✅
        Note over S: D3 has some unclaimed epoch rewards. Check if D3 has only 1 or more epochs that they didnt claim for
        alt (currentEpoch - 1) - D3.lastClaimedEpoch > 1 (2 - 1 - 0 > 1) ❌
            Note over S: There is more than 1 epoch that D3 needs to claim rewards for
            Note over S: REVERT: "Must claim all previous epoch rewards before changing stake"
            S -->> D3: Transaction reverted
        else
            Note over S: D3 didn't claim for only one epoch. Check if rewards for this delegator even exist in the unclaimed epoch
            alt If D3.epochScore(currentEpoch - 1) == 0 && (N1.nodeEpochScorePerStake(currentEpoch - 1) - D3.lastSettledNodeEpochScorePerStake(currentEpoch - 1)) (0 == 0 && 0.0000002 - 0 == 0) ❌
                Note over S: D3 has no rewards to claim for epoch 0 (currentEpoch - 1) --> set last claimed epoch for D3 to 0 (currentEpoch - 1)
                S ->> RSS: set D3.lastClaimedEpoch = currentEpoch - 1 = 0
            else:
                Note over S: D3 didn't claim their reward for currentEpoch - 1 (epoch 1)
                Note over S: REVERT: "Must claim all previous epoch rewards before changing stake"
                S -->> D3: Transaction reverted
            end
        end
    end
end

Note over S, N: State after Step 9 (D3 withdrawal reverted): <br><br> Node1 <br> - N1.totalNodeStake: 72_100 (unchanged) <br><br> Delegator 1: D1.stakeBase: 20_900, D1.lastClaimedEpoch: 1 <br> Delegator 2: D2.stakeBase: 21_200, D2.lastClaimedEpoch: 1 <br> Delegator 3: D3.stakeBase: 30_000, D3.epochScore (epoch 1): 0 (still unsettled), D3.lastClaimedEpoch: 0 <br><br> ❌ D3 cannot change stake until claiming epoch 1 rewards

rect LightBlue
    Note over SS, RSS: Step 10: Node 1 submits proof (Epoch 2)
    N ->> RS: executes submitProof(chunk, merkleProof)
    Note over RS: Node 1 score = 0.0072 (calculated based on 72_100 stake)
    RS ->> SS: getNodeStake(N1_id) (returns 72_100)
    Note over RS: nodeScorePerStake = 0.0072 / 72_100 = 0.0000000998613037
    RS ->> RSS: N1.nodeEpochScorePerStake (epoch 2) += 0.0000000998613037
    RS ->> RSS: N1.epochScore (epoch 2) += 0.0072
    RS ->> RSS: AllNodesEpochScore (epoch 2) += 0.0072
end

Note over S, N: State after Step 10 (Epoch 2): <br><br> Node1 <br> - N1.totalNodeStake: 72_100 <br> - N1.nodeEpochScorePerStake (epoch 2): 0.0000000998613037 <br> - N1.epochScore (epoch 2): 0.0072 <br><br> All delegators have unsettled scores for this proof period

rect LightBlue
    Note over D2, RSS: Step 11: Delegator2 requests withdrawal of 10,000 TRAC (Epoch 2)
    D2 ->> S: calls requestWithdrawal(N1_id, 10_000)

    Note over S: Check if D2 has some epochs that they didn't claim for
    alt D2.lastClaimedEpoch != currentEpoch - 1 (1 != 2 - 1) ❌
        Note over S: Claimed rewards for all possible epochs, no need to check further
    end
    
    rect LightYellow
        Note over S, RS: Phase 1: Settle D2's score before stake change
        S ->> RS: calls prepareForStakeChange(epoch 2, N1_id, D2_key)
        RS ->> RSS: get N1.nodeEpochScorePerStake (epoch 2) (is 0.0000000998613037)
        RS ->> RSS: get D2.lastSettledNodeEpochScorePerStake (epoch 2) (is 0)
        RS ->> RSS: get D2.stakeBase (epoch 2) (is 21_200)
        Note over RS: scoreEarned = D2.stakeBase * (N1.nodeEpochScorePerStake - D2.lastSettledNodeEpochScorePerStake) = 21_200 * (0.0000000998613037 - 0) = 0.00211705963
        RS ->> RSS: set D2.epochScore (epoch 2) = 0.00211705963
        RS ->> RSS: set D2.lastSettledNodeEpochScorePerStake (epoch 2) = 0.0000000998613037
        RS ->> RSS: set D2.stakeBase (epoch 2) = 11_200 (remaining stake)
    end

    rect LightYellow
        Note over S, SS: Phase 2: StakingStorage updates stake
        S ->> SS: setDelegatorStakeInfo(N1_id, D2_key, base=11_200, indexed=0)
        S ->> SS: setNodeStake(N1_id, 62_100)
        S ->> SS: create withdrawal request for 10_000 TRAC
    end
end

Note over S, N: State after Step 11 (D2 requests withdrawal, Epoch 2): <br><br> Node1 <br> - N1.totalNodeStake: 62_100 <br><br> Delegator 1: D1.stakeBase: 20_900, D1.lastClaimedEpoch: 1 <br> Delegator 2: D2.stakeBase: 11_200, D2.lastClaimedEpoch: 1 <br> - D2.stakeBase (epoch 2): 11_200 <br> Delegator 3: D3.stakeBase: 30_000, D3.lastClaimedEpoch: 0

rect LightBlue
    Note over SS, RSS: Step 12: Node 1 submits second proof (Epoch 2)
    N ->> RS: executes submitProof(chunk, merkleProof)
    Note over RS: Node 1 score = 0.0062 (calculated based on 62_100 stake)
    RS ->> SS: getNodeStake(N1_id) (returns 62_100)
    Note over RS: nodeScorePerStake = 0.0062 / 62_100 = 0.0000000998389694
    RS ->> RSS: N1.nodeEpochScorePerStake (epoch 2) += 0.0000000998389694 = 0.0000000998613037 + 0.0000000998389694 =  0.000000199700273
    RS ->> RSS: N1.epochScore (epoch 2) += 0.0062 = 0.0134
    RS ->> RSS: AllNodesEpochScore (epoch 2) += 0.0062 = 0.0134
end

Note over S, N: State after Step 12 (Epoch 2): <br><br> Node1 <br> - N1.totalNodeStake: 62_100 <br> - N1.nodeEpochScorePerStake (epoch 2): 0.000000199700273 <br> - N1.epochScore (epoch 2): 0.0134 <br><br> All delegators have unsettled scores for the second proof period

rect LightBlue
    Note over D2, RSS: <br> Advance to epoch 3... <br>
end

rect LightBlue
    Note over D1, RSS: Step 13: Delegator1 claims reward for epoch 2 - totalEpochFees = 4020 TRAC
    D1 ->> S: calls claimDelegatorReward(N1_id, epoch 2, D1_address)

    Note over S: Check if D1 has some epochs that they didn't claim for
    alt If D1.lastClaimedEpoch == currentEpoch - 1 (1 == 3 - 1) ❌
        Note over S: REVERT: "Delegator has already claimed rewards for all finalized epochs"
        S -->> D1: Transaction reverted
    else:
        Note over S: Check if delegator is claiming for the oldes unclaimed epoch first (lastClaimedEpoch + 1) and not some epoch newer than that
        alt If D1.lastClaimedEpoch + 1 != epochDelegatorWantsToClaimFor (1 + 1 != 2) ❌
            Note over S: REVERT: "Delegator has older epochs that they didn't claim rewards for"
            S -->> D1: Transaction reverted
        end
    end

    Note over S: Calculate Node 1 total reward = 4020 TRAC
    Note over S: rewardsForDelegators = 4020 TRAC

    Note over S, RS: Settle Delegator1's final score for epoch 2
    S ->> RS: calls prepareForStakeChange(epoch 2, N1_id, D1_key)
    RS ->> RSS: get N1.nodeEpochScorePerStake (epoch 2) (is 0.000000199700273)
    RS ->> RSS: get D1.lastSettledNodeEpochScorePerStake (epoch 2) (is 0)
    RS ->> RSS: get D1.stakeBase (epoch 2) (is 20_900)
    Note over RS: scoreEarned = D1.stakeBase * (N1.nodeEpochScorePerStake - D1.lastSettledNodeEpochScorePerStake) = 20_900 * (0.000000199700273 - 0) = 0.0041737357
    RS ->> RSS: set D1.epochScore (epoch 2) = 0.0041737357
    RS ->> RSS: set D1.lastSettledNodeEpochScorePerStake (epoch 2) = 0.000000199700273
    RS -->> S: returns D1.epochScore (epoch 2) = 0.0041737357

    Note over S: D1_reward_share = (0.0041737357 / 0.0134) * 4020 = 1252.12071 TRAC
    S ->> SS: update D1.stakeBase += 1252.12071 (20_900 + 1252.12071 = 22_152.12071)
    S ->> SS: update N1.totalNodeStake += 1252.12071 (62_100 + 1252.12071 = 63_352.12071)
    S ->> SS: increase totalStake by 1252.12071
    S ->> RSS: set D1.lastClaimedEpoch = 2
end

Note over S, N: State after Step 13 (D1 claims epoch 2 rewards): <br><br> Node1 <br> - N1.totalNodeStake: 63_352.12071 <br><br> Delegator 1: D1.stakeBase: 22_152.12071 <br> - D1.epochScore (epoch 2): 0.0041737357 (final), D1.lastClaimedEpoch: 2

rect LightBlue
    Note over D2, RSS: Step 14: Delegator2 claims reward for epoch 2 - totalEpochFees = 4020 TRAC
    D2 ->> S: calls claimDelegatorReward(N1_id, epoch 2, D2_address)

    Note over S: Check if D2 has some epochs that they didn't claim for
    alt If D2.lastClaimedEpoch == currentEpoch - 1 (1 == 3 - 1) ❌
        Note over S: REVERT: "Delegator has already claimed rewards for all finalized epochs"
        S -->> D2: Transaction reverted
    else:
        Note over S: Check if delegator is claiming for the oldes unclaimed epoch first (lastClaimedEpoch + 1) and not some epoch newer than that
        alt If D2.lastClaimedEpoch + 1 != epochDelegatorWantsToClaimFor (1 + 1 != 2) ❌
            Note over S: REVERT: "Delegator has older epochs that they didn't claim rewards for"
            S -->> D2: Transaction reverted
        end
    end

    Note over S: Calculate Node 1 total reward = 4020 TRAC
    Note over S: rewardsForDelegators = 4020 TRAC

    Note over S, RS: Settle Delegator2's final score for epoch 2
    S ->> RS: calls prepareForStakeChange(epoch 2, N1_id, D2_key)
    RS ->> RSS: get N1.nodeEpochScorePerStake (epoch 2) (is 0.000000199700273)
    RS ->> RSS: get D2.lastSettledNodeEpochScorePerStake (epoch 2) (is 0.0000000998613037)
    RS ->> RSS: get D2.stakeBase (epoch 2) (is 11_200)
    Note over RS: scoreEarned = D2.stakeBase * (N1.nodeEpochScorePerStake - D2.lastSettledNodeEpochScorePerStake) = 11_200 * (0.000000199700273 - 0.0000000998613037) = 0.00111819645
    RS ->> RSS: set D2.epochScore (epoch 2) = 0.00211705963 + 0.00111819645 = 0.00323525608
    RS ->> RSS: set D2.lastSettledNodeEpochScorePerStake (epoch 2) = 0.000000199700273
    RS -->> S: returns D2.epochScore (epoch 2) = 0.00323525608

    Note over S: D2_reward_share = (0.00323525608 / 0.0134) * 4020 = 970.576824 TRAC
    S ->> SS: update D2.stakeBase += 970.576824 (11_200 + 970.576824 = 12_170.576824)
    S ->> SS: update N1.totalNodeStake += 970.576824 (63_352.12071 + 970.576824 = 64_322.697534)
    S ->> SS: increase totalStake by 970.576824
    S ->> RSS: set D2.lastClaimedEpoch = 2
end

Note over S, N: State after Step 14 (D2 claims epoch 2 rewards): <br><br> Node1 <br> - N1.totalNodeStake: 64_322.697534 <br><br> Delegator 1: D1.stakeBase: 22_152.12071, D1.lastClaimedEpoch: 2 <br> Delegator 2: D2.stakeBase: 12_170.576824, D2.epochScore (epoch 2): 0.00323525608 (final), D2.lastClaimedEpoch: 2

rect LightBlue
    Note over D2, RSS: Step 15: Delegator2 finalizes withdrawal of 10,000 TRAC (Epoch 3) - NOW ALLOWED
    D2 ->> S: calls finalizeWithdrawal(N1_id)
        
    S ->> SS: getDelegatorWithdrawalRequest(N1_id, D2_key)
    SS -->> S: returns (amount: 10_000, indexedOutAmount: 0, withdrawalTimestamp)
    S ->> SS: deleteDelegatorWithdrawalRequest(N1_id, D2_key)
    S ->> SS: addDelegatorCumulativePaidOutRewards(N1_id, D2_key, 10_000)
    S ->> SS: addNodeCumulativePaidOutRewards(N1_id, 10_000)
    S ->> SS: transferStake(D2_address, 10_000)
end

Note over S, N: State after Step 15 (D2 finalizes withdrawal): <br><br> Node1 <br> - N1.totalNodeStake: 64_322.697534 (no change - withdrawal was already deducted in Step 11) <br><br> Delegator 2 <br> - D2.stakeBase: 12_170.576824 <br> - D2.cumulativePaidOutRewards: 10_000

rect LightBlue
    Note over D3, RSS: Step 16: Delegator3 delegates 5,000 TRAC to Node 1 (Epoch 3) - SHOULD REVERT
    D3 ->> S: calls stake(N1_id, 5_000)
    
    Note over S: Check unclaimed rewards: require(D1.lastClaimedEpoch == currentEpoch-1) - 1 == 3 - 1 ❌

    Note over S: Check if D3 has some epochs that they didn't claim for
    alt D3.lastClaimedEpoch != currentEpoch - 1 (1 != 3 - 1) ✅
        Note over S: D3 has some unclaimed epoch rewards. Check if D3 has only 1 or more epochs that they didnt claim for
        alt (currentEpoch - 1) - D3.lastClaimedEpoch > 1 (3 - 1 - 1 > 1) ❌
            Note over S: There is more than 1 epoch that D3 needs to claim rewards for
            Note over S: REVERT: "Must claim all previous epoch rewards before changing stake"
            S -->> D3: Transaction reverted
        end
    end

    Note over S: REVERT: "Must claim all previous epoch rewards before changing stake"
    S -->> D3: Transaction reverted
end

Note over S, N: State after Step 16 (D3 stake reverted): <br><br> Delegator 3 <br> - D3.stakeBase: 30_000 (unchanged) <br> - D3.lastClaimedEpoch: 0 <br><br> ❌ D3 cannot stake until claiming epochs 1 and 2 rewards

rect LightBlue
    Note over D3, RSS: Step 17: Delegator3 claims reward for epoch 1 - totalEpochFees = 3900 TRAC
    D3 ->> S: calls claimDelegatorReward(N1_id, epoch 1, D3_address)

    Note over S: Check if D3 has some epochs that they didn't claim for
    alt If D3.lastClaimedEpoch == currentEpoch - 1 (0 == 3 - 1) ❌
        Note over S: REVERT: "Delegator has already claimed rewards for all finalized epochs"
        S -->> D3: Transaction reverted
    else:
        Note over S: Check if delegator is claiming for the oldes unclaimed epoch first (lastClaimedEpoch + 1) and not some epoch newer than that
        alt If D3.lastClaimedEpoch + 1 != epochDelegatorWantsToClaimFor (0 + 1 != 1) ❌
            Note over S: REVERT: "Delegator has older epochs that they didn't claim rewards for"
            S -->> D3: Transaction reverted
        end
    end

    Note over S: Calculate Node 1 total reward = 3900 TRAC
    Note over S: rewardsForDelegators = 3900 TRAC

    Note over S, RS: Settle Delegator3's final score for epoch 1
    S ->> RS: calls prepareForStakeChange(epoch 1, N1_id, D3_key)
    RS ->> RSS: get N1.nodeEpochScorePerStake (epoch 1) (is 0.0000002)
    RS ->> RSS: get D3.lastSettledNodeEpochScorePerStake (epoch 1) (is 0)
    RS ->> RSS: get D3.stakeBase (epoch 1) (is 30_000)
    Note over RS: scoreEarned = D3.stakeBase * (N1.nodeEpochScorePerStake - D3.lastSettledNodeEpochScorePerStake) = 30_000 * (0.0000002 - 0) = 0.006
    RS ->> RSS: set D3.epochScore (epoch 1) = 0 + 0.006 = 0.006
    RS ->> RSS: set D3.lastSettledNodeEpochScorePerStake (epoch 1) = 0.0000002
    RS -->> S: returns D3.epochScore (epoch 1) = 0.006

    Note over S: D3_reward_share = (0.006 / 0.013) * 3900 = 1800 TRAC
    Note over S: Check if the number epochs that delegator needs to claim for is bigger than 1 <br> possibleEpochsToClaim = currentEpoch - 1 = 2 <br> lastClaimedEpoch = 0
    alt If possibleEpochsToClaim - lastClaimedEpoch > 1 (2 > 1) ✅
        Note over S: increase D3.rollingRewards, and leave stakeBase as is.
        S ->> SS: update D3.rollingRewards += 1800 = 1800
    else
        Note over S: D3_total_rewards = D3.rollingRewards + D3_reward_share
        S ->> SS: set D3.rollingRewards = 0
        S ->> SS: update D3.stakeBase += D3_total_rewards
        S ->> SS: update N1.totalNodeStake += D3_total_rewards
        S ->> SS: increase totalStake by D3_total_rewards
    end
    S ->> RSS: set D3.lastClaimedEpoch = 1
end

Note over S, N: State after Step 17 (D3 claims epoch 1 rewards): <br><br> Node1 <br> - N1.totalNodeStake: 66_122.697534 (64_322.697534 + 1_800) <br><br> Delegator 1: D1.stakeBase: 22_152.12071, D1.lastClaimedEpoch: 2 <br> Delegator 2: D2.stakeBase: 12_170.576824, D2.lastClaimedEpoch: 2 <br> Delegator 3: D3.stakeBase: 31_800, D3.epochScore (epoch 1): 0.006 (final), D3.lastClaimedEpoch: 1 <br><br> ✅ D3 correctly gets rewards based on 30_000 stake for epoch 1!

rect LightBlue
    Note over D3, RSS: Step 18: Delegator3 claims reward for epoch 2 - totalEpochFees = 4020 TRAC
    D3 ->> S: calls claimDelegatorReward(N1_id, epoch 2, D3_address)

    Note over S: Check if D3 has some epochs that they didn't claim for
    alt If D3.lastClaimedEpoch == currentEpoch - 1 (1 == 3 - 1) ❌
        Note over S: REVERT: "Delegator has already claimed rewards for all finalized epochs"
        S -->> D3: Transaction reverted
    else:
        Note over S: Check if delegator is claiming for the oldes unclaimed epoch first (lastClaimedEpoch + 1) and not some epoch newer than that
        alt If D3.lastClaimedEpoch + 1 != epochDelegatorWantsToClaimFor (1 + 1 != 2) ❌
            Note over S: REVERT: "Delegator has older epochs that they didn't claim rewards for"
            S -->> D3: Transaction reverted
        end
    end

    Note over S: Check if epochs that delegator needs to claim for is bigger than 1, currentEpoch = 3, lastClaimedEpoch + 1 = 1 + 1 = 2 <br><br> currentEpoch - lastClaimedEpoch > 1 --> 1 > 1 ❌ <br><br> We need to increase stakeBase with the D3.rollingRewards + new calculated rewards

    Note over S: Calculate Node 1 total reward = 4020 TRAC
    Note over S: rewardsForDelegators = 4020 TRAC

    Note over S, RS: Settle Delegator3's final score for epoch 2
    S ->> RS: calls prepareForStakeChange(epoch 2, N1_id, D3_key)
    RS ->> RSS: get N1.nodeEpochScorePerStake (epoch 2) (is 0.000000199700273)
    RS ->> RSS: get D3.lastSettledNodeEpochScorePerStake (epoch 2) (is 0)
    RS ->> RSS: get D3.stakeBase (epoch 2) (is 30_000)
    Note over RS: scoreEarned = D3.stakeBase * (N1.nodeEpochScorePerStake - D3.lastSettledNodeEpochScorePerStake) = 30_000 * (0.000000199700273 - 0) = 0.00599100819
    RS ->> RSS: set D3.epochScore (epoch 2) = 0.00599100819
    RS ->> RSS: set D3.lastSettledNodeEpochScorePerStake (epoch 2) = 0.000000199700273
    RS -->> S: returns D3.epochScore (epoch 2) = 0

    Note over S: D3_reward_share = (0.00599100819 / 0.0134) * 4020 = 1797.302457 TRAC
    Note over S: D3_total_rewards = D3.rollingRewards + D3_reward_share = 1800 + 1797.302457 = 3597.302457 TRAC
    S ->> SS: update D3.stakeBase += D3_total_rewards (30_000 + 3597.302457 = 33_597.302457)
    S ->> SS: update N1.totalNodeStake += 3597.302457 (66_122.697534 + 3597.302457 = 69_719.999991)
    S ->> SS: increase totalStake by 3597.302457
    S ->> RSS: set D3.lastClaimedEpoch = 2
end

Note over S, N: State after Step 18 (D3 claims epoch 2 rewards): <br><br> Node1 <br> - N1.totalNodeStake: 69_719.999991 <br><br> Delegator 1: D1.stakeBase: 22_152.12071, D1.lastClaimedEpoch: 2 <br> Delegator 2: D2.stakeBase: 12_170.576824, D2.lastClaimedEpoch: 2 <br> Delegator 3: D3.stakeBase: 33_597.302457, D3.epochScore (epoch 2): 0.00599100819 (final), D3.lastClaimedEpoch: 2

rect LightBlue
    Note over D3, RSS: Step 19: Delegator3 requests withdrawal of 10,000 TRAC (Epoch 3) - NOW ALLOWED
    D3 ->> S: calls requestWithdrawal(N1_id, 10_000)

    Note over S: Check if D3 has some epochs that they didn't claim for
    alt D3.lastClaimedEpoch != currentEpoch - 1 (2 != 3 - 1) ❌
        Note over S: Claimed rewards for all possible epochs, no need to check further
    end

    rect LightYellow
        Note over S, RS: Phase 1: Settle D3's score before stake change
        S ->> RS: calls prepareForStakeChange(epoch 3, N1_id, D3_key)
        RS ->> RSS: get N1.nodeEpochScorePerStake (epoch 3) (is 0)
        RS ->> RSS: get D3.lastSettledNodeEpochScorePerStake (epoch 3) (is 0)
        RS ->> RSS: get D3.stakeBase (epoch 3) (is 0)
        Note over RS: scoreEarned = D3.stakeBase * (N1.nodeEpochScorePerStake - D3.lastSettledNodeEpochScorePerStake) = 33_597.302457 * (0 - 0) = 0
        RS ->> RSS: set D3.epochScore (epoch 3) = 0
        RS ->> RSS: set D3.lastSettledNodeEpochScorePerStake (epoch 3) = 0
        RS ->> RSS: set D3.stakeBase (epoch 3) = 33_597.302457 - 10_000 = 23_597.302457 (remaining stake)
    end

    rect LightYellow
        Note over S, SS: Phase 2: StakingStorage updates stake
        S ->> SS: setDelegatorStakeInfo(N1_id, D3_key, base=23_597.302457, indexed=0)
        S ->> SS: setNodeStake(N1_id, 69_719.999991 - 10_000 = 59_719.999991)
        S ->> SS: create withdrawal request for 10_000 TRAC
    end
end

Note over S, N: State after Step 19 (D3 requests withdrawal, Epoch 3): <br><br> Node1 <br> - N1.totalNodeStake: 59_719.999991 <br><br> Delegator 1: D1.stakeBase: 22_152.12071, D1.lastClaimedEpoch: 2 <br> Delegator 2: D2.stakeBase: 12_170.576824, D2.lastClaimedEpoch: 2 <br> Delegator 3: D3.stakeBase: 23_597.302457, D3.lastClaimedEpoch: 2

rect LightBlue
    Note over D2, RSS: <br> Advance to epoch 4... <br>
end

rect LightBlue
    Note over D3, RSS: Step 20: Delegator3 finalizes withdrawal of 10,000 TRAC (Epoch 4)
    D3 ->> S: calls finalizeWithdrawal(N1_id)

    Note over S: Finalize withdrawal
    S ->> SS: getDelegatorWithdrawalRequest(N1_id, D3_key)
    SS -->> S: returns (amount: 10_000, indexedOutAmount: 0, withdrawalTimestamp)
    S ->> SS: deleteDelegatorWithdrawalRequest(N1_id, D3_key)
    S ->> SS: addDelegatorCumulativePaidOutRewards(N1_id, D3_key, 10_000)
    S ->> SS: addNodeCumulativePaidOutRewards(N1_id, 10_000)
    S ->> SS: transferStake(D3_address, 10_000)
end

Note over S, N: State after Step 20 (D3 finalize withdrawal): <br><br> Delegator 3 <br> - D3.stakeBase: 23_597.302457 (unchanged) <br> - D3.lastClaimedEpoch: 3 <br><br>

rect LightBlue
    Note over D1, RSS: Step 23: Delegator1 delegates 5,000 TRAC to Node 1 (Epoch 4)
    D1 ->> S: calls stake(N1_id, 5_000)

    Note over S: Check if D1 has some epochs that they didn't claim for
    alt D1.lastClaimedEpoch != currentEpoch - 1:
        Note over S: rest of the checks...
    end
    Note over S: D1.lastClaimedEpoch == currentEpoch - 1  -->  3 == 4 - 1 ✅

    Note over S: Proceed with the rest of the stake function...
end

Note over S, N: Final State after Step 23 (D1 stake reverted): <br><br> Node1 <br> - N1.totalNodeStake: 59_719.999991 <br><br> Delegator 1 <br> - D1.stakeBase: 22_152.12071 (unchanged) <br> - D1.lastClaimedEpoch: 2 <br><br> Delegator 2: D2.stakeBase: 12_170.576824, D2.lastClaimedEpoch: 2 <br> Delegator 3: D3.stakeBase: 23_597.302457, D3.lastClaimedEpoch: 2 <br><br> ❌ D1 cannot stake until claiming epoch 3 rewards <br><br> 🎯 The system successfully prevents stake changes until all <br> previous epoch rewards are claimed, ensuring accurate <br> reward calculations based on historical stake amounts! <br><br> ✅ Key Benefits: <br> - No loops needed in smart contracts <br> - Delegators control when to settle their scores <br> - Rewards always calculated with correct historical stakes <br> - System prevents the "late withdrawal" reward calculation bug

rect LightBlue
    Note over D1, RSS: <br> REDELEGATION SCENARIOS <br> Start of Epoch 4 <br><br> Node1.totalNodeStake = 59_719.999991 TRAC <br> Node1.nodeEpochScorePerStake(4) = 0.00000005 <br> Node2.totalNodeStake = 10_000 TRAC (foreign stake) <br> D1.stakeBase (on N1) = 22_152.12071 TRAC <br> D1.lastClaimedEpoch = 2
end

participant N2 as Node2

rect LightBlue
    Note over D1, RSS: Case A – "all-out" redelegate from N1 to a brand-new N2 <br> Step A-1 – D1 first claims epoch 3 on N1
    D1 ->> S: calls claimDelegatorReward(N1_id, epoch 3, D1_address)

    Note over S: Validation - Happy Path ✅
    Note over S: D1.lastClaimedEpoch != currentEpoch - 1 (2 != 4 - 1) ✅ 
    Note over S: (currentEpoch - 1) - D1.lastClaimedEpoch = 1 (not > 1) ✅
    Note over S: D1.lastClaimedEpoch + 1 == epochDelegatorWantsToClaimFor (2 + 1 == 3) ✅

    Note over S: Calculate Node 1 total reward for epoch 3 = 4200 TRAC
    Note over S: rewardsForDelegators = 4200 TRAC (assume 0 operator fee)

    Note over S, RS: Settle Delegator1's final score for epoch 3
    S ->> RS: calls prepareForStakeChange(epoch 3, N1_id, D1_key)
    RS ->> RSS: get N1.nodeEpochScorePerStake (epoch 3) (is 0.00000006)
    RS ->> RSS: get D1.lastSettledNodeEpochScorePerStake (epoch 3) (is 0)
    RS ->> RSS: get D1.stakeBase (epoch 3) (is 22_152.12071)
    Note over RS: scoreEarned = 22_152.12071 × (0.00000006 - 0) = 0.001329127
    RS ->> RSS: set D1.epochScore (epoch 3) = 0.001329127
    RS ->> RSS: set D1.lastSettledNodeEpochScorePerStake (epoch 3) = 0.00000006
    RS -->> S: returns D1.epochScore (epoch 3) = 0.001329127

    Note over S: totalNodeScoreForEpoch3 = N1.epochScore (epoch 3) = 0.0138
    Note over S: D1_reward_share = (0.001329127 / 0.0138) * 4200 = 404.18 TRAC
    S ->> SS: update D1.stakeBase += 404.18 (22_152.12071 + 404.18 = 22_556.30071)
    S ->> SS: update N1.totalNodeStake += 404.18 (59_719.999991 + 404.18 = 60_124.179991)
    S ->> SS: increase totalStake by 404.18
    S ->> RSS: set D1.lastClaimedEpoch = 3
end

Note over S, N2: State after Step A-1: <br><br> Node1 <br> - N1.totalNodeStake: 60_124.179991 <br><br> Delegator 1 <br> - D1.stakeBase: 22_556.30071 <br> - D1.lastClaimedEpoch: 3

rect LightBlue
    Note over D1, RSS: Step A-2 – redelegate(N1 → N2, stakeAmount = 22_556.30071)
    D1 ->> S: calls redelegate(N1_id, N2_id, 22_556.30071)

    Note over S: Guards - Happy Path ✅
    Note over S: ✔ fromIdentityId ≠ toIdentityId ✔ stakeAmount > 0 ✔ destination won't exceed maxStake

    Note over S: Validation - Happy Path ✅
    S ->> S: _validateDelegatorEpochClaims(N1_id, D1_address) 
    Note over S: ✓ D1.lastClaimedEpoch == currentEpoch - 1 (3 == 4 - 1)
    S ->> S: _validateDelegatorEpochClaims(N2_id, D1_address) 
    Note over S: ✓ first time on N2, no validation needed

    Note over S: Lazy-settle (source, then dest)
    S ->> RS: _prepareForStakeChange(epoch 4, N1_id, D1_key)
    RS ->> RSS: get N1.nodeEpochScorePerStake (epoch 4) (is 0.00000005)
    RS ->> RSS: get D1.lastSettledNodeEpochScorePerStake (epoch 4) (is 0)
    RS ->> RSS: get D1.stakeBase (epoch 4) (is 22_556.30071)
    Note over RS: newlyEarnedScore = 22_556.30071 × 0.00000005 = 0.001128
    RS ->> RSS: set D1.epochScore (epoch 4) on N1 = 0.001128
    RS ->> RSS: set D1.lastSettledNodeEpochScorePerStake (epoch 4) = 0.00000005
    RS -->> S: returns fromDelegatorEpochScore = 0.001128

    S ->> RS: _prepareForStakeChange(epoch 4, N2_id, D1_key)
    Note over RS: → all zero (fresh node)

    Note over S: State writes - Happy Path ✅
    S ->> SS: getDelegatorStakeBase(N1_id, D1_key) (returns 22_556.30071)
    Note over S: ✓ stakeAmount ≤ fromDelegatorStakeBase ✓ destination maxStake check passed

    Note over S: newFromDelegatorStakeBase = 22_556.30071 - 22_556.30071 = 0 (complete transfer)
    S ->> SS: setDelegatorStakeBase(N1_id, D1_key, 0)
    S ->> SS: setNodeStake(N1_id, 60_124.179991 - 22_556.30071 = 37_567.879281)
    S ->> SS: increaseDelegatorStakeBase(N2_id, D1_key, 22_556.30071)
    S ->> SS: setNodeStake(N2_id, 10_000 + 22_556.30071 = 32_556.30071)

    Note over S: 🚨 Critical system behavior when stake fully transferred
    alt newFromDelegatorStakeBase == 0 (0 == 0)
        Note over S: ✅ TRIGGERED - D1 has transferred ALL stake from N1
        S ->> SS: 🚨 delegatorsInfo.removeDelegator(N1_id, D1_address)
        Note over S: D1 is REMOVED from N1 delegators list
        alt fromDelegatorEpochScore > 0 (0.001128 > 0)
            Note over S: ✅ TRIGGERED - D1 earned score in epoch 4
            S ->> SS: 🔒 delegatorsInfo.setLastStakeHeldEpoch(N1_id, D1_address, 4)
            Note over S: System remembers D1 held stake in epoch 4 - can claim rewards later!
        end
    end

    S ->> S: _manageDelegatorStatus(N2_id, D1_address)
    Note over S: ✔ !isNodeDelegator(N2, D1) → addDelegator(N2, D1)
    Note over S: ✔ !hasEverDelegatedToNode(N2, D1) → setHasEverDelegated(N2, D1) = true
    Note over S: ✖ toLastStakeHeldEpoch(N2, D1) was 0 → skip reset

    S -->> D1: emit StakeRedelegated(N1, N2, D1, 22_556.30071)
end

Note over S, N2: Snapshot after Case A: <br><br> Node1.totalNodeStake = 37_567.879281, D1.stakeBase(N1)=0 <br> Node2.totalNodeStake = 32_556.30071, D1.stakeBase(N2)=22_556.30071 <br> 🔒 lastStakeHeldEpoch(N1, D1) = 4 (D1 NOT in N1 delegators list but can claim epoch 4 rewards)

rect LightBlue
    Note over N2, RSS: Proof on N2 (still epoch 4)
    N2 ->> RS: executes submitProof(chunk, merkleProof)
    Note over RS: Node 2 score = 0.00325563 (calculated based on 32_556.30071 stake)
    RS ->> SS: getNodeStake(N2_id) (returns 32_556.30071)
    Note over RS: nodeScorePerStake = 0.00325563 / 32_556.30071 = 0.0000001
    RS ->> RSS: N2.nodeEpochScorePerStake (epoch 4) += 0.0000001
    RS ->> RSS: N2.epochScore (epoch 4) += 0.00325563
    RS ->> RSS: AllNodesEpochScore (epoch 4) += 0.00325563
    
    Note over RS: D1.extraScore earned = 22_556.30071 × 0.0000001 = 0.002255630
    RS ->> RSS: set D1.epochScore (epoch 4) on N2 = 0.002255630
    RS ->> RSS: set D1.lastSettledNodeEpochScorePerStake (epoch 4) on N2 = 0.0000001
end

rect LightBlue
    Note over D1, RSS: <br> Advance to Epoch 5 <br><br> Node1.totalNodeStake = 37_567.879281 TRAC <br> Node1.nodeEpochScorePerStake(5) = 0.00000004 <br> Node2.totalNodeStake = 32_556.30071 TRAC <br> Node2.nodeEpochScorePerStake(5) = 0.00000006 <br> D1.stakeBase(N1) = 0 (but D1 NOT in N1 delegators list) <br> D1.stakeBase(N2) = 22_556.30071 <br> 🔒 lastStakeHeldEpoch(N1,D1) = 4, lastStakeHeldEpoch(N2,D1) = 0 <br> D1.lastClaimedEpoch = 3
end

rect LightBlue
    Note over N, RSS: Proofs in Epoch 5
    N ->> RS: Node1 submits proof
    Note over RS: Node 1 score = 0.00375679 (calculated based on 37_567.879281 stake)
    RS ->> SS: getNodeStake(N1_id) (returns 37_567.879281)
    Note over RS: nodeScorePerStake = 0.00375679 / 37_567.879281 = 0.0000001
    RS ->> RSS: N1.nodeEpochScorePerStake (epoch 5) += 0.0000001
    RS ->> RSS: N1.epochScore (epoch 5) += 0.00375679
    
    Note over RS: D1.extraScore on N1 = 0 × 0.0000001 = 0 (D1 has no stake on N1)
    RS ->> RSS: set D1.epochScore (epoch 5) on N1 = 0
    RS ->> RSS: set D1.lastSettledNodeEpochScorePerStake (epoch 5) on N1 = 0.0000001

    N2 ->> RS: Node2 submits proof  
    Note over RS: Node 2 score = 0.00325563 (calculated based on 32_556.30071 stake)
    RS ->> SS: getNodeStake(N2_id) (returns 32_556.30071)
    Note over RS: nodeScorePerStake = 0.00325563 / 32_556.30071 = 0.0000001
    RS ->> RSS: N2.nodeEpochScorePerStake (epoch 5) += 0.0000001
    RS ->> RSS: N2.epochScore (epoch 5) += 0.00325563
    
    Note over RS: D1.extraScore on N2 = 22_556.30071 × 0.0000001 = 0.002255630
    RS ->> RSS: set D1.epochScore (epoch 5) on N2 = 0.002255630
    RS ->> RSS: set D1.lastSettledNodeEpochScorePerStake (epoch 5) on N2 = 0.0000001
end

rect LightBlue
    Note over D1, RSS: Case B – "full-back" redelegate from N2 to N1 (now in Epoch 5) <br> Step B-0 – First, try redelegate and see validation
    D1 ->> S: calls redelegate(N2_id, N1_id, 21_281)

    Note over S: Validation - REVERT ❌
    S ->> S: _validateDelegatorEpochClaims(N2_id, D1_address) ✓
    S ->> S: _validateDelegatorEpochClaims(N1_id, D1_address) 
    Note over S: hasEverDelegatedToNode(N1, D1) = true ✅
    Note over S: getDelegatorStakeBase(N1, D1) = 0 ✅
    Note over S: lastStakeHeldEpoch(N1, D1) = 4 > 0 && 4 < currentEpoch(5) ✅
    Note over S: REVERT: "Must claim rewards up to the lastStakeHeldEpoch before changing stake"
    S -->> D1: Transaction reverted

    Note over D1, RSS: Step B-1 – Must claim epoch 4 rewards from N1 first
    D1 ->> S: calls claimDelegatorReward(N1_id, epoch 4, D1_address)

    Note over S: 🔒 _validateDelegatorEpochClaims(N1, D1) logic:
    Note over S: hasEverDelegatedToNode(N1, D1) = true ✅
    Note over S: getDelegatorStakeBase(N1, D1) = 0 ✅  
    Note over S: lastStakeHeldEpoch(N1, D1) = 4 > 0 && 4 < currentEpoch(5) ✅
    Note over S: → Validation allows claim for this specific lastStakeHeldEpoch

    Note over S: Calculate Node 1 total reward for epoch 4 = 3900 TRAC
    Note over S: rewardsForDelegators = 3900 TRAC

    Note over S, RS: Settle Delegator1's final score for epoch 4 on N1
    S ->> RS: calls prepareForStakeChange(epoch 4, N1_id, D1_key)
    Note over RS: D1.epochScore (epoch 4) on N1 was already settled = 0.001128
    RS -->> S: returns D1.epochScore (epoch 4) on N1 = 0.001128

    Note over S: totalNodeScoreForEpoch4 = N1.epochScore (epoch 4) = 0.0138
    Note over S: D1_reward_share = (0.001128 / 0.0138) * 3900 = 318.78 TRAC
    S ->> SS: update D1.stakeBase(N1) += 318.78 (0 + 318.78 = 318.78)
    S ->> SS: update N1.totalNodeStake += 318.78 (37_567.879281 + 318.78 = 37_886.659281)
    S ->> SS: increase totalStake by 318.78
    S ->> RSS: set D1.lastClaimedEpoch = 4
    S ->> RSS: set lastStakeHeldEpoch(N1, D1) = 0
    S ->> SS: 🔄 _manageDelegatorStatus(N1, D1): addDelegator + reset lastStakeHeldEpoch
end

Note over S, N2: State after claiming N1 epoch 4: <br><br> Node1.totalNodeStake = 37_886.659281, D1.stakeBase(N1) = 318.78 <br> Node2.totalNodeStake = 32_556.30071, D1.stakeBase(N2) = 22_556.30071 <br> D1.lastClaimedEpoch = 4, lastStakeHeldEpoch(N1,D1) = 0 <br> 🔄 D1 back in N1 delegators list

rect LightBlue
    Note over D1, RSS: Step B-2 – Now redelegate(N2 → N1, stakeAmount = 22_556.30071)
    D1 ->> S: calls redelegate(N2_id, N1_id, 22_556.30071)

    Note over S: Validation - Happy Path ✅
    S ->> S: _validateDelegatorEpochClaims(N2_id, D1_address)
    Note over S: ✓ D1.lastClaimedEpoch == currentEpoch - 1 (4 == 5 - 1)
    S ->> S: _validateDelegatorEpochClaims(N1_id, D1_address)  
    Note over S: ✓ D1.lastClaimedEpoch == currentEpoch - 1 (4 == 5 - 1)
    Note over S: ✓ lastStakeHeldEpoch(N1, D1) = 0 (was reset after claim)

    Note over S: Lazy-settle (source, then dest)
            S ->> RS: _prepareForStakeChange(epoch 5, N2_id, D1_key)
        RS ->> RSS: get N2.nodeEpochScorePerStake (epoch 5) (is 0.0000001)
        RS ->> RSS: get D1.lastSettledNodeEpochScorePerStake (epoch 5) on N2 (is 0)
        RS ->> RSS: get D1.stakeBase (epoch 5) on N2 (is 22_556.30071)
        Note over RS: newlyEarnedScore = 22_556.30071 × (0.0000001 - 0) = 0.00225563
        RS ->> RSS: set D1.epochScore (epoch 5) on N2 = 0.00225563
        RS ->> RSS: set D1.lastSettledNodeEpochScorePerStake (epoch 5) on N2 = 0.0000001
        RS -->> S: returns fromDelegatorEpochScore = 0.00225563

            S ->> RS: _prepareForStakeChange(epoch 5, N1_id, D1_key)
        RS ->> RSS: get N1.nodeEpochScorePerStake (epoch 5) (is 0.0000001)
        RS ->> RSS: get D1.lastSettledNodeEpochScorePerStake (epoch 5) on N1 (is 0)
        RS ->> RSS: get D1.stakeBase (epoch 5) on N1 (is 318.78)
        Note over RS: newlyEarnedScore = 318.78 × (0.0000001 - 0) = 0.00003188
        RS ->> RSS: set D1.epochScore (epoch 5) on N1 = 0.00003188
        RS ->> RSS: set D1.lastSettledNodeEpochScorePerStake (epoch 5) on N1 = 0.0000001

            Note over S: State writes - Happy Path ✅
        S ->> SS: getDelegatorStakeBase(N2_id, D1_key) (returns 22_556.30071)
        Note over S: ✓ stakeAmount ≤ fromDelegatorStakeBase ✓ destination maxStake check passed

        Note over S: newFromDelegatorStakeBase = 22_556.30071 - 22_556.30071 = 0 (complete transfer)
        S ->> SS: setDelegatorStakeBase(N2_id, D1_key, 0)
        S ->> SS: setNodeStake(N2_id, 32_556.30071 - 22_556.30071 = 10_000)
        S ->> SS: increaseDelegatorStakeBase(N1_id, D1_key, 22_556.30071)
        S ->> SS: setNodeStake(N1_id, 37_886.659281 + 22_556.30071 = 60_442.9600)

            Note over S: 🚨 Critical system behavior when stake fully transferred from N2
        alt newFromDelegatorStakeBase == 0 (0 == 0)
            Note over S: ✅ TRIGGERED - D1 has transferred ALL stake from N2
            S ->> SS: 🚨 delegatorsInfo.removeDelegator(N2_id, D1_address)
            Note over S: D1 is REMOVED from N2 delegators list
            alt fromDelegatorEpochScore > 0 (0.00225563 > 0)
                Note over S: ✅ TRIGGERED - D1 earned score in epoch 5
                S ->> SS: 🔒 delegatorsInfo.setLastStakeHeldEpoch(N2_id, D1_address, 5)
                Note over S: System remembers D1 held stake in epoch 5 on N2 - can claim rewards later!
            end
        end

            S ->> S: _manageDelegatorStatus(N1_id, D1_address)
        Note over S: ✓ isNodeDelegator(N1, D1) already true (D1 had 318.78 on N1)
        Note over S: ✓ hasEverDelegatedToNode(N1, D1) already true
        Note over S: ✓ lastStakeHeldEpoch(N1, D1) = 0, skip reset

        S -->> D1: emit StakeRedelegated(N2, N1, D1, 22_556.30071)
end

Note over S, N2: Snapshot after Case B: <br><br> Node1.totalNodeStake = 60_442.9600, D1.stakeBase(N1) = 22_875.08071 <br> Node2.totalNodeStake = 10_000, D1.stakeBase(N2) = 0 <br> 🔒 lastStakeHeldEpoch(N2, D1) = 5 (D1 NOT in N2 delegators list but can claim epoch 5 rewards)

rect LightBlue
    Note over D1, RSS: <br> Advance to Epoch 6 <br><br> Node1.totalNodeStake = 60_442.9600 TRAC <br> Node2.totalNodeStake = 10_000 TRAC <br> D1.stakeBase(N1) = 22_875.08071 TRAC <br> D1.stakeBase(N2) = 0 TRAC (but D1 NOT in N2 delegators list) <br> D1.lastClaimedEpoch = 4 <br> 🔒 lastStakeHeldEpoch(N2,D1) = 5
end

rect LightBlue
    Note over D1, RSS: Case C – Try some operation on N2, but must claim epoch 5 first
    Note over D1, RSS: Simulate: D1 tries any stake operation involving N2
    D1 ->> S: calls redelegate(N1_id, N2_id, 1000) [or any stake change involving N2]

    Note over S: Validation - REVERT ❌
    S ->> S: _validateDelegatorEpochClaims(N1_id, D1_address) ✓
    S ->> S: _validateDelegatorEpochClaims(N2_id, D1_address)
    Note over S: hasEverDelegatedToNode(N2, D1) = true ✅
    Note over S: getDelegatorStakeBase(N2, D1) = 0 ✅
    Note over S: lastStakeHeldEpoch(N2, D1) = 5 > 0 && 5 < currentEpoch(6) ✅
    Note over S: REVERT: "Must claim rewards up to the lastStakeHeldEpoch before changing stake"
    S -->> D1: Transaction reverted

    Note over D1, RSS: Must claim epoch 5 rewards from N2 first
    D1 ->> S: calls claimDelegatorReward(N2_id, epoch 5, D1_address)

    Note over S: 🔒 _validateDelegatorEpochClaims(N2, D1) logic:
    Note over S: hasEverDelegatedToNode(N2, D1) = true ✅
    Note over S: getDelegatorStakeBase(N2, D1) = 0 ✅
    Note over S: lastStakeHeldEpoch(N2, D1) = 5 > 0 && 5 < currentEpoch(6) ✅
    Note over S: → Must claim epoch 5 first before any stake changes on N2

    Note over S: Calculate Node 2 total reward for epoch 5 = 2800 TRAC
    Note over S: rewardsForDelegators = 2800 TRAC

    Note over S, RS: Settle Delegator1's final score for epoch 5 on N2
    S ->> RS: calls prepareForStakeChange(epoch 5, N2_id, D1_key)
    Note over RS: D1.epochScore (epoch 5) on N2 was already settled = 0.00225563
    RS -->> S: returns D1.epochScore (epoch 5) on N2 = 0.00225563

    Note over S: totalNodeScoreForEpoch5 = N2.epochScore (epoch 5) = 0.00325563
    Note over S: D1_reward_share = (0.00225563 / 0.00325563) * 2800 = 1938.02 TRAC
    S ->> SS: update D1.stakeBase(N2) += 1938.02 (0 + 1938.02 = 1938.02)
    S ->> SS: update N2.totalNodeStake += 1938.02 (10_000 + 1938.02 = 11_938.02)
    S ->> SS: increase totalStake by 1938.02
    S ->> RSS: set D1.lastClaimedEpoch = 5
    S ->> RSS: set lastStakeHeldEpoch(N2, D1) = 0
    S ->> SS: 🔄 _manageDelegatorStatus(N2, D1): addDelegator + reset lastStakeHeldEpoch
end

Note over S, N2: State after Case C: <br><br> Node1.totalNodeStake = 60_442.9600, D1.stakeBase(N1) = 22_875.08071 <br> Node2.totalNodeStake = 11_938.02, D1.stakeBase(N2) = 1938.02 <br> D1.lastClaimedEpoch = 5, all lastStakeHeldEpoch flags = 0

rect LightBlue
    Note over D1, RSS: Case D – Same epoch redelegation (no claim needed) <br> Context: All in epoch 6 - N1→N2→N1
    D1 ->> S: calls redelegate(N1_id, N2_id, 1000) [creates lastStakeHeldEpoch(N1,D1)=6]
    Note over S: Succeeds - partial transfer

    D1 ->> S: calls redelegate(N2_id, N1_id, 1000) [tries to go back to N1]

    Note over S: Validation - Happy Path ✅
    S ->> S: _validateDelegatorEpochClaims(N1_id, D1_address)
    Note over S: hasEverDelegatedToNode(N1, D1) = true ✅
    Note over S: getDelegatorStakeBase(N1, D1) > 0 ✅ (still has stake)
    Note over S: OR: lastStakeHeldEpoch(N1, D1) == currentEpoch(6) ✅
    Note over S: ✓ No claim needed - rewards not claimable yet in same epoch

    Note over S: Redelegate proceeds successfully
end

rect LightBlue
    Note over D1, RSS: <br> ===== REVERT SCENARIOS ===== <br> Now demonstrating various error cases
end

rect LightBlue
    Note over D1, RSS: Case E – REVERT: one epoch unclaimed → must claim before redelegate <br> Context: Set D1.lastClaimedEpoch = 4 to simulate unclaimed epoch 5
    Note over S: Simulate: D1.lastClaimedEpoch = 4, currentEpoch = 6
    D1 ->> S: calls redelegate(N1_id, N2_id, 500)

    Note over S: Guards - Happy Path ✅
    Note over S: ✔ fromIdentityId ≠ toIdentityId ✔ stakeAmount > 0 ✔ destination won't exceed maxStake

    Note over S: Validation - REVERT ❌
    S ->> S: _validateDelegatorEpochClaims(N1_id, D1_address)
    alt D1.lastClaimedEpoch != currentEpoch - 1 (4 != 6 - 1) ✅
        Note over S: D1 has some unclaimed epoch rewards
        alt (currentEpoch - 1) - D1.lastClaimedEpoch > 1 (5 - 4 > 1) ❌
            Note over S: There is more than 1 epoch that D1 needs to claim rewards for
            Note over S: REVERT: "Must claim all previous epoch rewards before changing stake"
            S -->> D1: Transaction reverted
        else
            Note over S: D1 didn't claim for only one epoch (epoch 5). Check if rewards exist
            alt D1.epochScore(epoch 5) == 0 && (N1.nodeEpochScorePerStake(epoch 5) - D1.lastSettledNodeEpochScorePerStake(epoch 5)) == 0
                Note over S: D1 has no rewards to claim for epoch 5 --> set last claimed epoch for D1 to 5
                S ->> RSS: set D1.lastClaimedEpoch = 5
            else
                Note over S: D1 has rewards for epoch 5 that need to be claimed first
                Note over S: REVERT: "Must claim all previous epoch rewards before changing stake"
                S -->> D1: Transaction reverted
            end
        end
    end

    Note over S: Result: REVERT - Must claim epoch 5 rewards first <br> (No state changes)
end

rect LightBlue
    Note over D1, RSS: Case F – REVERT: multiple epochs unclaimed → must claim older epochs first
    Note over S: Simulate: D1.lastClaimedEpoch = 3, currentEpoch = 6 (epochs 4 and 5 unclaimed)
    D1 ->> S: calls redelegate(N1_id, N2_id, 500)

    Note over S: Guards - Happy Path ✅
    Note over S: ✔ fromIdentityId ≠ toIdentityId ✔ stakeAmount > 0 ✔ destination won't exceed maxStake

    Note over S: Validation - REVERT ❌
    S ->> S: _validateDelegatorEpochClaims(N1_id, D1_address)
    alt D1.lastClaimedEpoch != currentEpoch - 1 (3 != 6 - 1) ✅
        Note over S: D1 has some unclaimed epoch rewards
        alt (currentEpoch - 1) - D1.lastClaimedEpoch > 1 (5 - 3 > 1) ✅
            Note over S: There is more than 1 epoch that D1 needs to claim rewards for
            Note over S: REVERT: "Must claim all previous epoch rewards before changing stake"
            S -->> D1: Transaction reverted
        end
    end

    Note over S: Result: REVERT - Must claim epochs 4 and 5 first, starting with epoch 4 <br> (No state changes)
end

rect LightBlue
    Note over D1, RSS: Case G – REVERT: same node redelegation
    D1 ->> S: calls redelegate(N1_id, N1_id, 1000)

    Note over S: Guards - REVERT ❌
    alt fromIdentityId == toIdentityId (N1_id == N1_id) ✅
        Note over S: REVERT: "Cannot redelegate to the same node"
        S -->> D1: Transaction reverted
    end

    Note over S: Result: REVERT - Cannot redelegate to same node <br> (No state changes)
end

rect LightBlue
    Note over D1, RSS: Case H – REVERT: zero amount redelegation
    D1 ->> S: calls redelegate(N1_id, N2_id, 0)

    Note over S: Guards - REVERT ❌
    Note over S: ✔ fromIdentityId ≠ toIdentityId
    alt stakeAmount == 0 ✅
        Note over S: REVERT: ZeroTokenAmount
        S -->> D1: Transaction reverted
    end

    Note over S: Result: REVERT - Cannot redelegate zero amount <br> (No state changes)
end

rect LightBlue
    Note over D1, RSS: Case I – REVERT: exceeds available stake
    Note over S: Context: D1.stakeBase(N1) = 22_875.08071 TRAC
    D1 ->> S: calls redelegate(N1_id, N2_id, 25_000)

    Note over S: Guards - Happy Path ✅
    Note over S: ✔ fromIdentityId ≠ toIdentityId ✔ stakeAmount > 0 ✔ destination won't exceed maxStake

    Note over S: Validation - Happy Path ✅
    S ->> S: _validateDelegatorEpochClaims(N1_id, D1_address) ✓
    S ->> S: _validateDelegatorEpochClaims(N2_id, D1_address) ✓

    Note over S: Lazy-settle - Happy Path ✅
    S ->> RS: _prepareForStakeChange(epoch 6, N1_id, D1_key)
    Note over RS: Settlement completes successfully
    S ->> RS: _prepareForStakeChange(epoch 6, N2_id, D1_key)
    Note over RS: Settlement completes successfully

    Note over S: State writes - REVERT ❌
    S ->> SS: getDelegatorStakeBase(N1_id, D1_key) (returns 22_875.08071)
    alt stakeAmount > fromDelegatorStakeBase (25_000 > 22_875.08071) ✅
        Note over S: REVERT: WithdrawalExceedsStake(22_875.08071, 25_000)
        S -->> D1: Transaction reverted
    end

    Note over S: Result: REVERT - Cannot redelegate more than available stake <br> (No state changes)
end

rect LightBlue
    Note over D1, RSS: Case J – REVERT: destination node exceeds maxStake
    Note over S: Context: N2.totalNodeStake = 11_938.02, maxStake = 50_000
    D1 ->> S: calls redelegate(N1_id, N2_id, 20_000)

    Note over S: Guards - REVERT ❌
    Note over S: ✔ fromIdentityId ≠ toIdentityId ✔ stakeAmount > 0
    alt ss.getNodeStake(N2_id) + stakeAmount > maxStake (11_938.02 + 20_000 = 31_938.02 > 50_000)
        Note over S: For demo purposes, assume maxStake = 30_000
        Note over S: REVERT: MaximumStakeExceeded(30_000)
        S -->> D1: Transaction reverted
    end

    Note over S: Result: REVERT - Destination node would exceed maximum stake <br> (No state changes)
end

Note over S, N2: 🎯 REDELEGATION SCENARIOS COMPLETE! <br><br> ✅ **Happy Path Features Demonstrated:** <br> - Proper epoch claim validation (must be up-to-date) <br> - Lazy settlement before stake changes <br> - Multi-node position management <br> - lastStakeHeldEpoch tracking for unclaimed rewards <br> - Accurate score and reward calculations <br> - State cleanup when delegator leaves a node <br><br> ❌ **Error Cases Demonstrated:** <br> - Must claim all previous epochs before redelegating <br> - Cannot redelegate to the same node <br> - Cannot redelegate zero amount <br> - Cannot redelegate more than available stake <br> - Cannot exceed destination node's maximum stake <br><br> 🔒 **Security Features:** <br> - Prevents reward manipulation through mandatory claims <br> - Ensures accurate historical stake-based reward calculations <br> - Protects against over-staking nodes <br> - Maintains data integrity across multi-node positions